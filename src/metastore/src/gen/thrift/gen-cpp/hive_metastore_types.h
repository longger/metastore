/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef hive_metastore_TYPES_H
#define hive_metastore_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "fb303_types.h"


namespace Apache { namespace Hadoop { namespace Hive {

struct HiveObjectType {
  enum type {
    GLOBAL = 1,
    DATABASE = 2,
    TABLE = 3,
    PARTITION = 4,
    COLUMN = 5,
    SCHEMA = 6
  };
};

extern const std::map<int, const char*> _HiveObjectType_VALUES_TO_NAMES;

struct PrincipalType {
  enum type {
    USER = 1,
    ROLE = 2,
    GROUP = 3
  };
};

extern const std::map<int, const char*> _PrincipalType_VALUES_TO_NAMES;

struct PartitionEventType {
  enum type {
    LOAD_DONE = 1
  };
};

extern const std::map<int, const char*> _PartitionEventType_VALUES_TO_NAMES;

struct FOFailReason {
  enum type {
    INVALID_NODE = 1,
    INVALID_TABLE = 2,
    INVALID_FILE = 3,
    INVALID_SPLIT_VALUES = 4,
    INVALID_ATTRIBUTION = 5,
    INVALID_NODE_GROUPS = 6,
    NOSPACE = 10,
    NOTEXIST = 11,
    SAFEMODE = 12,
    INVALID_STATE = 13,
    TRY_AGAIN = 14
  };
};

extern const std::map<int, const char*> _FOFailReason_VALUES_TO_NAMES;

struct FindNodePolicy {
  enum type {
    ALL_NGS = 1,
    SINGLE_NG = 2
  };
};

extern const std::map<int, const char*> _FindNodePolicy_VALUES_TO_NAMES;

struct MSOperation {
  enum type {
    EXPLAIN = 1,
    CREATEDATABASE = 2,
    DROPDATABASE = 3,
    DROPTABLE = 4,
    DESCTABLE = 5,
    ALTERTABLE_RENAME = 6,
    ALTERTABLE_RENAMECOL = 7,
    ALTERTABLE_ADDPARTS = 8,
    ALTERTABLE_DROPPARTS = 9,
    ALTERTABLE_ADDCOLS = 10,
    ALTERTABLE_REPLACECOLS = 11,
    ALTERTABLE_RENAMEPART = 12,
    ALTERTABLE_PROPERTIES = 13,
    SHOWDATABASES = 14,
    SHOWTABLES = 15,
    SHOWCOLUMNS = 16,
    SHOW_TABLESTATUS = 17,
    SHOW_TBLPROPERTIES = 18,
    SHOW_CREATETABLE = 19,
    SHOWINDEXES = 20,
    SHOWPARTITIONS = 21,
    CREATEVIEW = 22,
    DROPVIEW = 23,
    CREATEINDEX = 24,
    DROPINDEX = 25,
    ALTERINDEX_REBUILD = 26,
    ALTERVIEW_PROPERTIES = 27,
    CREATEUSER = 28,
    DROPUSER = 29,
    CHANGE_PWD = 30,
    AUTHENTICATION = 31,
    SHOW_USERNAMES = 32,
    CREATEROLE = 33,
    DROPROLE = 34,
    GRANT_PRIVILEGE = 35,
    REVOKE_PRIVILEGE = 36,
    SHOW_GRANT = 37,
    GRANT_ROLE = 38,
    REVOKE_ROLE = 39,
    SHOW_ROLE_GRANT = 40,
    CREATETABLE = 41,
    QUERY = 42,
    ALTERINDEX_PROPS = 43,
    ALTERDATABASE = 44,
    DESCDATABASE = 45,
    ALTERTABLE_DROP_PROPERTIES = 46
  };
};

extern const std::map<int, const char*> _MSOperation_VALUES_TO_NAMES;

struct CreateOperation {
  enum type {
    CREATE_NEW = 1,
    CREATE_IF_NOT_EXIST_AND_GET_IF_EXIST = 2,
    CREATE_NEW_IN_NODEGROUPS = 3,
    CREATE_AUX_IDX_FILE = 4,
    CREATE_NEW_RANDOM = 5
  };
};

extern const std::map<int, const char*> _CreateOperation_VALUES_TO_NAMES;

typedef struct _Version__isset {
  _Version__isset() : version(false), comments(false) {}
  bool version;
  bool comments;
} _Version__isset;

class Version {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  Version() : version(), comments() {
  }

  virtual ~Version() throw() {}

  std::string version;
  std::string comments;

  _Version__isset __isset;

  void __set_version(const std::string& val) {
    version = val;
  }

  void __set_comments(const std::string& val) {
    comments = val;
  }

  bool operator == (const Version & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (!(comments == rhs.comments))
      return false;
    return true;
  }
  bool operator != (const Version &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Version & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Version &a, Version &b);

typedef struct _FieldSchema__isset {
  _FieldSchema__isset() : name(false), type(false), comment(false), version(false) {}
  bool name;
  bool type;
  bool comment;
  bool version;
} _FieldSchema__isset;

class FieldSchema {
 public:

  static const char* ascii_fingerprint; // = "1B53D3FAC5A5CFD45E7E867DA6314FAB";
  static const uint8_t binary_fingerprint[16]; // = {0x1B,0x53,0xD3,0xFA,0xC5,0xA5,0xCF,0xD4,0x5E,0x7E,0x86,0x7D,0xA6,0x31,0x4F,0xAB};

  FieldSchema() : name(), type(), comment(), version(0) {
  }

  virtual ~FieldSchema() throw() {}

  std::string name;
  std::string type;
  std::string comment;
  int64_t version;

  _FieldSchema__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_type(const std::string& val) {
    type = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
  }

  void __set_version(const int64_t val) {
    version = val;
    __isset.version = true;
  }

  bool operator == (const FieldSchema & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(comment == rhs.comment))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const FieldSchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FieldSchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FieldSchema &a, FieldSchema &b);

typedef struct _Type__isset {
  _Type__isset() : name(false), type1(false), type2(false), fields(false) {}
  bool name;
  bool type1;
  bool type2;
  bool fields;
} _Type__isset;

class Type {
 public:

  static const char* ascii_fingerprint; // = "29EF6A23B5200F7867A886B32E338605";
  static const uint8_t binary_fingerprint[16]; // = {0x29,0xEF,0x6A,0x23,0xB5,0x20,0x0F,0x78,0x67,0xA8,0x86,0xB3,0x2E,0x33,0x86,0x05};

  Type() : name(), type1(), type2() {
  }

  virtual ~Type() throw() {}

  std::string name;
  std::string type1;
  std::string type2;
  std::vector<FieldSchema>  fields;

  _Type__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_type1(const std::string& val) {
    type1 = val;
    __isset.type1 = true;
  }

  void __set_type2(const std::string& val) {
    type2 = val;
    __isset.type2 = true;
  }

  void __set_fields(const std::vector<FieldSchema> & val) {
    fields = val;
    __isset.fields = true;
  }

  bool operator == (const Type & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.type1 != rhs.__isset.type1)
      return false;
    else if (__isset.type1 && !(type1 == rhs.type1))
      return false;
    if (__isset.type2 != rhs.__isset.type2)
      return false;
    else if (__isset.type2 && !(type2 == rhs.type2))
      return false;
    if (__isset.fields != rhs.__isset.fields)
      return false;
    else if (__isset.fields && !(fields == rhs.fields))
      return false;
    return true;
  }
  bool operator != (const Type &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Type & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Type &a, Type &b);

typedef struct _HiveObjectRef__isset {
  _HiveObjectRef__isset() : objectType(false), dbName(false), objectName(false), partValues(false), columnName(false) {}
  bool objectType;
  bool dbName;
  bool objectName;
  bool partValues;
  bool columnName;
} _HiveObjectRef__isset;

class HiveObjectRef {
 public:

  static const char* ascii_fingerprint; // = "205CD8311CF3AA9EC161BAEF8D7C933C";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0x5C,0xD8,0x31,0x1C,0xF3,0xAA,0x9E,0xC1,0x61,0xBA,0xEF,0x8D,0x7C,0x93,0x3C};

  HiveObjectRef() : objectType((HiveObjectType::type)0), dbName(), objectName(), columnName() {
  }

  virtual ~HiveObjectRef() throw() {}

  HiveObjectType::type objectType;
  std::string dbName;
  std::string objectName;
  std::vector<std::string>  partValues;
  std::string columnName;

  _HiveObjectRef__isset __isset;

  void __set_objectType(const HiveObjectType::type val) {
    objectType = val;
  }

  void __set_dbName(const std::string& val) {
    dbName = val;
  }

  void __set_objectName(const std::string& val) {
    objectName = val;
  }

  void __set_partValues(const std::vector<std::string> & val) {
    partValues = val;
  }

  void __set_columnName(const std::string& val) {
    columnName = val;
  }

  bool operator == (const HiveObjectRef & rhs) const
  {
    if (!(objectType == rhs.objectType))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(objectName == rhs.objectName))
      return false;
    if (!(partValues == rhs.partValues))
      return false;
    if (!(columnName == rhs.columnName))
      return false;
    return true;
  }
  bool operator != (const HiveObjectRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HiveObjectRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(HiveObjectRef &a, HiveObjectRef &b);

typedef struct _PrivilegeGrantInfo__isset {
  _PrivilegeGrantInfo__isset() : privilege(false), createTime(false), grantor(false), grantorType(false), grantOption(false) {}
  bool privilege;
  bool createTime;
  bool grantor;
  bool grantorType;
  bool grantOption;
} _PrivilegeGrantInfo__isset;

class PrivilegeGrantInfo {
 public:

  static const char* ascii_fingerprint; // = "A58923AF7294BE492D6F90E07E8CEE1F";
  static const uint8_t binary_fingerprint[16]; // = {0xA5,0x89,0x23,0xAF,0x72,0x94,0xBE,0x49,0x2D,0x6F,0x90,0xE0,0x7E,0x8C,0xEE,0x1F};

  PrivilegeGrantInfo() : privilege(), createTime(0), grantor(), grantorType((PrincipalType::type)0), grantOption(0) {
  }

  virtual ~PrivilegeGrantInfo() throw() {}

  std::string privilege;
  int32_t createTime;
  std::string grantor;
  PrincipalType::type grantorType;
  bool grantOption;

  _PrivilegeGrantInfo__isset __isset;

  void __set_privilege(const std::string& val) {
    privilege = val;
  }

  void __set_createTime(const int32_t val) {
    createTime = val;
  }

  void __set_grantor(const std::string& val) {
    grantor = val;
  }

  void __set_grantorType(const PrincipalType::type val) {
    grantorType = val;
  }

  void __set_grantOption(const bool val) {
    grantOption = val;
  }

  bool operator == (const PrivilegeGrantInfo & rhs) const
  {
    if (!(privilege == rhs.privilege))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(grantor == rhs.grantor))
      return false;
    if (!(grantorType == rhs.grantorType))
      return false;
    if (!(grantOption == rhs.grantOption))
      return false;
    return true;
  }
  bool operator != (const PrivilegeGrantInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrivilegeGrantInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PrivilegeGrantInfo &a, PrivilegeGrantInfo &b);

typedef struct _HiveObjectPrivilege__isset {
  _HiveObjectPrivilege__isset() : hiveObject(false), principalName(false), principalType(false), grantInfo(false) {}
  bool hiveObject;
  bool principalName;
  bool principalType;
  bool grantInfo;
} _HiveObjectPrivilege__isset;

class HiveObjectPrivilege {
 public:

  static const char* ascii_fingerprint; // = "83D71969B23BD853E29DBA9D43B29AF8";
  static const uint8_t binary_fingerprint[16]; // = {0x83,0xD7,0x19,0x69,0xB2,0x3B,0xD8,0x53,0xE2,0x9D,0xBA,0x9D,0x43,0xB2,0x9A,0xF8};

  HiveObjectPrivilege() : principalName(), principalType((PrincipalType::type)0) {
  }

  virtual ~HiveObjectPrivilege() throw() {}

  HiveObjectRef hiveObject;
  std::string principalName;
  PrincipalType::type principalType;
  PrivilegeGrantInfo grantInfo;

  _HiveObjectPrivilege__isset __isset;

  void __set_hiveObject(const HiveObjectRef& val) {
    hiveObject = val;
  }

  void __set_principalName(const std::string& val) {
    principalName = val;
  }

  void __set_principalType(const PrincipalType::type val) {
    principalType = val;
  }

  void __set_grantInfo(const PrivilegeGrantInfo& val) {
    grantInfo = val;
  }

  bool operator == (const HiveObjectPrivilege & rhs) const
  {
    if (!(hiveObject == rhs.hiveObject))
      return false;
    if (!(principalName == rhs.principalName))
      return false;
    if (!(principalType == rhs.principalType))
      return false;
    if (!(grantInfo == rhs.grantInfo))
      return false;
    return true;
  }
  bool operator != (const HiveObjectPrivilege &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HiveObjectPrivilege & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(HiveObjectPrivilege &a, HiveObjectPrivilege &b);

typedef struct _PrivilegeBag__isset {
  _PrivilegeBag__isset() : privileges(false) {}
  bool privileges;
} _PrivilegeBag__isset;

class PrivilegeBag {
 public:

  static const char* ascii_fingerprint; // = "BB89E4701B7B709B046A74C90B1147F2";
  static const uint8_t binary_fingerprint[16]; // = {0xBB,0x89,0xE4,0x70,0x1B,0x7B,0x70,0x9B,0x04,0x6A,0x74,0xC9,0x0B,0x11,0x47,0xF2};

  PrivilegeBag() {
  }

  virtual ~PrivilegeBag() throw() {}

  std::vector<HiveObjectPrivilege>  privileges;

  _PrivilegeBag__isset __isset;

  void __set_privileges(const std::vector<HiveObjectPrivilege> & val) {
    privileges = val;
  }

  bool operator == (const PrivilegeBag & rhs) const
  {
    if (!(privileges == rhs.privileges))
      return false;
    return true;
  }
  bool operator != (const PrivilegeBag &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrivilegeBag & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PrivilegeBag &a, PrivilegeBag &b);

typedef struct _PrincipalPrivilegeSet__isset {
  _PrincipalPrivilegeSet__isset() : userPrivileges(false), groupPrivileges(false), rolePrivileges(false) {}
  bool userPrivileges;
  bool groupPrivileges;
  bool rolePrivileges;
} _PrincipalPrivilegeSet__isset;

class PrincipalPrivilegeSet {
 public:

  static const char* ascii_fingerprint; // = "08F75D2533906EA87BE34EA640856683";
  static const uint8_t binary_fingerprint[16]; // = {0x08,0xF7,0x5D,0x25,0x33,0x90,0x6E,0xA8,0x7B,0xE3,0x4E,0xA6,0x40,0x85,0x66,0x83};

  PrincipalPrivilegeSet() {
  }

  virtual ~PrincipalPrivilegeSet() throw() {}

  std::map<std::string, std::vector<PrivilegeGrantInfo> >  userPrivileges;
  std::map<std::string, std::vector<PrivilegeGrantInfo> >  groupPrivileges;
  std::map<std::string, std::vector<PrivilegeGrantInfo> >  rolePrivileges;

  _PrincipalPrivilegeSet__isset __isset;

  void __set_userPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
    userPrivileges = val;
  }

  void __set_groupPrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
    groupPrivileges = val;
  }

  void __set_rolePrivileges(const std::map<std::string, std::vector<PrivilegeGrantInfo> > & val) {
    rolePrivileges = val;
  }

  bool operator == (const PrincipalPrivilegeSet & rhs) const
  {
    if (!(userPrivileges == rhs.userPrivileges))
      return false;
    if (!(groupPrivileges == rhs.groupPrivileges))
      return false;
    if (!(rolePrivileges == rhs.rolePrivileges))
      return false;
    return true;
  }
  bool operator != (const PrincipalPrivilegeSet &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PrincipalPrivilegeSet & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PrincipalPrivilegeSet &a, PrincipalPrivilegeSet &b);

typedef struct _statfs__isset {
  _statfs__isset() : from(false), to(false), increate(false), close(false), replicated(false), rm_logical(false), rm_physical(false), underrep(false), overrep(false), linger(false), suspect(false), inc_ons(false), inc_ons2(false), cls_offs(false), incs(false), clos(false), fnrs(false), recordnr(false), length(false) {}
  bool from;
  bool to;
  bool increate;
  bool close;
  bool replicated;
  bool rm_logical;
  bool rm_physical;
  bool underrep;
  bool overrep;
  bool linger;
  bool suspect;
  bool inc_ons;
  bool inc_ons2;
  bool cls_offs;
  bool incs;
  bool clos;
  bool fnrs;
  bool recordnr;
  bool length;
} _statfs__isset;

class statfs {
 public:

  static const char* ascii_fingerprint; // = "E1F7C501B5B805C4D8CDA5C49FD0ACFA";
  static const uint8_t binary_fingerprint[16]; // = {0xE1,0xF7,0xC5,0x01,0xB5,0xB8,0x05,0xC4,0xD8,0xCD,0xA5,0xC4,0x9F,0xD0,0xAC,0xFA};

  statfs() : from(0), to(0), increate(0), close(0), replicated(0), rm_logical(0), rm_physical(0), underrep(0), overrep(0), linger(0), suspect(0), inc_ons(0), inc_ons2(0), cls_offs(0), recordnr(0), length(0) {
  }

  virtual ~statfs() throw() {}

  int64_t from;
  int64_t to;
  int64_t increate;
  int64_t close;
  int64_t replicated;
  int64_t rm_logical;
  int64_t rm_physical;
  int64_t underrep;
  int64_t overrep;
  int64_t linger;
  int64_t suspect;
  int64_t inc_ons;
  int64_t inc_ons2;
  int64_t cls_offs;
  std::vector<int64_t>  incs;
  std::vector<int64_t>  clos;
  std::map<std::string, int64_t>  fnrs;
  int64_t recordnr;
  int64_t length;

  _statfs__isset __isset;

  void __set_from(const int64_t val) {
    from = val;
  }

  void __set_to(const int64_t val) {
    to = val;
  }

  void __set_increate(const int64_t val) {
    increate = val;
  }

  void __set_close(const int64_t val) {
    close = val;
  }

  void __set_replicated(const int64_t val) {
    replicated = val;
  }

  void __set_rm_logical(const int64_t val) {
    rm_logical = val;
  }

  void __set_rm_physical(const int64_t val) {
    rm_physical = val;
  }

  void __set_underrep(const int64_t val) {
    underrep = val;
  }

  void __set_overrep(const int64_t val) {
    overrep = val;
  }

  void __set_linger(const int64_t val) {
    linger = val;
  }

  void __set_suspect(const int64_t val) {
    suspect = val;
  }

  void __set_inc_ons(const int64_t val) {
    inc_ons = val;
  }

  void __set_inc_ons2(const int64_t val) {
    inc_ons2 = val;
  }

  void __set_cls_offs(const int64_t val) {
    cls_offs = val;
  }

  void __set_incs(const std::vector<int64_t> & val) {
    incs = val;
  }

  void __set_clos(const std::vector<int64_t> & val) {
    clos = val;
  }

  void __set_fnrs(const std::map<std::string, int64_t> & val) {
    fnrs = val;
  }

  void __set_recordnr(const int64_t val) {
    recordnr = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  bool operator == (const statfs & rhs) const
  {
    if (!(from == rhs.from))
      return false;
    if (!(to == rhs.to))
      return false;
    if (!(increate == rhs.increate))
      return false;
    if (!(close == rhs.close))
      return false;
    if (!(replicated == rhs.replicated))
      return false;
    if (!(rm_logical == rhs.rm_logical))
      return false;
    if (!(rm_physical == rhs.rm_physical))
      return false;
    if (!(underrep == rhs.underrep))
      return false;
    if (!(overrep == rhs.overrep))
      return false;
    if (!(linger == rhs.linger))
      return false;
    if (!(suspect == rhs.suspect))
      return false;
    if (!(inc_ons == rhs.inc_ons))
      return false;
    if (!(inc_ons2 == rhs.inc_ons2))
      return false;
    if (!(cls_offs == rhs.cls_offs))
      return false;
    if (!(incs == rhs.incs))
      return false;
    if (!(clos == rhs.clos))
      return false;
    if (!(fnrs == rhs.fnrs))
      return false;
    if (!(recordnr == rhs.recordnr))
      return false;
    if (!(length == rhs.length))
      return false;
    return true;
  }
  bool operator != (const statfs &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const statfs & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(statfs &a, statfs &b);

typedef struct _Role__isset {
  _Role__isset() : roleName(false), createTime(false), ownerName(false) {}
  bool roleName;
  bool createTime;
  bool ownerName;
} _Role__isset;

class Role {
 public:

  static const char* ascii_fingerprint; // = "70563A0628F75DF9555F4D24690B1E26";
  static const uint8_t binary_fingerprint[16]; // = {0x70,0x56,0x3A,0x06,0x28,0xF7,0x5D,0xF9,0x55,0x5F,0x4D,0x24,0x69,0x0B,0x1E,0x26};

  Role() : roleName(), createTime(0), ownerName() {
  }

  virtual ~Role() throw() {}

  std::string roleName;
  int32_t createTime;
  std::string ownerName;

  _Role__isset __isset;

  void __set_roleName(const std::string& val) {
    roleName = val;
  }

  void __set_createTime(const int32_t val) {
    createTime = val;
  }

  void __set_ownerName(const std::string& val) {
    ownerName = val;
  }

  bool operator == (const Role & rhs) const
  {
    if (!(roleName == rhs.roleName))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(ownerName == rhs.ownerName))
      return false;
    return true;
  }
  bool operator != (const Role &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Role & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Role &a, Role &b);

typedef struct _User__isset {
  _User__isset() : userName(false), password(false), createTime(false), ownerName(false) {}
  bool userName;
  bool password;
  bool createTime;
  bool ownerName;
} _User__isset;

class User {
 public:

  static const char* ascii_fingerprint; // = "67CA7CC4061D5EB7B29D9595C88340E6";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0xCA,0x7C,0xC4,0x06,0x1D,0x5E,0xB7,0xB2,0x9D,0x95,0x95,0xC8,0x83,0x40,0xE6};

  User() : userName(), password(), createTime(0), ownerName() {
  }

  virtual ~User() throw() {}

  std::string userName;
  std::string password;
  int64_t createTime;
  std::string ownerName;

  _User__isset __isset;

  void __set_userName(const std::string& val) {
    userName = val;
  }

  void __set_password(const std::string& val) {
    password = val;
  }

  void __set_createTime(const int64_t val) {
    createTime = val;
  }

  void __set_ownerName(const std::string& val) {
    ownerName = val;
  }

  bool operator == (const User & rhs) const
  {
    if (!(userName == rhs.userName))
      return false;
    if (!(password == rhs.password))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(ownerName == rhs.ownerName))
      return false;
    return true;
  }
  bool operator != (const User &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const User & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(User &a, User &b);

typedef struct _Node__isset {
  _Node__isset() : node_name(false), ips(false), status(false) {}
  bool node_name;
  bool ips;
  bool status;
} _Node__isset;

class Node {
 public:

  static const char* ascii_fingerprint; // = "2B861B7093B3DC2A61450349FC883477";
  static const uint8_t binary_fingerprint[16]; // = {0x2B,0x86,0x1B,0x70,0x93,0xB3,0xDC,0x2A,0x61,0x45,0x03,0x49,0xFC,0x88,0x34,0x77};

  Node() : node_name(), status(0) {
  }

  virtual ~Node() throw() {}

  std::string node_name;
  std::vector<std::string>  ips;
  int32_t status;

  _Node__isset __isset;

  void __set_node_name(const std::string& val) {
    node_name = val;
  }

  void __set_ips(const std::vector<std::string> & val) {
    ips = val;
  }

  void __set_status(const int32_t val) {
    status = val;
  }

  bool operator == (const Node & rhs) const
  {
    if (!(node_name == rhs.node_name))
      return false;
    if (!(ips == rhs.ips))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const Node &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Node &a, Node &b);

typedef struct _NodeGroup__isset {
  _NodeGroup__isset() : node_group_name(false), comment(false), status(false), nodes(false) {}
  bool node_group_name;
  bool comment;
  bool status;
  bool nodes;
} _NodeGroup__isset;

class NodeGroup {
 public:

  static const char* ascii_fingerprint; // = "E71E2D61367D2C720DB7E3DEBA98BF91";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x1E,0x2D,0x61,0x36,0x7D,0x2C,0x72,0x0D,0xB7,0xE3,0xDE,0xBA,0x98,0xBF,0x91};

  NodeGroup() : node_group_name(), comment(), status(0) {
  }

  virtual ~NodeGroup() throw() {}

  std::string node_group_name;
  std::string comment;
  int32_t status;
  std::set<Node>  nodes;

  _NodeGroup__isset __isset;

  void __set_node_group_name(const std::string& val) {
    node_group_name = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
  }

  void __set_status(const int32_t val) {
    status = val;
  }

  void __set_nodes(const std::set<Node> & val) {
    nodes = val;
  }

  bool operator == (const NodeGroup & rhs) const
  {
    if (!(node_group_name == rhs.node_group_name))
      return false;
    if (!(comment == rhs.comment))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(nodes == rhs.nodes))
      return false;
    return true;
  }
  bool operator != (const NodeGroup &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NodeGroup & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NodeGroup &a, NodeGroup &b);

typedef struct _Database__isset {
  _Database__isset() : name(false), description(false), locationUri(false), parameters(false), privileges(false) {}
  bool name;
  bool description;
  bool locationUri;
  bool parameters;
  bool privileges;
} _Database__isset;

class Database {
 public:

  static const char* ascii_fingerprint; // = "213967572143E49C9F1A23F7A866E2F5";
  static const uint8_t binary_fingerprint[16]; // = {0x21,0x39,0x67,0x57,0x21,0x43,0xE4,0x9C,0x9F,0x1A,0x23,0xF7,0xA8,0x66,0xE2,0xF5};

  Database() : name(), description(), locationUri() {
  }

  virtual ~Database() throw() {}

  std::string name;
  std::string description;
  std::string locationUri;
  std::map<std::string, std::string>  parameters;
  PrincipalPrivilegeSet privileges;

  _Database__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_description(const std::string& val) {
    description = val;
  }

  void __set_locationUri(const std::string& val) {
    locationUri = val;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
  }

  void __set_privileges(const PrincipalPrivilegeSet& val) {
    privileges = val;
    __isset.privileges = true;
  }

  bool operator == (const Database & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(locationUri == rhs.locationUri))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    return true;
  }
  bool operator != (const Database &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Database & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Database &a, Database &b);

typedef struct _SerDeInfo__isset {
  _SerDeInfo__isset() : name(false), serializationLib(false), parameters(false) {}
  bool name;
  bool serializationLib;
  bool parameters;
} _SerDeInfo__isset;

class SerDeInfo {
 public:

  static const char* ascii_fingerprint; // = "B1021C32A35A2AEFCD2F57A5424159A7";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x02,0x1C,0x32,0xA3,0x5A,0x2A,0xEF,0xCD,0x2F,0x57,0xA5,0x42,0x41,0x59,0xA7};

  SerDeInfo() : name(), serializationLib() {
  }

  virtual ~SerDeInfo() throw() {}

  std::string name;
  std::string serializationLib;
  std::map<std::string, std::string>  parameters;

  _SerDeInfo__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_serializationLib(const std::string& val) {
    serializationLib = val;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
  }

  bool operator == (const SerDeInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(serializationLib == rhs.serializationLib))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    return true;
  }
  bool operator != (const SerDeInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SerDeInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SerDeInfo &a, SerDeInfo &b);

typedef struct _Order__isset {
  _Order__isset() : col(false), order(false) {}
  bool col;
  bool order;
} _Order__isset;

class Order {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  Order() : col(), order(0) {
  }

  virtual ~Order() throw() {}

  std::string col;
  int32_t order;

  _Order__isset __isset;

  void __set_col(const std::string& val) {
    col = val;
  }

  void __set_order(const int32_t val) {
    order = val;
  }

  bool operator == (const Order & rhs) const
  {
    if (!(col == rhs.col))
      return false;
    if (!(order == rhs.order))
      return false;
    return true;
  }
  bool operator != (const Order &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Order & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Order &a, Order &b);

typedef struct _SkewedInfo__isset {
  _SkewedInfo__isset() : skewedColNames(false), skewedColValues(false), skewedColValueLocationMaps(false) {}
  bool skewedColNames;
  bool skewedColValues;
  bool skewedColValueLocationMaps;
} _SkewedInfo__isset;

class SkewedInfo {
 public:

  static const char* ascii_fingerprint; // = "4BF2ED84BC3C3EB297A2AE2FA8427EB1";
  static const uint8_t binary_fingerprint[16]; // = {0x4B,0xF2,0xED,0x84,0xBC,0x3C,0x3E,0xB2,0x97,0xA2,0xAE,0x2F,0xA8,0x42,0x7E,0xB1};

  SkewedInfo() {
  }

  virtual ~SkewedInfo() throw() {}

  std::vector<std::string>  skewedColNames;
  std::vector<std::vector<std::string> >  skewedColValues;
  std::map<std::vector<std::string> , std::string>  skewedColValueLocationMaps;

  _SkewedInfo__isset __isset;

  void __set_skewedColNames(const std::vector<std::string> & val) {
    skewedColNames = val;
  }

  void __set_skewedColValues(const std::vector<std::vector<std::string> > & val) {
    skewedColValues = val;
  }

  void __set_skewedColValueLocationMaps(const std::map<std::vector<std::string> , std::string> & val) {
    skewedColValueLocationMaps = val;
  }

  bool operator == (const SkewedInfo & rhs) const
  {
    if (!(skewedColNames == rhs.skewedColNames))
      return false;
    if (!(skewedColValues == rhs.skewedColValues))
      return false;
    if (!(skewedColValueLocationMaps == rhs.skewedColValueLocationMaps))
      return false;
    return true;
  }
  bool operator != (const SkewedInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SkewedInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SkewedInfo &a, SkewedInfo &b);

typedef struct _StorageDescriptor__isset {
  _StorageDescriptor__isset() : cols(false), location(false), inputFormat(false), outputFormat(false), compressed(false), numBuckets(false), serdeInfo(false), bucketCols(false), sortCols(false), parameters(false), skewedInfo(false), storedAsSubDirectories(false) {}
  bool cols;
  bool location;
  bool inputFormat;
  bool outputFormat;
  bool compressed;
  bool numBuckets;
  bool serdeInfo;
  bool bucketCols;
  bool sortCols;
  bool parameters;
  bool skewedInfo;
  bool storedAsSubDirectories;
} _StorageDescriptor__isset;

class StorageDescriptor {
 public:

  static const char* ascii_fingerprint; // = "3345F7499CCEE403945059A63592A00D";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x45,0xF7,0x49,0x9C,0xCE,0xE4,0x03,0x94,0x50,0x59,0xA6,0x35,0x92,0xA0,0x0D};

  StorageDescriptor() : location(), inputFormat(), outputFormat(), compressed(0), numBuckets(0), storedAsSubDirectories(0) {
  }

  virtual ~StorageDescriptor() throw() {}

  std::vector<FieldSchema>  cols;
  std::string location;
  std::string inputFormat;
  std::string outputFormat;
  bool compressed;
  int32_t numBuckets;
  SerDeInfo serdeInfo;
  std::vector<std::string>  bucketCols;
  std::vector<Order>  sortCols;
  std::map<std::string, std::string>  parameters;
  SkewedInfo skewedInfo;
  bool storedAsSubDirectories;

  _StorageDescriptor__isset __isset;

  void __set_cols(const std::vector<FieldSchema> & val) {
    cols = val;
  }

  void __set_location(const std::string& val) {
    location = val;
  }

  void __set_inputFormat(const std::string& val) {
    inputFormat = val;
  }

  void __set_outputFormat(const std::string& val) {
    outputFormat = val;
  }

  void __set_compressed(const bool val) {
    compressed = val;
  }

  void __set_numBuckets(const int32_t val) {
    numBuckets = val;
  }

  void __set_serdeInfo(const SerDeInfo& val) {
    serdeInfo = val;
  }

  void __set_bucketCols(const std::vector<std::string> & val) {
    bucketCols = val;
  }

  void __set_sortCols(const std::vector<Order> & val) {
    sortCols = val;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
  }

  void __set_skewedInfo(const SkewedInfo& val) {
    skewedInfo = val;
    __isset.skewedInfo = true;
  }

  void __set_storedAsSubDirectories(const bool val) {
    storedAsSubDirectories = val;
    __isset.storedAsSubDirectories = true;
  }

  bool operator == (const StorageDescriptor & rhs) const
  {
    if (!(cols == rhs.cols))
      return false;
    if (!(location == rhs.location))
      return false;
    if (!(inputFormat == rhs.inputFormat))
      return false;
    if (!(outputFormat == rhs.outputFormat))
      return false;
    if (!(compressed == rhs.compressed))
      return false;
    if (!(numBuckets == rhs.numBuckets))
      return false;
    if (!(serdeInfo == rhs.serdeInfo))
      return false;
    if (!(bucketCols == rhs.bucketCols))
      return false;
    if (!(sortCols == rhs.sortCols))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (__isset.skewedInfo != rhs.__isset.skewedInfo)
      return false;
    else if (__isset.skewedInfo && !(skewedInfo == rhs.skewedInfo))
      return false;
    if (__isset.storedAsSubDirectories != rhs.__isset.storedAsSubDirectories)
      return false;
    else if (__isset.storedAsSubDirectories && !(storedAsSubDirectories == rhs.storedAsSubDirectories))
      return false;
    return true;
  }
  bool operator != (const StorageDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StorageDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StorageDescriptor &a, StorageDescriptor &b);

typedef struct _Subpartition__isset {
  _Subpartition__isset() : values(false), dbName(false), tableName(false), createTime(false), lastAccessTime(false), sd(false), parameters(false), files(false), partitionName(false), version(false), privileges(false) {}
  bool values;
  bool dbName;
  bool tableName;
  bool createTime;
  bool lastAccessTime;
  bool sd;
  bool parameters;
  bool files;
  bool partitionName;
  bool version;
  bool privileges;
} _Subpartition__isset;

class Subpartition {
 public:

  static const char* ascii_fingerprint; // = "7480A1CF039EAE14C6BD666DB7657BD7";
  static const uint8_t binary_fingerprint[16]; // = {0x74,0x80,0xA1,0xCF,0x03,0x9E,0xAE,0x14,0xC6,0xBD,0x66,0x6D,0xB7,0x65,0x7B,0xD7};

  Subpartition() : dbName(), tableName(), createTime(0), lastAccessTime(0), partitionName(), version(0) {
  }

  virtual ~Subpartition() throw() {}

  std::vector<std::string>  values;
  std::string dbName;
  std::string tableName;
  int32_t createTime;
  int32_t lastAccessTime;
  StorageDescriptor sd;
  std::map<std::string, std::string>  parameters;
  std::vector<int64_t>  files;
  std::string partitionName;
  int32_t version;
  PrincipalPrivilegeSet privileges;

  _Subpartition__isset __isset;

  void __set_values(const std::vector<std::string> & val) {
    values = val;
  }

  void __set_dbName(const std::string& val) {
    dbName = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_createTime(const int32_t val) {
    createTime = val;
  }

  void __set_lastAccessTime(const int32_t val) {
    lastAccessTime = val;
  }

  void __set_sd(const StorageDescriptor& val) {
    sd = val;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
  }

  void __set_files(const std::vector<int64_t> & val) {
    files = val;
  }

  void __set_partitionName(const std::string& val) {
    partitionName = val;
    __isset.partitionName = true;
  }

  void __set_version(const int32_t val) {
    version = val;
    __isset.version = true;
  }

  void __set_privileges(const PrincipalPrivilegeSet& val) {
    privileges = val;
    __isset.privileges = true;
  }

  bool operator == (const Subpartition & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(sd == rhs.sd))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (!(files == rhs.files))
      return false;
    if (__isset.partitionName != rhs.__isset.partitionName)
      return false;
    else if (__isset.partitionName && !(partitionName == rhs.partitionName))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    return true;
  }
  bool operator != (const Subpartition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Subpartition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Subpartition &a, Subpartition &b);

typedef struct _Partition__isset {
  _Partition__isset() : values(false), dbName(false), tableName(false), createTime(false), lastAccessTime(false), sd(false), parameters(false), files(false), partitionName(false), subpartitions(false), version(false), privileges(false) {}
  bool values;
  bool dbName;
  bool tableName;
  bool createTime;
  bool lastAccessTime;
  bool sd;
  bool parameters;
  bool files;
  bool partitionName;
  bool subpartitions;
  bool version;
  bool privileges;
} _Partition__isset;

class Partition {
 public:

  static const char* ascii_fingerprint; // = "AC293B9C276BEF35347F3EA3BAA09827";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0x29,0x3B,0x9C,0x27,0x6B,0xEF,0x35,0x34,0x7F,0x3E,0xA3,0xBA,0xA0,0x98,0x27};

  Partition() : dbName(), tableName(), createTime(0), lastAccessTime(0), partitionName(), version(0) {
  }

  virtual ~Partition() throw() {}

  std::vector<std::string>  values;
  std::string dbName;
  std::string tableName;
  int32_t createTime;
  int32_t lastAccessTime;
  StorageDescriptor sd;
  std::map<std::string, std::string>  parameters;
  std::vector<int64_t>  files;
  std::string partitionName;
  std::vector<Subpartition>  subpartitions;
  int32_t version;
  PrincipalPrivilegeSet privileges;

  _Partition__isset __isset;

  void __set_values(const std::vector<std::string> & val) {
    values = val;
  }

  void __set_dbName(const std::string& val) {
    dbName = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_createTime(const int32_t val) {
    createTime = val;
  }

  void __set_lastAccessTime(const int32_t val) {
    lastAccessTime = val;
  }

  void __set_sd(const StorageDescriptor& val) {
    sd = val;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
  }

  void __set_files(const std::vector<int64_t> & val) {
    files = val;
  }

  void __set_partitionName(const std::string& val) {
    partitionName = val;
    __isset.partitionName = true;
  }

  void __set_subpartitions(const std::vector<Subpartition> & val) {
    subpartitions = val;
    __isset.subpartitions = true;
  }

  void __set_version(const int32_t val) {
    version = val;
    __isset.version = true;
  }

  void __set_privileges(const PrincipalPrivilegeSet& val) {
    privileges = val;
    __isset.privileges = true;
  }

  bool operator == (const Partition & rhs) const
  {
    if (!(values == rhs.values))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(sd == rhs.sd))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (!(files == rhs.files))
      return false;
    if (__isset.partitionName != rhs.__isset.partitionName)
      return false;
    else if (__isset.partitionName && !(partitionName == rhs.partitionName))
      return false;
    if (__isset.subpartitions != rhs.__isset.subpartitions)
      return false;
    else if (__isset.subpartitions && !(subpartitions == rhs.subpartitions))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    return true;
  }
  bool operator != (const Partition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Partition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Partition &a, Partition &b);

typedef struct _GlobalSchema__isset {
  _GlobalSchema__isset() : schemaName(false), owner(false), createTime(false), lastAccessTime(false), retention(false), sd(false), parameters(false), viewOriginalText(false), viewExpandedText(false), schemaType(false), privileges(false) {}
  bool schemaName;
  bool owner;
  bool createTime;
  bool lastAccessTime;
  bool retention;
  bool sd;
  bool parameters;
  bool viewOriginalText;
  bool viewExpandedText;
  bool schemaType;
  bool privileges;
} _GlobalSchema__isset;

class GlobalSchema {
 public:

  static const char* ascii_fingerprint; // = "8442BBEAF50292ADD3A520841ADCCBFA";
  static const uint8_t binary_fingerprint[16]; // = {0x84,0x42,0xBB,0xEA,0xF5,0x02,0x92,0xAD,0xD3,0xA5,0x20,0x84,0x1A,0xDC,0xCB,0xFA};

  GlobalSchema() : schemaName(), owner(), createTime(0), lastAccessTime(0), retention(0), viewOriginalText(), viewExpandedText(), schemaType() {
  }

  virtual ~GlobalSchema() throw() {}

  std::string schemaName;
  std::string owner;
  int32_t createTime;
  int32_t lastAccessTime;
  int32_t retention;
  StorageDescriptor sd;
  std::map<std::string, std::string>  parameters;
  std::string viewOriginalText;
  std::string viewExpandedText;
  std::string schemaType;
  PrincipalPrivilegeSet privileges;

  _GlobalSchema__isset __isset;

  void __set_schemaName(const std::string& val) {
    schemaName = val;
  }

  void __set_owner(const std::string& val) {
    owner = val;
  }

  void __set_createTime(const int32_t val) {
    createTime = val;
  }

  void __set_lastAccessTime(const int32_t val) {
    lastAccessTime = val;
  }

  void __set_retention(const int32_t val) {
    retention = val;
  }

  void __set_sd(const StorageDescriptor& val) {
    sd = val;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
  }

  void __set_viewOriginalText(const std::string& val) {
    viewOriginalText = val;
  }

  void __set_viewExpandedText(const std::string& val) {
    viewExpandedText = val;
  }

  void __set_schemaType(const std::string& val) {
    schemaType = val;
  }

  void __set_privileges(const PrincipalPrivilegeSet& val) {
    privileges = val;
    __isset.privileges = true;
  }

  bool operator == (const GlobalSchema & rhs) const
  {
    if (!(schemaName == rhs.schemaName))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(retention == rhs.retention))
      return false;
    if (!(sd == rhs.sd))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (!(viewOriginalText == rhs.viewOriginalText))
      return false;
    if (!(viewExpandedText == rhs.viewExpandedText))
      return false;
    if (!(schemaType == rhs.schemaType))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    return true;
  }
  bool operator != (const GlobalSchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GlobalSchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GlobalSchema &a, GlobalSchema &b);

typedef struct _Table__isset {
  _Table__isset() : tableName(false), dbName(false), schemaName(false), owner(false), createTime(false), lastAccessTime(false), retention(false), sd(false), partitionKeys(false), parameters(false), viewOriginalText(false), viewExpandedText(false), tableType(false), nodeGroups(false), privileges(false), partitions(false), fileSplitKeys(false) {}
  bool tableName;
  bool dbName;
  bool schemaName;
  bool owner;
  bool createTime;
  bool lastAccessTime;
  bool retention;
  bool sd;
  bool partitionKeys;
  bool parameters;
  bool viewOriginalText;
  bool viewExpandedText;
  bool tableType;
  bool nodeGroups;
  bool privileges;
  bool partitions;
  bool fileSplitKeys;
} _Table__isset;

class Table {
 public:

  static const char* ascii_fingerprint; // = "C68CCAEBD56326F2E7FA16995D0BA14A";
  static const uint8_t binary_fingerprint[16]; // = {0xC6,0x8C,0xCA,0xEB,0xD5,0x63,0x26,0xF2,0xE7,0xFA,0x16,0x99,0x5D,0x0B,0xA1,0x4A};

  Table() : tableName(), dbName(), schemaName(), owner(), createTime(0), lastAccessTime(0), retention(0), viewOriginalText(), viewExpandedText(), tableType() {
  }

  virtual ~Table() throw() {}

  std::string tableName;
  std::string dbName;
  std::string schemaName;
  std::string owner;
  int32_t createTime;
  int32_t lastAccessTime;
  int32_t retention;
  StorageDescriptor sd;
  std::vector<FieldSchema>  partitionKeys;
  std::map<std::string, std::string>  parameters;
  std::string viewOriginalText;
  std::string viewExpandedText;
  std::string tableType;
  std::vector<NodeGroup>  nodeGroups;
  PrincipalPrivilegeSet privileges;
  std::vector<Partition>  partitions;
  std::vector<FieldSchema>  fileSplitKeys;

  _Table__isset __isset;

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_dbName(const std::string& val) {
    dbName = val;
  }

  void __set_schemaName(const std::string& val) {
    schemaName = val;
  }

  void __set_owner(const std::string& val) {
    owner = val;
  }

  void __set_createTime(const int32_t val) {
    createTime = val;
  }

  void __set_lastAccessTime(const int32_t val) {
    lastAccessTime = val;
  }

  void __set_retention(const int32_t val) {
    retention = val;
  }

  void __set_sd(const StorageDescriptor& val) {
    sd = val;
  }

  void __set_partitionKeys(const std::vector<FieldSchema> & val) {
    partitionKeys = val;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
  }

  void __set_viewOriginalText(const std::string& val) {
    viewOriginalText = val;
  }

  void __set_viewExpandedText(const std::string& val) {
    viewExpandedText = val;
  }

  void __set_tableType(const std::string& val) {
    tableType = val;
  }

  void __set_nodeGroups(const std::vector<NodeGroup> & val) {
    nodeGroups = val;
  }

  void __set_privileges(const PrincipalPrivilegeSet& val) {
    privileges = val;
    __isset.privileges = true;
  }

  void __set_partitions(const std::vector<Partition> & val) {
    partitions = val;
    __isset.partitions = true;
  }

  void __set_fileSplitKeys(const std::vector<FieldSchema> & val) {
    fileSplitKeys = val;
  }

  bool operator == (const Table & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(schemaName == rhs.schemaName))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(retention == rhs.retention))
      return false;
    if (!(sd == rhs.sd))
      return false;
    if (!(partitionKeys == rhs.partitionKeys))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (!(viewOriginalText == rhs.viewOriginalText))
      return false;
    if (!(viewExpandedText == rhs.viewExpandedText))
      return false;
    if (!(tableType == rhs.tableType))
      return false;
    if (!(nodeGroups == rhs.nodeGroups))
      return false;
    if (__isset.privileges != rhs.__isset.privileges)
      return false;
    else if (__isset.privileges && !(privileges == rhs.privileges))
      return false;
    if (__isset.partitions != rhs.__isset.partitions)
      return false;
    else if (__isset.partitions && !(partitions == rhs.partitions))
      return false;
    if (!(fileSplitKeys == rhs.fileSplitKeys))
      return false;
    return true;
  }
  bool operator != (const Table &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Table & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Table &a, Table &b);

typedef struct _BusiTypeColumn__isset {
  _BusiTypeColumn__isset() : busiType(false), table(false), column(false) {}
  bool busiType;
  bool table;
  bool column;
} _BusiTypeColumn__isset;

class BusiTypeColumn {
 public:

  static const char* ascii_fingerprint; // = "4F6CF489081F4332C2A1BDB27E7884D7";
  static const uint8_t binary_fingerprint[16]; // = {0x4F,0x6C,0xF4,0x89,0x08,0x1F,0x43,0x32,0xC2,0xA1,0xBD,0xB2,0x7E,0x78,0x84,0xD7};

  BusiTypeColumn() : busiType(), column() {
  }

  virtual ~BusiTypeColumn() throw() {}

  std::string busiType;
  Table table;
  std::string column;

  _BusiTypeColumn__isset __isset;

  void __set_busiType(const std::string& val) {
    busiType = val;
  }

  void __set_table(const Table& val) {
    table = val;
  }

  void __set_column(const std::string& val) {
    column = val;
  }

  bool operator == (const BusiTypeColumn & rhs) const
  {
    if (!(busiType == rhs.busiType))
      return false;
    if (!(table == rhs.table))
      return false;
    if (!(column == rhs.column))
      return false;
    return true;
  }
  bool operator != (const BusiTypeColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BusiTypeColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BusiTypeColumn &a, BusiTypeColumn &b);

typedef struct _BusiTypeDatacenter__isset {
  _BusiTypeDatacenter__isset() : busiType(false), db(false) {}
  bool busiType;
  bool db;
} _BusiTypeDatacenter__isset;

class BusiTypeDatacenter {
 public:

  static const char* ascii_fingerprint; // = "3D42CF44649E64872587912574D1C399";
  static const uint8_t binary_fingerprint[16]; // = {0x3D,0x42,0xCF,0x44,0x64,0x9E,0x64,0x87,0x25,0x87,0x91,0x25,0x74,0xD1,0xC3,0x99};

  BusiTypeDatacenter() : busiType() {
  }

  virtual ~BusiTypeDatacenter() throw() {}

  std::string busiType;
  Database db;

  _BusiTypeDatacenter__isset __isset;

  void __set_busiType(const std::string& val) {
    busiType = val;
  }

  void __set_db(const Database& val) {
    db = val;
  }

  bool operator == (const BusiTypeDatacenter & rhs) const
  {
    if (!(busiType == rhs.busiType))
      return false;
    if (!(db == rhs.db))
      return false;
    return true;
  }
  bool operator != (const BusiTypeDatacenter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BusiTypeDatacenter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BusiTypeDatacenter &a, BusiTypeDatacenter &b);

typedef struct _SplitValue__isset {
  _SplitValue__isset() : splitKeyName(false), level(false), value(false), verison(false) {}
  bool splitKeyName;
  bool level;
  bool value;
  bool verison;
} _SplitValue__isset;

class SplitValue {
 public:

  static const char* ascii_fingerprint; // = "B26E3EE0F60BE71407EEDAFDE8E4D32D";
  static const uint8_t binary_fingerprint[16]; // = {0xB2,0x6E,0x3E,0xE0,0xF6,0x0B,0xE7,0x14,0x07,0xEE,0xDA,0xFD,0xE8,0xE4,0xD3,0x2D};

  SplitValue() : splitKeyName(), level(0), value(), verison(0) {
  }

  virtual ~SplitValue() throw() {}

  std::string splitKeyName;
  int32_t level;
  std::string value;
  int64_t verison;

  _SplitValue__isset __isset;

  void __set_splitKeyName(const std::string& val) {
    splitKeyName = val;
  }

  void __set_level(const int32_t val) {
    level = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  void __set_verison(const int64_t val) {
    verison = val;
  }

  bool operator == (const SplitValue & rhs) const
  {
    if (!(splitKeyName == rhs.splitKeyName))
      return false;
    if (!(level == rhs.level))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(verison == rhs.verison))
      return false;
    return true;
  }
  bool operator != (const SplitValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SplitValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SplitValue &a, SplitValue &b);

typedef struct _CreatePolicy__isset {
  _CreatePolicy__isset() : operation(false), arguments(false) {}
  bool operation;
  bool arguments;
} _CreatePolicy__isset;

class CreatePolicy {
 public:

  static const char* ascii_fingerprint; // = "A22BE3E84688C9DA4E00CC902B4EE818";
  static const uint8_t binary_fingerprint[16]; // = {0xA2,0x2B,0xE3,0xE8,0x46,0x88,0xC9,0xDA,0x4E,0x00,0xCC,0x90,0x2B,0x4E,0xE8,0x18};

  CreatePolicy() : operation((CreateOperation::type)0) {
  }

  virtual ~CreatePolicy() throw() {}

  CreateOperation::type operation;
  std::vector<std::string>  arguments;

  _CreatePolicy__isset __isset;

  void __set_operation(const CreateOperation::type val) {
    operation = val;
  }

  void __set_arguments(const std::vector<std::string> & val) {
    arguments = val;
  }

  bool operator == (const CreatePolicy & rhs) const
  {
    if (!(operation == rhs.operation))
      return false;
    if (!(arguments == rhs.arguments))
      return false;
    return true;
  }
  bool operator != (const CreatePolicy &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreatePolicy & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CreatePolicy &a, CreatePolicy &b);

typedef struct _Device__isset {
  _Device__isset() : devid(false), prop(false), node_name(false), status(false), ng_name(false) {}
  bool devid;
  bool prop;
  bool node_name;
  bool status;
  bool ng_name;
} _Device__isset;

class Device {
 public:

  static const char* ascii_fingerprint; // = "33584CD6150018AF03D99F89786E9675";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x58,0x4C,0xD6,0x15,0x00,0x18,0xAF,0x03,0xD9,0x9F,0x89,0x78,0x6E,0x96,0x75};

  Device() : devid(), prop(0), node_name(), status(0), ng_name() {
  }

  virtual ~Device() throw() {}

  std::string devid;
  int32_t prop;
  std::string node_name;
  int32_t status;
  std::string ng_name;

  _Device__isset __isset;

  void __set_devid(const std::string& val) {
    devid = val;
  }

  void __set_prop(const int32_t val) {
    prop = val;
  }

  void __set_node_name(const std::string& val) {
    node_name = val;
  }

  void __set_status(const int32_t val) {
    status = val;
  }

  void __set_ng_name(const std::string& val) {
    ng_name = val;
  }

  bool operator == (const Device & rhs) const
  {
    if (!(devid == rhs.devid))
      return false;
    if (!(prop == rhs.prop))
      return false;
    if (!(node_name == rhs.node_name))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(ng_name == rhs.ng_name))
      return false;
    return true;
  }
  bool operator != (const Device &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Device & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Device &a, Device &b);

typedef struct _SFileLocation__isset {
  _SFileLocation__isset() : node_name(false), fid(false), devid(false), location(false), rep_id(false), update_time(false), visit_status(false), digest(false) {}
  bool node_name;
  bool fid;
  bool devid;
  bool location;
  bool rep_id;
  bool update_time;
  bool visit_status;
  bool digest;
} _SFileLocation__isset;

class SFileLocation {
 public:

  static const char* ascii_fingerprint; // = "7505CE2A9B9174A64FCDB5382F1A83DF";
  static const uint8_t binary_fingerprint[16]; // = {0x75,0x05,0xCE,0x2A,0x9B,0x91,0x74,0xA6,0x4F,0xCD,0xB5,0x38,0x2F,0x1A,0x83,0xDF};

  SFileLocation() : node_name(), fid(0), devid(), location(), rep_id(0), update_time(0), visit_status(0), digest() {
  }

  virtual ~SFileLocation() throw() {}

  std::string node_name;
  int64_t fid;
  std::string devid;
  std::string location;
  int32_t rep_id;
  int64_t update_time;
  int32_t visit_status;
  std::string digest;

  _SFileLocation__isset __isset;

  void __set_node_name(const std::string& val) {
    node_name = val;
  }

  void __set_fid(const int64_t val) {
    fid = val;
  }

  void __set_devid(const std::string& val) {
    devid = val;
  }

  void __set_location(const std::string& val) {
    location = val;
  }

  void __set_rep_id(const int32_t val) {
    rep_id = val;
  }

  void __set_update_time(const int64_t val) {
    update_time = val;
  }

  void __set_visit_status(const int32_t val) {
    visit_status = val;
  }

  void __set_digest(const std::string& val) {
    digest = val;
  }

  bool operator == (const SFileLocation & rhs) const
  {
    if (!(node_name == rhs.node_name))
      return false;
    if (!(fid == rhs.fid))
      return false;
    if (!(devid == rhs.devid))
      return false;
    if (!(location == rhs.location))
      return false;
    if (!(rep_id == rhs.rep_id))
      return false;
    if (!(update_time == rhs.update_time))
      return false;
    if (!(visit_status == rhs.visit_status))
      return false;
    if (!(digest == rhs.digest))
      return false;
    return true;
  }
  bool operator != (const SFileLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SFileLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SFileLocation &a, SFileLocation &b);

typedef struct _SFile__isset {
  _SFile__isset() : fid(false), dbName(false), tableName(false), store_status(false), rep_nr(false), digest(false), record_nr(false), all_record_nr(false), locations(false), length(false), ref_files(false), values(false), load_status(false) {}
  bool fid;
  bool dbName;
  bool tableName;
  bool store_status;
  bool rep_nr;
  bool digest;
  bool record_nr;
  bool all_record_nr;
  bool locations;
  bool length;
  bool ref_files;
  bool values;
  bool load_status;
} _SFile__isset;

class SFile {
 public:

  static const char* ascii_fingerprint; // = "7BBF5A1200925F95C3F9B33C3E523584";
  static const uint8_t binary_fingerprint[16]; // = {0x7B,0xBF,0x5A,0x12,0x00,0x92,0x5F,0x95,0xC3,0xF9,0xB3,0x3C,0x3E,0x52,0x35,0x84};

  SFile() : fid(0), dbName(), tableName(), store_status(0), rep_nr(0), digest(), record_nr(0), all_record_nr(0), length(0), load_status(0) {
  }

  virtual ~SFile() throw() {}

  int64_t fid;
  std::string dbName;
  std::string tableName;
  int32_t store_status;
  int32_t rep_nr;
  std::string digest;
  int64_t record_nr;
  int64_t all_record_nr;
  std::vector<SFileLocation>  locations;
  int64_t length;
  std::vector<int64_t>  ref_files;
  std::vector<SplitValue>  values;
  int32_t load_status;

  _SFile__isset __isset;

  void __set_fid(const int64_t val) {
    fid = val;
  }

  void __set_dbName(const std::string& val) {
    dbName = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_store_status(const int32_t val) {
    store_status = val;
  }

  void __set_rep_nr(const int32_t val) {
    rep_nr = val;
  }

  void __set_digest(const std::string& val) {
    digest = val;
  }

  void __set_record_nr(const int64_t val) {
    record_nr = val;
  }

  void __set_all_record_nr(const int64_t val) {
    all_record_nr = val;
  }

  void __set_locations(const std::vector<SFileLocation> & val) {
    locations = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  void __set_ref_files(const std::vector<int64_t> & val) {
    ref_files = val;
  }

  void __set_values(const std::vector<SplitValue> & val) {
    values = val;
  }

  void __set_load_status(const int32_t val) {
    load_status = val;
  }

  bool operator == (const SFile & rhs) const
  {
    if (!(fid == rhs.fid))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(store_status == rhs.store_status))
      return false;
    if (!(rep_nr == rhs.rep_nr))
      return false;
    if (!(digest == rhs.digest))
      return false;
    if (!(record_nr == rhs.record_nr))
      return false;
    if (!(all_record_nr == rhs.all_record_nr))
      return false;
    if (!(locations == rhs.locations))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(ref_files == rhs.ref_files))
      return false;
    if (!(values == rhs.values))
      return false;
    if (!(load_status == rhs.load_status))
      return false;
    return true;
  }
  bool operator != (const SFile &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SFile & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SFile &a, SFile &b);

typedef struct _SFileRef__isset {
  _SFileRef__isset() : file(false), origin_fid(false) {}
  bool file;
  bool origin_fid;
} _SFileRef__isset;

class SFileRef {
 public:

  static const char* ascii_fingerprint; // = "2B316059F23EFEAE1F7AF0A680BA8319";
  static const uint8_t binary_fingerprint[16]; // = {0x2B,0x31,0x60,0x59,0xF2,0x3E,0xFE,0xAE,0x1F,0x7A,0xF0,0xA6,0x80,0xBA,0x83,0x19};

  SFileRef() : origin_fid(0) {
  }

  virtual ~SFileRef() throw() {}

  SFile file;
  int64_t origin_fid;

  _SFileRef__isset __isset;

  void __set_file(const SFile& val) {
    file = val;
  }

  void __set_origin_fid(const int64_t val) {
    origin_fid = val;
  }

  bool operator == (const SFileRef & rhs) const
  {
    if (!(file == rhs.file))
      return false;
    if (!(origin_fid == rhs.origin_fid))
      return false;
    return true;
  }
  bool operator != (const SFileRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SFileRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SFileRef &a, SFileRef &b);

typedef struct _Busitype__isset {
  _Busitype__isset() : name(false), comment(false) {}
  bool name;
  bool comment;
} _Busitype__isset;

class Busitype {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  Busitype() : name(), comment() {
  }

  virtual ~Busitype() throw() {}

  std::string name;
  std::string comment;

  _Busitype__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
  }

  bool operator == (const Busitype & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(comment == rhs.comment))
      return false;
    return true;
  }
  bool operator != (const Busitype &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Busitype & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Busitype &a, Busitype &b);

typedef struct _Index__isset {
  _Index__isset() : indexName(false), indexHandlerClass(false), dbName(false), origTableName(false), createTime(false), lastAccessTime(false), indexTableName(false), sd(false), parameters(false), deferredRebuild(false) {}
  bool indexName;
  bool indexHandlerClass;
  bool dbName;
  bool origTableName;
  bool createTime;
  bool lastAccessTime;
  bool indexTableName;
  bool sd;
  bool parameters;
  bool deferredRebuild;
} _Index__isset;

class Index {
 public:

  static const char* ascii_fingerprint; // = "CD5B5B520F9837C000345B35A2169F22";
  static const uint8_t binary_fingerprint[16]; // = {0xCD,0x5B,0x5B,0x52,0x0F,0x98,0x37,0xC0,0x00,0x34,0x5B,0x35,0xA2,0x16,0x9F,0x22};

  Index() : indexName(), indexHandlerClass(), dbName(), origTableName(), createTime(0), lastAccessTime(0), indexTableName(), deferredRebuild(0) {
  }

  virtual ~Index() throw() {}

  std::string indexName;
  std::string indexHandlerClass;
  std::string dbName;
  std::string origTableName;
  int32_t createTime;
  int32_t lastAccessTime;
  std::string indexTableName;
  StorageDescriptor sd;
  std::map<std::string, std::string>  parameters;
  bool deferredRebuild;

  _Index__isset __isset;

  void __set_indexName(const std::string& val) {
    indexName = val;
  }

  void __set_indexHandlerClass(const std::string& val) {
    indexHandlerClass = val;
  }

  void __set_dbName(const std::string& val) {
    dbName = val;
  }

  void __set_origTableName(const std::string& val) {
    origTableName = val;
  }

  void __set_createTime(const int32_t val) {
    createTime = val;
  }

  void __set_lastAccessTime(const int32_t val) {
    lastAccessTime = val;
  }

  void __set_indexTableName(const std::string& val) {
    indexTableName = val;
  }

  void __set_sd(const StorageDescriptor& val) {
    sd = val;
  }

  void __set_parameters(const std::map<std::string, std::string> & val) {
    parameters = val;
  }

  void __set_deferredRebuild(const bool val) {
    deferredRebuild = val;
  }

  bool operator == (const Index & rhs) const
  {
    if (!(indexName == rhs.indexName))
      return false;
    if (!(indexHandlerClass == rhs.indexHandlerClass))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(origTableName == rhs.origTableName))
      return false;
    if (!(createTime == rhs.createTime))
      return false;
    if (!(lastAccessTime == rhs.lastAccessTime))
      return false;
    if (!(indexTableName == rhs.indexTableName))
      return false;
    if (!(sd == rhs.sd))
      return false;
    if (!(parameters == rhs.parameters))
      return false;
    if (!(deferredRebuild == rhs.deferredRebuild))
      return false;
    return true;
  }
  bool operator != (const Index &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Index & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Index &a, Index &b);


class BooleanColumnStatsData {
 public:

  static const char* ascii_fingerprint; // = "EA2D65F1E0BB78760205682082304B41";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0x2D,0x65,0xF1,0xE0,0xBB,0x78,0x76,0x02,0x05,0x68,0x20,0x82,0x30,0x4B,0x41};

  BooleanColumnStatsData() : numTrues(0), numFalses(0), numNulls(0) {
  }

  virtual ~BooleanColumnStatsData() throw() {}

  int64_t numTrues;
  int64_t numFalses;
  int64_t numNulls;

  void __set_numTrues(const int64_t val) {
    numTrues = val;
  }

  void __set_numFalses(const int64_t val) {
    numFalses = val;
  }

  void __set_numNulls(const int64_t val) {
    numNulls = val;
  }

  bool operator == (const BooleanColumnStatsData & rhs) const
  {
    if (!(numTrues == rhs.numTrues))
      return false;
    if (!(numFalses == rhs.numFalses))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    return true;
  }
  bool operator != (const BooleanColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BooleanColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BooleanColumnStatsData &a, BooleanColumnStatsData &b);


class DoubleColumnStatsData {
 public:

  static const char* ascii_fingerprint; // = "97F958CB0709C3B109A57EEE01946C13";
  static const uint8_t binary_fingerprint[16]; // = {0x97,0xF9,0x58,0xCB,0x07,0x09,0xC3,0xB1,0x09,0xA5,0x7E,0xEE,0x01,0x94,0x6C,0x13};

  DoubleColumnStatsData() : lowValue(0), highValue(0), numNulls(0), numDVs(0) {
  }

  virtual ~DoubleColumnStatsData() throw() {}

  double lowValue;
  double highValue;
  int64_t numNulls;
  int64_t numDVs;

  void __set_lowValue(const double val) {
    lowValue = val;
  }

  void __set_highValue(const double val) {
    highValue = val;
  }

  void __set_numNulls(const int64_t val) {
    numNulls = val;
  }

  void __set_numDVs(const int64_t val) {
    numDVs = val;
  }

  bool operator == (const DoubleColumnStatsData & rhs) const
  {
    if (!(lowValue == rhs.lowValue))
      return false;
    if (!(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    return true;
  }
  bool operator != (const DoubleColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DoubleColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DoubleColumnStatsData &a, DoubleColumnStatsData &b);


class LongColumnStatsData {
 public:

  static const char* ascii_fingerprint; // = "66C8E6F97F0275919D86FEB536251B17";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xC8,0xE6,0xF9,0x7F,0x02,0x75,0x91,0x9D,0x86,0xFE,0xB5,0x36,0x25,0x1B,0x17};

  LongColumnStatsData() : lowValue(0), highValue(0), numNulls(0), numDVs(0) {
  }

  virtual ~LongColumnStatsData() throw() {}

  int64_t lowValue;
  int64_t highValue;
  int64_t numNulls;
  int64_t numDVs;

  void __set_lowValue(const int64_t val) {
    lowValue = val;
  }

  void __set_highValue(const int64_t val) {
    highValue = val;
  }

  void __set_numNulls(const int64_t val) {
    numNulls = val;
  }

  void __set_numDVs(const int64_t val) {
    numDVs = val;
  }

  bool operator == (const LongColumnStatsData & rhs) const
  {
    if (!(lowValue == rhs.lowValue))
      return false;
    if (!(highValue == rhs.highValue))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    return true;
  }
  bool operator != (const LongColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LongColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LongColumnStatsData &a, LongColumnStatsData &b);


class StringColumnStatsData {
 public:

  static const char* ascii_fingerprint; // = "D017B08C3DF12C3AB98788B2E67DAAB3";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0x17,0xB0,0x8C,0x3D,0xF1,0x2C,0x3A,0xB9,0x87,0x88,0xB2,0xE6,0x7D,0xAA,0xB3};

  StringColumnStatsData() : maxColLen(0), avgColLen(0), numNulls(0), numDVs(0) {
  }

  virtual ~StringColumnStatsData() throw() {}

  int64_t maxColLen;
  double avgColLen;
  int64_t numNulls;
  int64_t numDVs;

  void __set_maxColLen(const int64_t val) {
    maxColLen = val;
  }

  void __set_avgColLen(const double val) {
    avgColLen = val;
  }

  void __set_numNulls(const int64_t val) {
    numNulls = val;
  }

  void __set_numDVs(const int64_t val) {
    numDVs = val;
  }

  bool operator == (const StringColumnStatsData & rhs) const
  {
    if (!(maxColLen == rhs.maxColLen))
      return false;
    if (!(avgColLen == rhs.avgColLen))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    if (!(numDVs == rhs.numDVs))
      return false;
    return true;
  }
  bool operator != (const StringColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StringColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StringColumnStatsData &a, StringColumnStatsData &b);


class BinaryColumnStatsData {
 public:

  static const char* ascii_fingerprint; // = "22B0CB67183FCDB945892B9974518D06";
  static const uint8_t binary_fingerprint[16]; // = {0x22,0xB0,0xCB,0x67,0x18,0x3F,0xCD,0xB9,0x45,0x89,0x2B,0x99,0x74,0x51,0x8D,0x06};

  BinaryColumnStatsData() : maxColLen(0), avgColLen(0), numNulls(0) {
  }

  virtual ~BinaryColumnStatsData() throw() {}

  int64_t maxColLen;
  double avgColLen;
  int64_t numNulls;

  void __set_maxColLen(const int64_t val) {
    maxColLen = val;
  }

  void __set_avgColLen(const double val) {
    avgColLen = val;
  }

  void __set_numNulls(const int64_t val) {
    numNulls = val;
  }

  bool operator == (const BinaryColumnStatsData & rhs) const
  {
    if (!(maxColLen == rhs.maxColLen))
      return false;
    if (!(avgColLen == rhs.avgColLen))
      return false;
    if (!(numNulls == rhs.numNulls))
      return false;
    return true;
  }
  bool operator != (const BinaryColumnStatsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BinaryColumnStatsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BinaryColumnStatsData &a, BinaryColumnStatsData &b);

typedef struct _ColumnStatisticsData__isset {
  _ColumnStatisticsData__isset() : booleanStats(false), longStats(false), doubleStats(false), stringStats(false), binaryStats(false) {}
  bool booleanStats;
  bool longStats;
  bool doubleStats;
  bool stringStats;
  bool binaryStats;
} _ColumnStatisticsData__isset;

class ColumnStatisticsData {
 public:

  static const char* ascii_fingerprint; // = "3D106F26C0761EF37E58CAFAA3F1651C";
  static const uint8_t binary_fingerprint[16]; // = {0x3D,0x10,0x6F,0x26,0xC0,0x76,0x1E,0xF3,0x7E,0x58,0xCA,0xFA,0xA3,0xF1,0x65,0x1C};

  ColumnStatisticsData() {
  }

  virtual ~ColumnStatisticsData() throw() {}

  BooleanColumnStatsData booleanStats;
  LongColumnStatsData longStats;
  DoubleColumnStatsData doubleStats;
  StringColumnStatsData stringStats;
  BinaryColumnStatsData binaryStats;

  _ColumnStatisticsData__isset __isset;

  void __set_booleanStats(const BooleanColumnStatsData& val) {
    booleanStats = val;
  }

  void __set_longStats(const LongColumnStatsData& val) {
    longStats = val;
  }

  void __set_doubleStats(const DoubleColumnStatsData& val) {
    doubleStats = val;
  }

  void __set_stringStats(const StringColumnStatsData& val) {
    stringStats = val;
  }

  void __set_binaryStats(const BinaryColumnStatsData& val) {
    binaryStats = val;
  }

  bool operator == (const ColumnStatisticsData & rhs) const
  {
    if (!(booleanStats == rhs.booleanStats))
      return false;
    if (!(longStats == rhs.longStats))
      return false;
    if (!(doubleStats == rhs.doubleStats))
      return false;
    if (!(stringStats == rhs.stringStats))
      return false;
    if (!(binaryStats == rhs.binaryStats))
      return false;
    return true;
  }
  bool operator != (const ColumnStatisticsData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatisticsData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnStatisticsData &a, ColumnStatisticsData &b);


class ColumnStatisticsObj {
 public:

  static const char* ascii_fingerprint; // = "DEE09584C51BCAF60824FE4509B59567";
  static const uint8_t binary_fingerprint[16]; // = {0xDE,0xE0,0x95,0x84,0xC5,0x1B,0xCA,0xF6,0x08,0x24,0xFE,0x45,0x09,0xB5,0x95,0x67};

  ColumnStatisticsObj() : colName(), colType() {
  }

  virtual ~ColumnStatisticsObj() throw() {}

  std::string colName;
  std::string colType;
  ColumnStatisticsData statsData;

  void __set_colName(const std::string& val) {
    colName = val;
  }

  void __set_colType(const std::string& val) {
    colType = val;
  }

  void __set_statsData(const ColumnStatisticsData& val) {
    statsData = val;
  }

  bool operator == (const ColumnStatisticsObj & rhs) const
  {
    if (!(colName == rhs.colName))
      return false;
    if (!(colType == rhs.colType))
      return false;
    if (!(statsData == rhs.statsData))
      return false;
    return true;
  }
  bool operator != (const ColumnStatisticsObj &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatisticsObj & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnStatisticsObj &a, ColumnStatisticsObj &b);

typedef struct _ColumnStatisticsDesc__isset {
  _ColumnStatisticsDesc__isset() : partName(false), lastAnalyzed(false) {}
  bool partName;
  bool lastAnalyzed;
} _ColumnStatisticsDesc__isset;

class ColumnStatisticsDesc {
 public:

  static const char* ascii_fingerprint; // = "261759FF6F8FAB53F941453007FE18CB";
  static const uint8_t binary_fingerprint[16]; // = {0x26,0x17,0x59,0xFF,0x6F,0x8F,0xAB,0x53,0xF9,0x41,0x45,0x30,0x07,0xFE,0x18,0xCB};

  ColumnStatisticsDesc() : isTblLevel(0), dbName(), tableName(), partName(), lastAnalyzed(0) {
  }

  virtual ~ColumnStatisticsDesc() throw() {}

  bool isTblLevel;
  std::string dbName;
  std::string tableName;
  std::string partName;
  int64_t lastAnalyzed;

  _ColumnStatisticsDesc__isset __isset;

  void __set_isTblLevel(const bool val) {
    isTblLevel = val;
  }

  void __set_dbName(const std::string& val) {
    dbName = val;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_partName(const std::string& val) {
    partName = val;
    __isset.partName = true;
  }

  void __set_lastAnalyzed(const int64_t val) {
    lastAnalyzed = val;
    __isset.lastAnalyzed = true;
  }

  bool operator == (const ColumnStatisticsDesc & rhs) const
  {
    if (!(isTblLevel == rhs.isTblLevel))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (__isset.partName != rhs.__isset.partName)
      return false;
    else if (__isset.partName && !(partName == rhs.partName))
      return false;
    if (__isset.lastAnalyzed != rhs.__isset.lastAnalyzed)
      return false;
    else if (__isset.lastAnalyzed && !(lastAnalyzed == rhs.lastAnalyzed))
      return false;
    return true;
  }
  bool operator != (const ColumnStatisticsDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatisticsDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnStatisticsDesc &a, ColumnStatisticsDesc &b);


class ColumnStatistics {
 public:

  static const char* ascii_fingerprint; // = "681BDBD0CBB53373AC1C9C0C2E26BEAB";
  static const uint8_t binary_fingerprint[16]; // = {0x68,0x1B,0xDB,0xD0,0xCB,0xB5,0x33,0x73,0xAC,0x1C,0x9C,0x0C,0x2E,0x26,0xBE,0xAB};

  ColumnStatistics() {
  }

  virtual ~ColumnStatistics() throw() {}

  ColumnStatisticsDesc statsDesc;
  std::vector<ColumnStatisticsObj>  statsObj;

  void __set_statsDesc(const ColumnStatisticsDesc& val) {
    statsDesc = val;
  }

  void __set_statsObj(const std::vector<ColumnStatisticsObj> & val) {
    statsObj = val;
  }

  bool operator == (const ColumnStatistics & rhs) const
  {
    if (!(statsDesc == rhs.statsDesc))
      return false;
    if (!(statsObj == rhs.statsObj))
      return false;
    return true;
  }
  bool operator != (const ColumnStatistics &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnStatistics & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnStatistics &a, ColumnStatistics &b);

typedef struct _Schema__isset {
  _Schema__isset() : fieldSchemas(false), properties(false) {}
  bool fieldSchemas;
  bool properties;
} _Schema__isset;

class Schema {
 public:

  static const char* ascii_fingerprint; // = "9EA43B0EE173E84788396641C1993971";
  static const uint8_t binary_fingerprint[16]; // = {0x9E,0xA4,0x3B,0x0E,0xE1,0x73,0xE8,0x47,0x88,0x39,0x66,0x41,0xC1,0x99,0x39,0x71};

  Schema() {
  }

  virtual ~Schema() throw() {}

  std::vector<FieldSchema>  fieldSchemas;
  std::map<std::string, std::string>  properties;

  _Schema__isset __isset;

  void __set_fieldSchemas(const std::vector<FieldSchema> & val) {
    fieldSchemas = val;
  }

  void __set_properties(const std::map<std::string, std::string> & val) {
    properties = val;
  }

  bool operator == (const Schema & rhs) const
  {
    if (!(fieldSchemas == rhs.fieldSchemas))
      return false;
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const Schema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Schema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Schema &a, Schema &b);

typedef struct _EnvironmentContext__isset {
  _EnvironmentContext__isset() : properties(false) {}
  bool properties;
} _EnvironmentContext__isset;

class EnvironmentContext {
 public:

  static const char* ascii_fingerprint; // = "5EA2D527ECA3BA20C77AFC023EE8C05F";
  static const uint8_t binary_fingerprint[16]; // = {0x5E,0xA2,0xD5,0x27,0xEC,0xA3,0xBA,0x20,0xC7,0x7A,0xFC,0x02,0x3E,0xE8,0xC0,0x5F};

  EnvironmentContext() {
  }

  virtual ~EnvironmentContext() throw() {}

  std::map<std::string, std::string>  properties;

  _EnvironmentContext__isset __isset;

  void __set_properties(const std::map<std::string, std::string> & val) {
    properties = val;
  }

  bool operator == (const EnvironmentContext & rhs) const
  {
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const EnvironmentContext &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EnvironmentContext & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(EnvironmentContext &a, EnvironmentContext &b);


class GeoLocation {
 public:

  static const char* ascii_fingerprint; // = "BFF0E21728CB005F9AA5774A41542B8D";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0xF0,0xE2,0x17,0x28,0xCB,0x00,0x5F,0x9A,0xA5,0x77,0x4A,0x41,0x54,0x2B,0x8D};

  GeoLocation() : geoLocName(), nation(), province(), city(), dist() {
  }

  virtual ~GeoLocation() throw() {}

  std::string geoLocName;
  std::string nation;
  std::string province;
  std::string city;
  std::string dist;

  void __set_geoLocName(const std::string& val) {
    geoLocName = val;
  }

  void __set_nation(const std::string& val) {
    nation = val;
  }

  void __set_province(const std::string& val) {
    province = val;
  }

  void __set_city(const std::string& val) {
    city = val;
  }

  void __set_dist(const std::string& val) {
    dist = val;
  }

  bool operator == (const GeoLocation & rhs) const
  {
    if (!(geoLocName == rhs.geoLocName))
      return false;
    if (!(nation == rhs.nation))
      return false;
    if (!(province == rhs.province))
      return false;
    if (!(city == rhs.city))
      return false;
    if (!(dist == rhs.dist))
      return false;
    return true;
  }
  bool operator != (const GeoLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GeoLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GeoLocation &a, GeoLocation &b);

typedef struct _EquipRoom__isset {
  _EquipRoom__isset() : comment(false), geolocation(false) {}
  bool comment;
  bool geolocation;
} _EquipRoom__isset;

class EquipRoom {
 public:

  static const char* ascii_fingerprint; // = "A51DC72287DA72911ECE4E8E6AFB90DA";
  static const uint8_t binary_fingerprint[16]; // = {0xA5,0x1D,0xC7,0x22,0x87,0xDA,0x72,0x91,0x1E,0xCE,0x4E,0x8E,0x6A,0xFB,0x90,0xDA};

  EquipRoom() : eqRoomName(), status(0), comment() {
  }

  virtual ~EquipRoom() throw() {}

  std::string eqRoomName;
  int32_t status;
  std::string comment;
  GeoLocation geolocation;

  _EquipRoom__isset __isset;

  void __set_eqRoomName(const std::string& val) {
    eqRoomName = val;
  }

  void __set_status(const int32_t val) {
    status = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_geolocation(const GeoLocation& val) {
    geolocation = val;
    __isset.geolocation = true;
  }

  bool operator == (const EquipRoom & rhs) const
  {
    if (!(eqRoomName == rhs.eqRoomName))
      return false;
    if (!(status == rhs.status))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.geolocation != rhs.__isset.geolocation)
      return false;
    else if (__isset.geolocation && !(geolocation == rhs.geolocation))
      return false;
    return true;
  }
  bool operator != (const EquipRoom &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EquipRoom & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(EquipRoom &a, EquipRoom &b);

typedef struct _MetaException__isset {
  _MetaException__isset() : message(false) {}
  bool message;
} _MetaException__isset;

class MetaException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  MetaException() : message() {
  }

  virtual ~MetaException() throw() {}

  std::string message;

  _MetaException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const MetaException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const MetaException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MetaException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MetaException &a, MetaException &b);

typedef struct _UnknownTableException__isset {
  _UnknownTableException__isset() : message(false) {}
  bool message;
} _UnknownTableException__isset;

class UnknownTableException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  UnknownTableException() : message() {
  }

  virtual ~UnknownTableException() throw() {}

  std::string message;

  _UnknownTableException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const UnknownTableException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnknownTableException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownTableException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UnknownTableException &a, UnknownTableException &b);

typedef struct _UnknownDBException__isset {
  _UnknownDBException__isset() : message(false) {}
  bool message;
} _UnknownDBException__isset;

class UnknownDBException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  UnknownDBException() : message() {
  }

  virtual ~UnknownDBException() throw() {}

  std::string message;

  _UnknownDBException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const UnknownDBException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnknownDBException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownDBException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UnknownDBException &a, UnknownDBException &b);

typedef struct _AlreadyExistsException__isset {
  _AlreadyExistsException__isset() : message(false) {}
  bool message;
} _AlreadyExistsException__isset;

class AlreadyExistsException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  AlreadyExistsException() : message() {
  }

  virtual ~AlreadyExistsException() throw() {}

  std::string message;

  _AlreadyExistsException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const AlreadyExistsException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const AlreadyExistsException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AlreadyExistsException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AlreadyExistsException &a, AlreadyExistsException &b);

typedef struct _InvalidPartitionException__isset {
  _InvalidPartitionException__isset() : message(false) {}
  bool message;
} _InvalidPartitionException__isset;

class InvalidPartitionException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  InvalidPartitionException() : message() {
  }

  virtual ~InvalidPartitionException() throw() {}

  std::string message;

  _InvalidPartitionException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const InvalidPartitionException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidPartitionException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidPartitionException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InvalidPartitionException &a, InvalidPartitionException &b);

typedef struct _UnknownPartitionException__isset {
  _UnknownPartitionException__isset() : message(false) {}
  bool message;
} _UnknownPartitionException__isset;

class UnknownPartitionException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  UnknownPartitionException() : message() {
  }

  virtual ~UnknownPartitionException() throw() {}

  std::string message;

  _UnknownPartitionException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const UnknownPartitionException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const UnknownPartitionException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnknownPartitionException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UnknownPartitionException &a, UnknownPartitionException &b);

typedef struct _InvalidObjectException__isset {
  _InvalidObjectException__isset() : message(false) {}
  bool message;
} _InvalidObjectException__isset;

class InvalidObjectException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  InvalidObjectException() : message() {
  }

  virtual ~InvalidObjectException() throw() {}

  std::string message;

  _InvalidObjectException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const InvalidObjectException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidObjectException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidObjectException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InvalidObjectException &a, InvalidObjectException &b);

typedef struct _NoSuchObjectException__isset {
  _NoSuchObjectException__isset() : message(false) {}
  bool message;
} _NoSuchObjectException__isset;

class NoSuchObjectException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  NoSuchObjectException() : message() {
  }

  virtual ~NoSuchObjectException() throw() {}

  std::string message;

  _NoSuchObjectException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const NoSuchObjectException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NoSuchObjectException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoSuchObjectException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NoSuchObjectException &a, NoSuchObjectException &b);

typedef struct _IndexAlreadyExistsException__isset {
  _IndexAlreadyExistsException__isset() : message(false) {}
  bool message;
} _IndexAlreadyExistsException__isset;

class IndexAlreadyExistsException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  IndexAlreadyExistsException() : message() {
  }

  virtual ~IndexAlreadyExistsException() throw() {}

  std::string message;

  _IndexAlreadyExistsException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const IndexAlreadyExistsException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const IndexAlreadyExistsException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IndexAlreadyExistsException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(IndexAlreadyExistsException &a, IndexAlreadyExistsException &b);

typedef struct _InvalidOperationException__isset {
  _InvalidOperationException__isset() : message(false) {}
  bool message;
} _InvalidOperationException__isset;

class InvalidOperationException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  InvalidOperationException() : message() {
  }

  virtual ~InvalidOperationException() throw() {}

  std::string message;

  _InvalidOperationException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const InvalidOperationException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidOperationException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidOperationException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InvalidOperationException &a, InvalidOperationException &b);

typedef struct _ConfigValSecurityException__isset {
  _ConfigValSecurityException__isset() : message(false) {}
  bool message;
} _ConfigValSecurityException__isset;

class ConfigValSecurityException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  ConfigValSecurityException() : message() {
  }

  virtual ~ConfigValSecurityException() throw() {}

  std::string message;

  _ConfigValSecurityException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const ConfigValSecurityException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const ConfigValSecurityException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ConfigValSecurityException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ConfigValSecurityException &a, ConfigValSecurityException &b);

typedef struct _InvalidInputException__isset {
  _InvalidInputException__isset() : message(false) {}
  bool message;
} _InvalidInputException__isset;

class InvalidInputException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  InvalidInputException() : message() {
  }

  virtual ~InvalidInputException() throw() {}

  std::string message;

  _InvalidInputException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const InvalidInputException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const InvalidInputException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidInputException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InvalidInputException &a, InvalidInputException &b);

typedef struct _FileOperationException__isset {
  _FileOperationException__isset() : message(false), reason(false) {}
  bool message;
  bool reason;
} _FileOperationException__isset;

class FileOperationException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "D6FD826D949221396F4FFC3ECCD3D192";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

  FileOperationException() : message(), reason((FOFailReason::type)0) {
  }

  virtual ~FileOperationException() throw() {}

  std::string message;
  FOFailReason::type reason;

  _FileOperationException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  void __set_reason(const FOFailReason::type val) {
    reason = val;
  }

  bool operator == (const FileOperationException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    if (!(reason == rhs.reason))
      return false;
    return true;
  }
  bool operator != (const FileOperationException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FileOperationException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FileOperationException &a, FileOperationException &b);

}}} // namespace

#endif
