#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import fb303.FacebookService
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(fb303.FacebookService.Iface):
  """
  This interface is live.
  """
  def create_attribution(self, db):
    """
    Parameters:
     - db
    """
    pass

  def get_attribution(self, name):
    """
    Parameters:
     - name
    """
    pass

  def drop_attribution(self, name, deleteData, cascade):
    """
    Parameters:
     - name
     - deleteData
     - cascade
    """
    pass

  def update_attribution(self, db):
    """
    Parameters:
     - db
    """
    pass

  def get_all_attributions(self, ):
    pass

  def get_local_attribution(self, ):
    pass

  def get_lucene_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass

  def get_all_busi_type_cols(self, ):
    pass

  def get_all_busi_type_datacenters(self, ):
    pass

  def append_busi_type_datacenter(self, busiTypeDatacenter):
    """
    Parameters:
     - busiTypeDatacenter
    """
    pass

  def add_datawarehouse_sql(self, dwNum, sql):
    """
    Parameters:
     - dwNum
     - sql
    """
    pass

  def showBusitypes(self, ):
    pass

  def createBusitype(self, busitype):
    """
    Parameters:
     - busitype
    """
    pass

  def add_partition_files(self, part, files):
    """
    Parameters:
     - part
     - files
    """
    pass

  def drop_partition_files(self, part, files):
    """
    Parameters:
     - part
     - files
    """
    pass

  def add_subpartition_files(self, subpart, files):
    """
    Parameters:
     - subpart
     - files
    """
    pass

  def drop_subpartition_files(self, subpart, files):
    """
    Parameters:
     - subpart
     - files
    """
    pass

  def add_partition_index(self, index, part):
    """
    Parameters:
     - index
     - part
    """
    pass

  def drop_partition_index(self, index, part):
    """
    Parameters:
     - index
     - part
    """
    pass

  def add_subpartition_index(self, index, part):
    """
    Parameters:
     - index
     - part
    """
    pass

  def drop_subpartition_index(self, index, part):
    """
    Parameters:
     - index
     - part
    """
    pass

  def add_subpartition(self, dbname, tbl_name, part_vals, sub_part):
    """
    Parameters:
     - dbname
     - tbl_name
     - part_vals
     - sub_part
    """
    pass

  def get_subpartitions(self, dbname, tbl_name, part):
    """
    Parameters:
     - dbname
     - tbl_name
     - part
    """
    pass

  def add_partition_index_files(self, index, part, file, originfid):
    """
    Parameters:
     - index
     - part
     - file
     - originfid
    """
    pass

  def get_partition_index_files(self, index, part):
    """
    Parameters:
     - index
     - part
    """
    pass

  def drop_partition_index_files(self, index, part, file):
    """
    Parameters:
     - index
     - part
     - file
    """
    pass

  def add_subpartition_index_files(self, index, subpart, file, originfid):
    """
    Parameters:
     - index
     - subpart
     - file
     - originfid
    """
    pass

  def get_subpartition_index_files(self, index, subpart):
    """
    Parameters:
     - index
     - subpart
    """
    pass

  def drop_subpartition_index_files(self, index, subpart, file):
    """
    Parameters:
     - index
     - subpart
     - file
    """
    pass

  def addGeoLocation(self, gl):
    """
    Parameters:
     - gl
    """
    pass

  def modifyGeoLocation(self, gl):
    """
    Parameters:
     - gl
    """
    pass

  def deleteGeoLocation(self, gl):
    """
    Parameters:
     - gl
    """
    pass

  def listGeoLocation(self, ):
    pass

  def addEquipRoom(self, er):
    """
    Parameters:
     - er
    """
    pass

  def modifyEquipRoom(self, er):
    """
    Parameters:
     - er
    """
    pass

  def deleteEquipRoom(self, er):
    """
    Parameters:
     - er
    """
    pass

  def listEquipRoom(self, ):
    pass

  def getGeoLocationByName(self, geoLocName):
    """
    Parameters:
     - geoLocName
    """
    pass

  def getGeoLocationByNames(self, geoLocNames):
    """
    Parameters:
     - geoLocNames
    """
    pass

  def addNodeAssignment(self, nodeName, dbName):
    """
    Parameters:
     - nodeName
     - dbName
    """
    pass

  def deleteNodeAssignment(self, nodeName, dbName):
    """
    Parameters:
     - nodeName
     - dbName
    """
    pass

  def listNodes(self, ):
    pass

  def addUserAssignment(self, roleName, dbName):
    """
    Parameters:
     - roleName
     - dbName
    """
    pass

  def deleteUserAssignment(self, roleName, dbName):
    """
    Parameters:
     - roleName
     - dbName
    """
    pass

  def listUsers(self, ):
    pass

  def addRoleAssignment(self, userName, dbName):
    """
    Parameters:
     - userName
     - dbName
    """
    pass

  def deleteRoleAssignment(self, userName, dbName):
    """
    Parameters:
     - userName
     - dbName
    """
    pass

  def listRoles(self, ):
    pass

  def addNodeGroupAssignment(self, ng, dbName):
    """
    Parameters:
     - ng
     - dbName
    """
    pass

  def deleteNodeGroupAssignment(self, ng, dbName):
    """
    Parameters:
     - ng
     - dbName
    """
    pass

  def pingPong(self, str):
    """
    Parameters:
     - str
    """
    pass

  def alterNodeGroup(self, ng):
    """
    Parameters:
     - ng
    """
    pass

  def create_database(self, database):
    """
    Parameters:
     - database
    """
    pass

  def get_database(self, name):
    """
    Parameters:
     - name
    """
    pass

  def drop_database(self, name, deleteData, cascade):
    """
    Parameters:
     - name
     - deleteData
     - cascade
    """
    pass

  def get_databases(self, pattern):
    """
    Parameters:
     - pattern
    """
    pass

  def get_all_databases(self, ):
    pass

  def alter_database(self, dbname, db):
    """
    Parameters:
     - dbname
     - db
    """
    pass

  def get_type(self, name):
    """
    Parameters:
     - name
    """
    pass

  def create_type(self, type):
    """
    Parameters:
     - type
    """
    pass

  def drop_type(self, type):
    """
    Parameters:
     - type
    """
    pass

  def get_type_all(self, name):
    """
    Parameters:
     - name
    """
    pass

  def get_fields(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    pass

  def get_schema(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    pass

  def create_table(self, tbl):
    """
    Parameters:
     - tbl
    """
    pass

  def create_table_by_user(self, tbl, user):
    """
    Parameters:
     - tbl
     - user
    """
    pass

  def create_table_with_environment_context(self, tbl, environment_context):
    """
    Parameters:
     - tbl
     - environment_context
    """
    pass

  def drop_table(self, dbname, name, deleteData):
    """
    Parameters:
     - dbname
     - name
     - deleteData
    """
    pass

  def get_tables(self, db_name, pattern):
    """
    Parameters:
     - db_name
     - pattern
    """
    pass

  def get_all_tables(self, db_name):
    """
    Parameters:
     - db_name
    """
    pass

  def get_table(self, dbname, tbl_name):
    """
    Parameters:
     - dbname
     - tbl_name
    """
    pass

  def get_table_objects_by_name(self, dbname, tbl_names):
    """
    Parameters:
     - dbname
     - tbl_names
    """
    pass

  def get_table_names_by_filter(self, dbname, filter, max_tables):
    """
    Parameters:
     - dbname
     - filter
     - max_tables
    """
    pass

  def alter_table(self, dbname, tbl_name, new_tbl):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
    """
    pass

  def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
     - environment_context
    """
    pass

  def add_partition(self, new_part):
    """
    Parameters:
     - new_part
    """
    pass

  def add_partition_with_environment_context(self, new_part, environment_context):
    """
    Parameters:
     - new_part
     - environment_context
    """
    pass

  def add_partitions(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    pass

  def append_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    pass

  def append_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    pass

  def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """
    pass

  def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """
    pass

  def get_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    pass

  def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names
    """
    pass

  def get_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    pass

  def get_partitions(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names
    """
    pass

  def get_partition_names(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    pass

  def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    pass

  def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names
    """
    pass

  def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    pass

  def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    pass

  def get_partitions_by_names(self, db_name, tbl_name, names):
    """
    Parameters:
     - db_name
     - tbl_name
     - names
    """
    pass

  def alter_partition(self, db_name, tbl_name, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
    """
    pass

  def alter_partitions(self, db_name, tbl_name, new_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_parts
    """
    pass

  def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
     - environment_context
    """
    pass

  def rename_partition(self, db_name, tbl_name, part_vals, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - new_part
    """
    pass

  def get_config_value(self, name, defaultValue):
    """
    Parameters:
     - name
     - defaultValue
    """
    pass

  def partition_name_to_vals(self, part_name):
    """
    Parameters:
     - part_name
    """
    pass

  def partition_name_to_spec(self, part_name):
    """
    Parameters:
     - part_name
    """
    pass

  def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    pass

  def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    pass

  def add_index(self, new_index, index_table):
    """
    Parameters:
     - new_index
     - index_table
    """
    pass

  def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    """
    Parameters:
     - dbname
     - base_tbl_name
     - idx_name
     - new_idx
    """
    pass

  def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """
    pass

  def get_index_by_name(self, db_name, tbl_name, index_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
    """
    pass

  def get_indexes(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass

  def get_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    pass

  def update_table_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    pass

  def update_partition_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    pass

  def get_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    pass

  def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    pass

  def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    pass

  def delete_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    pass

  def create_user(self, user):
    """
    Parameters:
     - user
    """
    pass

  def drop_user(self, user_name):
    """
    Parameters:
     - user_name
    """
    pass

  def modify_user(self, user):
    """
    Parameters:
     - user
    """
    pass

  def list_users_names(self, ):
    pass

  def list_users(self, db):
    """
    Parameters:
     - db
    """
    pass

  def authentication(self, user_name, passwd):
    """
    Parameters:
     - user_name
     - passwd
    """
    pass

  def user_authority_check(self, user, tbl, ops):
    """
    Parameters:
     - user
     - tbl
     - ops
    """
    pass

  def create_role(self, role):
    """
    Parameters:
     - role
    """
    pass

  def drop_role(self, role_name):
    """
    Parameters:
     - role_name
    """
    pass

  def get_role_names(self, ):
    pass

  def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option
    """
    pass

  def revoke_role(self, role_name, principal_name, principal_type):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
    """
    pass

  def list_roles(self, principal_name, principal_type):
    """
    Parameters:
     - principal_name
     - principal_type
    """
    pass

  def get_privilege_set(self, hiveObject, user_name, group_names):
    """
    Parameters:
     - hiveObject
     - user_name
     - group_names
    """
    pass

  def list_privileges(self, principal_name, principal_type, hiveObject):
    """
    Parameters:
     - principal_name
     - principal_type
     - hiveObject
    """
    pass

  def grant_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    pass

  def revoke_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    pass

  def set_ugi(self, user_name, group_names):
    """
    Parameters:
     - user_name
     - group_names
    """
    pass

  def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    """
    Parameters:
     - token_owner
     - renewer_kerberos_principal_name
    """
    pass

  def renew_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    pass

  def cancel_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    pass

  def create_file(self, node_name, repnr, db_name, table_name, values):
    """
    Parameters:
     - node_name
     - repnr
     - db_name
     - table_name
     - values
    """
    pass

  def create_file_by_policy(self, policy, repnr, db_name, table_name, values):
    """
    Parameters:
     - policy
     - repnr
     - db_name
     - table_name
     - values
    """
    pass

  def set_file_repnr(self, fid, repnr):
    """
    Parameters:
     - fid
     - repnr
    """
    pass

  def reopen_file(self, fid):
    """
    Parameters:
     - fid
    """
    pass

  def close_file(self, file):
    """
    Parameters:
     - file
    """
    pass

  def online_filelocation(self, file):
    """
    Parameters:
     - file
    """
    pass

  def offline_filelocation(self, sfl):
    """
    Parameters:
     - sfl
    """
    pass

  def set_loadstatus_bad(self, fid):
    """
    Parameters:
     - fid
    """
    pass

  def toggle_safemode(self, ):
    pass

  def get_file_by_id(self, fid):
    """
    Parameters:
     - fid
    """
    pass

  def get_file_by_name(self, node, devid, location):
    """
    Parameters:
     - node
     - devid
     - location
    """
    pass

  def rm_file_logical(self, file):
    """
    Parameters:
     - file
    """
    pass

  def restore_file(self, file):
    """
    Parameters:
     - file
    """
    pass

  def rm_file_physical(self, file):
    """
    Parameters:
     - file
    """
    pass

  def get_node(self, node_name):
    """
    Parameters:
     - node_name
    """
    pass

  def add_node(self, node_name, ipl):
    """
    Parameters:
     - node_name
     - ipl
    """
    pass

  def del_node(self, node_name):
    """
    Parameters:
     - node_name
    """
    pass

  def create_device(self, devid, prop, node_name):
    """
    Parameters:
     - devid
     - prop
     - node_name
    """
    pass

  def get_device(self, devid):
    """
    Parameters:
     - devid
    """
    pass

  def del_device(self, devid):
    """
    Parameters:
     - devid
    """
    pass

  def modify_device(self, dev, node):
    """
    Parameters:
     - dev
     - node
    """
    pass

  def list_device(self, ):
    pass

  def alter_node(self, node_name, ipl, status):
    """
    Parameters:
     - node_name
     - ipl
     - status
    """
    pass

  def find_best_nodes(self, nr):
    """
    Parameters:
     - nr
    """
    pass

  def find_best_nodes_in_groups(self, dbName, tableName, nr, policy):
    """
    Parameters:
     - dbName
     - tableName
     - nr
     - policy
    """
    pass

  def get_all_nodes(self, ):
    pass

  def getDMStatus(self, ):
    pass

  def getNodeInfo(self, ):
    pass

  def migrate_in(self, tbl, files, idxs, from_db, to_devid, fileMap):
    """
    Parameters:
     - tbl
     - files
     - idxs
     - from_db
     - to_devid
     - fileMap
    """
    pass

  def migrate_stage1(self, dbName, tableName, files, to_db):
    """
    Parameters:
     - dbName
     - tableName
     - files
     - to_db
    """
    pass

  def migrate_stage2(self, dbName, tableName, files, from_db, to_db, to_devid, user, password):
    """
    Parameters:
     - dbName
     - tableName
     - files
     - from_db
     - to_db
     - to_devid
     - user
     - password
    """
    pass

  def migrate2_in(self, tbl, parts, idxs, from_db, to_nas_devid, fileMap):
    """
    Parameters:
     - tbl
     - parts
     - idxs
     - from_db
     - to_nas_devid
     - fileMap
    """
    pass

  def migrate2_stage1(self, dbName, tableName, partNames, to_db):
    """
    Parameters:
     - dbName
     - tableName
     - partNames
     - to_db
    """
    pass

  def migrate2_stage2(self, dbName, tableName, partNames, from_db, to_db, to_nas_devid):
    """
    Parameters:
     - dbName
     - tableName
     - partNames
     - from_db
     - to_db
     - to_nas_devid
    """
    pass

  def getMP(self, node_name, devid):
    """
    Parameters:
     - node_name
     - devid
    """
    pass

  def getSessionId(self, ):
    pass

  def createSchema(self, schema):
    """
    Parameters:
     - schema
    """
    pass

  def modifySchema(self, schemaName, schema):
    """
    Parameters:
     - schemaName
     - schema
    """
    pass

  def deleteSchema(self, schemaName):
    """
    Parameters:
     - schemaName
    """
    pass

  def listSchemas(self, ):
    pass

  def getSchemaByName(self, schemaName):
    """
    Parameters:
     - schemaName
    """
    pass

  def getTableNodeGroups(self, dbName, tabName):
    """
    Parameters:
     - dbName
     - tabName
    """
    pass

  def getTableNodeFiles(self, dbName, tabName, nodeName):
    """
    Parameters:
     - dbName
     - tabName
     - nodeName
    """
    pass

  def listTableFiles(self, dbName, tabName, from, to):
    """
    Parameters:
     - dbName
     - tabName
     - from
     - to
    """
    pass

  def listFilesByDigest(self, digest):
    """
    Parameters:
     - digest
    """
    pass

  def filterTableFiles(self, dbName, tabName, values):
    """
    Parameters:
     - dbName
     - tabName
     - values
    """
    pass

  def truncTableFiles(self, dbName, tabName):
    """
    Parameters:
     - dbName
     - tabName
    """
    pass

  def addNodeGroup(self, ng):
    """
    Parameters:
     - ng
    """
    pass

  def modifyNodeGroup(self, schemaName, ng):
    """
    Parameters:
     - schemaName
     - ng
    """
    pass

  def deleteNodeGroup(self, ng):
    """
    Parameters:
     - ng
    """
    pass

  def listNodeGroups(self, ):
    pass

  def listDBNodeGroups(self, dbName):
    """
    Parameters:
     - dbName
    """
    pass

  def listNodeGroupByNames(self, ngNames):
    """
    Parameters:
     - ngNames
    """
    pass

  def addTableNodeDist(self, db, tab, ng):
    """
    Parameters:
     - db
     - tab
     - ng
    """
    pass

  def deleteTableNodeDist(self, db, tab, ng):
    """
    Parameters:
     - db
     - tab
     - ng
    """
    pass

  def listTableNodeDists(self, dbName, tabName):
    """
    Parameters:
     - dbName
     - tabName
    """
    pass

  def assiginSchematoDB(self, dbName, schemaName, fileSplitKeys, part_keys, ngs):
    """
    Parameters:
     - dbName
     - schemaName
     - fileSplitKeys
     - part_keys
     - ngs
    """
    pass

  def statFileSystem(self, begin_time, end_time):
    """
    Parameters:
     - begin_time
     - end_time
    """
    pass

  def getMaxFid(self, ):
    pass


class Client(fb303.FacebookService.Client, Iface):
  """
  This interface is live.
  """
  def __init__(self, iprot, oprot=None):
    fb303.FacebookService.Client.__init__(self, iprot, oprot)

  def create_attribution(self, db):
    """
    Parameters:
     - db
    """
    self.send_create_attribution(db)
    self.recv_create_attribution()

  def send_create_attribution(self, db):
    self._oprot.writeMessageBegin('create_attribution', TMessageType.CALL, self._seqid)
    args = create_attribution_args()
    args.db = db
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_attribution(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_attribution_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def get_attribution(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_attribution(name)
    return self.recv_get_attribution()

  def send_get_attribution(self, name):
    self._oprot.writeMessageBegin('get_attribution', TMessageType.CALL, self._seqid)
    args = get_attribution_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_attribution(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_attribution_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_attribution failed: unknown result");

  def drop_attribution(self, name, deleteData, cascade):
    """
    Parameters:
     - name
     - deleteData
     - cascade
    """
    self.send_drop_attribution(name, deleteData, cascade)
    self.recv_drop_attribution()

  def send_drop_attribution(self, name, deleteData, cascade):
    self._oprot.writeMessageBegin('drop_attribution', TMessageType.CALL, self._seqid)
    args = drop_attribution_args()
    args.name = name
    args.deleteData = deleteData
    args.cascade = cascade
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_attribution(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_attribution_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def update_attribution(self, db):
    """
    Parameters:
     - db
    """
    self.send_update_attribution(db)
    self.recv_update_attribution()

  def send_update_attribution(self, db):
    self._oprot.writeMessageBegin('update_attribution', TMessageType.CALL, self._seqid)
    args = update_attribution_args()
    args.db = db
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_attribution(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = update_attribution_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def get_all_attributions(self, ):
    self.send_get_all_attributions()
    return self.recv_get_all_attributions()

  def send_get_all_attributions(self, ):
    self._oprot.writeMessageBegin('get_all_attributions', TMessageType.CALL, self._seqid)
    args = get_all_attributions_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_attributions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_all_attributions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_attributions failed: unknown result");

  def get_local_attribution(self, ):
    self.send_get_local_attribution()
    return self.recv_get_local_attribution()

  def send_get_local_attribution(self, ):
    self._oprot.writeMessageBegin('get_local_attribution', TMessageType.CALL, self._seqid)
    args = get_local_attribution_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_local_attribution(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_local_attribution_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_local_attribution failed: unknown result");

  def get_lucene_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_lucene_index_names(db_name, tbl_name, max_indexes)
    return self.recv_get_lucene_index_names()

  def send_get_lucene_index_names(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_lucene_index_names', TMessageType.CALL, self._seqid)
    args = get_lucene_index_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_lucene_index_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_lucene_index_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_lucene_index_names failed: unknown result");

  def get_all_busi_type_cols(self, ):
    self.send_get_all_busi_type_cols()
    return self.recv_get_all_busi_type_cols()

  def send_get_all_busi_type_cols(self, ):
    self._oprot.writeMessageBegin('get_all_busi_type_cols', TMessageType.CALL, self._seqid)
    args = get_all_busi_type_cols_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_busi_type_cols(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_all_busi_type_cols_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_busi_type_cols failed: unknown result");

  def get_all_busi_type_datacenters(self, ):
    self.send_get_all_busi_type_datacenters()
    return self.recv_get_all_busi_type_datacenters()

  def send_get_all_busi_type_datacenters(self, ):
    self._oprot.writeMessageBegin('get_all_busi_type_datacenters', TMessageType.CALL, self._seqid)
    args = get_all_busi_type_datacenters_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_busi_type_datacenters(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_all_busi_type_datacenters_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_busi_type_datacenters failed: unknown result");

  def append_busi_type_datacenter(self, busiTypeDatacenter):
    """
    Parameters:
     - busiTypeDatacenter
    """
    self.send_append_busi_type_datacenter(busiTypeDatacenter)
    self.recv_append_busi_type_datacenter()

  def send_append_busi_type_datacenter(self, busiTypeDatacenter):
    self._oprot.writeMessageBegin('append_busi_type_datacenter', TMessageType.CALL, self._seqid)
    args = append_busi_type_datacenter_args()
    args.busiTypeDatacenter = busiTypeDatacenter
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_busi_type_datacenter(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = append_busi_type_datacenter_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def add_datawarehouse_sql(self, dwNum, sql):
    """
    Parameters:
     - dwNum
     - sql
    """
    self.send_add_datawarehouse_sql(dwNum, sql)
    return self.recv_add_datawarehouse_sql()

  def send_add_datawarehouse_sql(self, dwNum, sql):
    self._oprot.writeMessageBegin('add_datawarehouse_sql', TMessageType.CALL, self._seqid)
    args = add_datawarehouse_sql_args()
    args.dwNum = dwNum
    args.sql = sql
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_datawarehouse_sql(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_datawarehouse_sql_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_datawarehouse_sql failed: unknown result");

  def showBusitypes(self, ):
    self.send_showBusitypes()
    return self.recv_showBusitypes()

  def send_showBusitypes(self, ):
    self._oprot.writeMessageBegin('showBusitypes', TMessageType.CALL, self._seqid)
    args = showBusitypes_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_showBusitypes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = showBusitypes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "showBusitypes failed: unknown result");

  def createBusitype(self, busitype):
    """
    Parameters:
     - busitype
    """
    self.send_createBusitype(busitype)
    return self.recv_createBusitype()

  def send_createBusitype(self, busitype):
    self._oprot.writeMessageBegin('createBusitype', TMessageType.CALL, self._seqid)
    args = createBusitype_args()
    args.busitype = busitype
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createBusitype(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createBusitype_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createBusitype failed: unknown result");

  def add_partition_files(self, part, files):
    """
    Parameters:
     - part
     - files
    """
    self.send_add_partition_files(part, files)
    return self.recv_add_partition_files()

  def send_add_partition_files(self, part, files):
    self._oprot.writeMessageBegin('add_partition_files', TMessageType.CALL, self._seqid)
    args = add_partition_files_args()
    args.part = part
    args.files = files
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition_files(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_partition_files_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition_files failed: unknown result");

  def drop_partition_files(self, part, files):
    """
    Parameters:
     - part
     - files
    """
    self.send_drop_partition_files(part, files)
    return self.recv_drop_partition_files()

  def send_drop_partition_files(self, part, files):
    self._oprot.writeMessageBegin('drop_partition_files', TMessageType.CALL, self._seqid)
    args = drop_partition_files_args()
    args.part = part
    args.files = files
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_files(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_partition_files_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_files failed: unknown result");

  def add_subpartition_files(self, subpart, files):
    """
    Parameters:
     - subpart
     - files
    """
    self.send_add_subpartition_files(subpart, files)
    return self.recv_add_subpartition_files()

  def send_add_subpartition_files(self, subpart, files):
    self._oprot.writeMessageBegin('add_subpartition_files', TMessageType.CALL, self._seqid)
    args = add_subpartition_files_args()
    args.subpart = subpart
    args.files = files
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_subpartition_files(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_subpartition_files_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_subpartition_files failed: unknown result");

  def drop_subpartition_files(self, subpart, files):
    """
    Parameters:
     - subpart
     - files
    """
    self.send_drop_subpartition_files(subpart, files)
    return self.recv_drop_subpartition_files()

  def send_drop_subpartition_files(self, subpart, files):
    self._oprot.writeMessageBegin('drop_subpartition_files', TMessageType.CALL, self._seqid)
    args = drop_subpartition_files_args()
    args.subpart = subpart
    args.files = files
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_subpartition_files(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_subpartition_files_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_subpartition_files failed: unknown result");

  def add_partition_index(self, index, part):
    """
    Parameters:
     - index
     - part
    """
    self.send_add_partition_index(index, part)
    return self.recv_add_partition_index()

  def send_add_partition_index(self, index, part):
    self._oprot.writeMessageBegin('add_partition_index', TMessageType.CALL, self._seqid)
    args = add_partition_index_args()
    args.index = index
    args.part = part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_partition_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition_index failed: unknown result");

  def drop_partition_index(self, index, part):
    """
    Parameters:
     - index
     - part
    """
    self.send_drop_partition_index(index, part)
    return self.recv_drop_partition_index()

  def send_drop_partition_index(self, index, part):
    self._oprot.writeMessageBegin('drop_partition_index', TMessageType.CALL, self._seqid)
    args = drop_partition_index_args()
    args.index = index
    args.part = part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_partition_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_index failed: unknown result");

  def add_subpartition_index(self, index, part):
    """
    Parameters:
     - index
     - part
    """
    self.send_add_subpartition_index(index, part)
    return self.recv_add_subpartition_index()

  def send_add_subpartition_index(self, index, part):
    self._oprot.writeMessageBegin('add_subpartition_index', TMessageType.CALL, self._seqid)
    args = add_subpartition_index_args()
    args.index = index
    args.part = part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_subpartition_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_subpartition_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_subpartition_index failed: unknown result");

  def drop_subpartition_index(self, index, part):
    """
    Parameters:
     - index
     - part
    """
    self.send_drop_subpartition_index(index, part)
    return self.recv_drop_subpartition_index()

  def send_drop_subpartition_index(self, index, part):
    self._oprot.writeMessageBegin('drop_subpartition_index', TMessageType.CALL, self._seqid)
    args = drop_subpartition_index_args()
    args.index = index
    args.part = part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_subpartition_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_subpartition_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_subpartition_index failed: unknown result");

  def add_subpartition(self, dbname, tbl_name, part_vals, sub_part):
    """
    Parameters:
     - dbname
     - tbl_name
     - part_vals
     - sub_part
    """
    self.send_add_subpartition(dbname, tbl_name, part_vals, sub_part)
    return self.recv_add_subpartition()

  def send_add_subpartition(self, dbname, tbl_name, part_vals, sub_part):
    self._oprot.writeMessageBegin('add_subpartition', TMessageType.CALL, self._seqid)
    args = add_subpartition_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.sub_part = sub_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_subpartition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_subpartition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_subpartition failed: unknown result");

  def get_subpartitions(self, dbname, tbl_name, part):
    """
    Parameters:
     - dbname
     - tbl_name
     - part
    """
    self.send_get_subpartitions(dbname, tbl_name, part)
    return self.recv_get_subpartitions()

  def send_get_subpartitions(self, dbname, tbl_name, part):
    self._oprot.writeMessageBegin('get_subpartitions', TMessageType.CALL, self._seqid)
    args = get_subpartitions_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.part = part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_subpartitions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_subpartitions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_subpartitions failed: unknown result");

  def add_partition_index_files(self, index, part, file, originfid):
    """
    Parameters:
     - index
     - part
     - file
     - originfid
    """
    self.send_add_partition_index_files(index, part, file, originfid)
    return self.recv_add_partition_index_files()

  def send_add_partition_index_files(self, index, part, file, originfid):
    self._oprot.writeMessageBegin('add_partition_index_files', TMessageType.CALL, self._seqid)
    args = add_partition_index_files_args()
    args.index = index
    args.part = part
    args.file = file
    args.originfid = originfid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition_index_files(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_partition_index_files_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition_index_files failed: unknown result");

  def get_partition_index_files(self, index, part):
    """
    Parameters:
     - index
     - part
    """
    self.send_get_partition_index_files(index, part)
    return self.recv_get_partition_index_files()

  def send_get_partition_index_files(self, index, part):
    self._oprot.writeMessageBegin('get_partition_index_files', TMessageType.CALL, self._seqid)
    args = get_partition_index_files_args()
    args.index = index
    args.part = part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_index_files(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_index_files_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_index_files failed: unknown result");

  def drop_partition_index_files(self, index, part, file):
    """
    Parameters:
     - index
     - part
     - file
    """
    self.send_drop_partition_index_files(index, part, file)
    return self.recv_drop_partition_index_files()

  def send_drop_partition_index_files(self, index, part, file):
    self._oprot.writeMessageBegin('drop_partition_index_files', TMessageType.CALL, self._seqid)
    args = drop_partition_index_files_args()
    args.index = index
    args.part = part
    args.file = file
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_index_files(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_partition_index_files_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_index_files failed: unknown result");

  def add_subpartition_index_files(self, index, subpart, file, originfid):
    """
    Parameters:
     - index
     - subpart
     - file
     - originfid
    """
    self.send_add_subpartition_index_files(index, subpart, file, originfid)
    return self.recv_add_subpartition_index_files()

  def send_add_subpartition_index_files(self, index, subpart, file, originfid):
    self._oprot.writeMessageBegin('add_subpartition_index_files', TMessageType.CALL, self._seqid)
    args = add_subpartition_index_files_args()
    args.index = index
    args.subpart = subpart
    args.file = file
    args.originfid = originfid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_subpartition_index_files(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_subpartition_index_files_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_subpartition_index_files failed: unknown result");

  def get_subpartition_index_files(self, index, subpart):
    """
    Parameters:
     - index
     - subpart
    """
    self.send_get_subpartition_index_files(index, subpart)
    return self.recv_get_subpartition_index_files()

  def send_get_subpartition_index_files(self, index, subpart):
    self._oprot.writeMessageBegin('get_subpartition_index_files', TMessageType.CALL, self._seqid)
    args = get_subpartition_index_files_args()
    args.index = index
    args.subpart = subpart
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_subpartition_index_files(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_subpartition_index_files_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_subpartition_index_files failed: unknown result");

  def drop_subpartition_index_files(self, index, subpart, file):
    """
    Parameters:
     - index
     - subpart
     - file
    """
    self.send_drop_subpartition_index_files(index, subpart, file)
    return self.recv_drop_subpartition_index_files()

  def send_drop_subpartition_index_files(self, index, subpart, file):
    self._oprot.writeMessageBegin('drop_subpartition_index_files', TMessageType.CALL, self._seqid)
    args = drop_subpartition_index_files_args()
    args.index = index
    args.subpart = subpart
    args.file = file
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_subpartition_index_files(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_subpartition_index_files_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_subpartition_index_files failed: unknown result");

  def addGeoLocation(self, gl):
    """
    Parameters:
     - gl
    """
    self.send_addGeoLocation(gl)
    return self.recv_addGeoLocation()

  def send_addGeoLocation(self, gl):
    self._oprot.writeMessageBegin('addGeoLocation', TMessageType.CALL, self._seqid)
    args = addGeoLocation_args()
    args.gl = gl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addGeoLocation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addGeoLocation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addGeoLocation failed: unknown result");

  def modifyGeoLocation(self, gl):
    """
    Parameters:
     - gl
    """
    self.send_modifyGeoLocation(gl)
    return self.recv_modifyGeoLocation()

  def send_modifyGeoLocation(self, gl):
    self._oprot.writeMessageBegin('modifyGeoLocation', TMessageType.CALL, self._seqid)
    args = modifyGeoLocation_args()
    args.gl = gl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_modifyGeoLocation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = modifyGeoLocation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "modifyGeoLocation failed: unknown result");

  def deleteGeoLocation(self, gl):
    """
    Parameters:
     - gl
    """
    self.send_deleteGeoLocation(gl)
    return self.recv_deleteGeoLocation()

  def send_deleteGeoLocation(self, gl):
    self._oprot.writeMessageBegin('deleteGeoLocation', TMessageType.CALL, self._seqid)
    args = deleteGeoLocation_args()
    args.gl = gl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteGeoLocation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteGeoLocation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteGeoLocation failed: unknown result");

  def listGeoLocation(self, ):
    self.send_listGeoLocation()
    return self.recv_listGeoLocation()

  def send_listGeoLocation(self, ):
    self._oprot.writeMessageBegin('listGeoLocation', TMessageType.CALL, self._seqid)
    args = listGeoLocation_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listGeoLocation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listGeoLocation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listGeoLocation failed: unknown result");

  def addEquipRoom(self, er):
    """
    Parameters:
     - er
    """
    self.send_addEquipRoom(er)
    return self.recv_addEquipRoom()

  def send_addEquipRoom(self, er):
    self._oprot.writeMessageBegin('addEquipRoom', TMessageType.CALL, self._seqid)
    args = addEquipRoom_args()
    args.er = er
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addEquipRoom(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addEquipRoom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addEquipRoom failed: unknown result");

  def modifyEquipRoom(self, er):
    """
    Parameters:
     - er
    """
    self.send_modifyEquipRoom(er)
    return self.recv_modifyEquipRoom()

  def send_modifyEquipRoom(self, er):
    self._oprot.writeMessageBegin('modifyEquipRoom', TMessageType.CALL, self._seqid)
    args = modifyEquipRoom_args()
    args.er = er
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_modifyEquipRoom(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = modifyEquipRoom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "modifyEquipRoom failed: unknown result");

  def deleteEquipRoom(self, er):
    """
    Parameters:
     - er
    """
    self.send_deleteEquipRoom(er)
    return self.recv_deleteEquipRoom()

  def send_deleteEquipRoom(self, er):
    self._oprot.writeMessageBegin('deleteEquipRoom', TMessageType.CALL, self._seqid)
    args = deleteEquipRoom_args()
    args.er = er
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteEquipRoom(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteEquipRoom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteEquipRoom failed: unknown result");

  def listEquipRoom(self, ):
    self.send_listEquipRoom()
    return self.recv_listEquipRoom()

  def send_listEquipRoom(self, ):
    self._oprot.writeMessageBegin('listEquipRoom', TMessageType.CALL, self._seqid)
    args = listEquipRoom_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listEquipRoom(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listEquipRoom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listEquipRoom failed: unknown result");

  def getGeoLocationByName(self, geoLocName):
    """
    Parameters:
     - geoLocName
    """
    self.send_getGeoLocationByName(geoLocName)
    return self.recv_getGeoLocationByName()

  def send_getGeoLocationByName(self, geoLocName):
    self._oprot.writeMessageBegin('getGeoLocationByName', TMessageType.CALL, self._seqid)
    args = getGeoLocationByName_args()
    args.geoLocName = geoLocName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGeoLocationByName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGeoLocationByName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGeoLocationByName failed: unknown result");

  def getGeoLocationByNames(self, geoLocNames):
    """
    Parameters:
     - geoLocNames
    """
    self.send_getGeoLocationByNames(geoLocNames)
    return self.recv_getGeoLocationByNames()

  def send_getGeoLocationByNames(self, geoLocNames):
    self._oprot.writeMessageBegin('getGeoLocationByNames', TMessageType.CALL, self._seqid)
    args = getGeoLocationByNames_args()
    args.geoLocNames = geoLocNames
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGeoLocationByNames(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getGeoLocationByNames_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGeoLocationByNames failed: unknown result");

  def addNodeAssignment(self, nodeName, dbName):
    """
    Parameters:
     - nodeName
     - dbName
    """
    self.send_addNodeAssignment(nodeName, dbName)
    return self.recv_addNodeAssignment()

  def send_addNodeAssignment(self, nodeName, dbName):
    self._oprot.writeMessageBegin('addNodeAssignment', TMessageType.CALL, self._seqid)
    args = addNodeAssignment_args()
    args.nodeName = nodeName
    args.dbName = dbName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addNodeAssignment(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addNodeAssignment_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addNodeAssignment failed: unknown result");

  def deleteNodeAssignment(self, nodeName, dbName):
    """
    Parameters:
     - nodeName
     - dbName
    """
    self.send_deleteNodeAssignment(nodeName, dbName)
    return self.recv_deleteNodeAssignment()

  def send_deleteNodeAssignment(self, nodeName, dbName):
    self._oprot.writeMessageBegin('deleteNodeAssignment', TMessageType.CALL, self._seqid)
    args = deleteNodeAssignment_args()
    args.nodeName = nodeName
    args.dbName = dbName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteNodeAssignment(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteNodeAssignment_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteNodeAssignment failed: unknown result");

  def listNodes(self, ):
    self.send_listNodes()
    return self.recv_listNodes()

  def send_listNodes(self, ):
    self._oprot.writeMessageBegin('listNodes', TMessageType.CALL, self._seqid)
    args = listNodes_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listNodes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listNodes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listNodes failed: unknown result");

  def addUserAssignment(self, roleName, dbName):
    """
    Parameters:
     - roleName
     - dbName
    """
    self.send_addUserAssignment(roleName, dbName)
    return self.recv_addUserAssignment()

  def send_addUserAssignment(self, roleName, dbName):
    self._oprot.writeMessageBegin('addUserAssignment', TMessageType.CALL, self._seqid)
    args = addUserAssignment_args()
    args.roleName = roleName
    args.dbName = dbName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addUserAssignment(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addUserAssignment_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addUserAssignment failed: unknown result");

  def deleteUserAssignment(self, roleName, dbName):
    """
    Parameters:
     - roleName
     - dbName
    """
    self.send_deleteUserAssignment(roleName, dbName)
    return self.recv_deleteUserAssignment()

  def send_deleteUserAssignment(self, roleName, dbName):
    self._oprot.writeMessageBegin('deleteUserAssignment', TMessageType.CALL, self._seqid)
    args = deleteUserAssignment_args()
    args.roleName = roleName
    args.dbName = dbName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteUserAssignment(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteUserAssignment_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteUserAssignment failed: unknown result");

  def listUsers(self, ):
    self.send_listUsers()
    return self.recv_listUsers()

  def send_listUsers(self, ):
    self._oprot.writeMessageBegin('listUsers', TMessageType.CALL, self._seqid)
    args = listUsers_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listUsers(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listUsers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listUsers failed: unknown result");

  def addRoleAssignment(self, userName, dbName):
    """
    Parameters:
     - userName
     - dbName
    """
    self.send_addRoleAssignment(userName, dbName)
    return self.recv_addRoleAssignment()

  def send_addRoleAssignment(self, userName, dbName):
    self._oprot.writeMessageBegin('addRoleAssignment', TMessageType.CALL, self._seqid)
    args = addRoleAssignment_args()
    args.userName = userName
    args.dbName = dbName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addRoleAssignment(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addRoleAssignment_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addRoleAssignment failed: unknown result");

  def deleteRoleAssignment(self, userName, dbName):
    """
    Parameters:
     - userName
     - dbName
    """
    self.send_deleteRoleAssignment(userName, dbName)
    return self.recv_deleteRoleAssignment()

  def send_deleteRoleAssignment(self, userName, dbName):
    self._oprot.writeMessageBegin('deleteRoleAssignment', TMessageType.CALL, self._seqid)
    args = deleteRoleAssignment_args()
    args.userName = userName
    args.dbName = dbName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteRoleAssignment(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteRoleAssignment_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteRoleAssignment failed: unknown result");

  def listRoles(self, ):
    self.send_listRoles()
    return self.recv_listRoles()

  def send_listRoles(self, ):
    self._oprot.writeMessageBegin('listRoles', TMessageType.CALL, self._seqid)
    args = listRoles_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listRoles(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listRoles_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listRoles failed: unknown result");

  def addNodeGroupAssignment(self, ng, dbName):
    """
    Parameters:
     - ng
     - dbName
    """
    self.send_addNodeGroupAssignment(ng, dbName)
    return self.recv_addNodeGroupAssignment()

  def send_addNodeGroupAssignment(self, ng, dbName):
    self._oprot.writeMessageBegin('addNodeGroupAssignment', TMessageType.CALL, self._seqid)
    args = addNodeGroupAssignment_args()
    args.ng = ng
    args.dbName = dbName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addNodeGroupAssignment(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addNodeGroupAssignment_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addNodeGroupAssignment failed: unknown result");

  def deleteNodeGroupAssignment(self, ng, dbName):
    """
    Parameters:
     - ng
     - dbName
    """
    self.send_deleteNodeGroupAssignment(ng, dbName)
    return self.recv_deleteNodeGroupAssignment()

  def send_deleteNodeGroupAssignment(self, ng, dbName):
    self._oprot.writeMessageBegin('deleteNodeGroupAssignment', TMessageType.CALL, self._seqid)
    args = deleteNodeGroupAssignment_args()
    args.ng = ng
    args.dbName = dbName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteNodeGroupAssignment(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteNodeGroupAssignment_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteNodeGroupAssignment failed: unknown result");

  def pingPong(self, str):
    """
    Parameters:
     - str
    """
    self.send_pingPong(str)
    return self.recv_pingPong()

  def send_pingPong(self, str):
    self._oprot.writeMessageBegin('pingPong', TMessageType.CALL, self._seqid)
    args = pingPong_args()
    args.str = str
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pingPong(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = pingPong_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pingPong failed: unknown result");

  def alterNodeGroup(self, ng):
    """
    Parameters:
     - ng
    """
    self.send_alterNodeGroup(ng)
    return self.recv_alterNodeGroup()

  def send_alterNodeGroup(self, ng):
    self._oprot.writeMessageBegin('alterNodeGroup', TMessageType.CALL, self._seqid)
    args = alterNodeGroup_args()
    args.ng = ng
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alterNodeGroup(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alterNodeGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "alterNodeGroup failed: unknown result");

  def create_database(self, database):
    """
    Parameters:
     - database
    """
    self.send_create_database(database)
    self.recv_create_database()

  def send_create_database(self, database):
    self._oprot.writeMessageBegin('create_database', TMessageType.CALL, self._seqid)
    args = create_database_args()
    args.database = database
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def get_database(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_database(name)
    return self.recv_get_database()

  def send_get_database(self, name):
    self._oprot.writeMessageBegin('get_database', TMessageType.CALL, self._seqid)
    args = get_database_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_database failed: unknown result");

  def drop_database(self, name, deleteData, cascade):
    """
    Parameters:
     - name
     - deleteData
     - cascade
    """
    self.send_drop_database(name, deleteData, cascade)
    self.recv_drop_database()

  def send_drop_database(self, name, deleteData, cascade):
    self._oprot.writeMessageBegin('drop_database', TMessageType.CALL, self._seqid)
    args = drop_database_args()
    args.name = name
    args.deleteData = deleteData
    args.cascade = cascade
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    return

  def get_databases(self, pattern):
    """
    Parameters:
     - pattern
    """
    self.send_get_databases(pattern)
    return self.recv_get_databases()

  def send_get_databases(self, pattern):
    self._oprot.writeMessageBegin('get_databases', TMessageType.CALL, self._seqid)
    args = get_databases_args()
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_databases(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_databases_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_databases failed: unknown result");

  def get_all_databases(self, ):
    self.send_get_all_databases()
    return self.recv_get_all_databases()

  def send_get_all_databases(self, ):
    self._oprot.writeMessageBegin('get_all_databases', TMessageType.CALL, self._seqid)
    args = get_all_databases_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_databases(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_all_databases_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_databases failed: unknown result");

  def alter_database(self, dbname, db):
    """
    Parameters:
     - dbname
     - db
    """
    self.send_alter_database(dbname, db)
    self.recv_alter_database()

  def send_alter_database(self, dbname, db):
    self._oprot.writeMessageBegin('alter_database', TMessageType.CALL, self._seqid)
    args = alter_database_args()
    args.dbname = dbname
    args.db = db
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_database(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_database_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def get_type(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_type(name)
    return self.recv_get_type()

  def send_get_type(self, name):
    self._oprot.writeMessageBegin('get_type', TMessageType.CALL, self._seqid)
    args = get_type_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type failed: unknown result");

  def create_type(self, type):
    """
    Parameters:
     - type
    """
    self.send_create_type(type)
    return self.recv_create_type()

  def send_create_type(self, type):
    self._oprot.writeMessageBegin('create_type', TMessageType.CALL, self._seqid)
    args = create_type_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_type failed: unknown result");

  def drop_type(self, type):
    """
    Parameters:
     - type
    """
    self.send_drop_type(type)
    return self.recv_drop_type()

  def send_drop_type(self, type):
    self._oprot.writeMessageBegin('drop_type', TMessageType.CALL, self._seqid)
    args = drop_type_args()
    args.type = type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_type failed: unknown result");

  def get_type_all(self, name):
    """
    Parameters:
     - name
    """
    self.send_get_type_all(name)
    return self.recv_get_type_all()

  def send_get_type_all(self, name):
    self._oprot.writeMessageBegin('get_type_all', TMessageType.CALL, self._seqid)
    args = get_type_all_args()
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_type_all(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_type_all_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type_all failed: unknown result");

  def get_fields(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    self.send_get_fields(db_name, table_name)
    return self.recv_get_fields()

  def send_get_fields(self, db_name, table_name):
    self._oprot.writeMessageBegin('get_fields', TMessageType.CALL, self._seqid)
    args = get_fields_args()
    args.db_name = db_name
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_fields(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_fields_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields failed: unknown result");

  def get_schema(self, db_name, table_name):
    """
    Parameters:
     - db_name
     - table_name
    """
    self.send_get_schema(db_name, table_name)
    return self.recv_get_schema()

  def send_get_schema(self, db_name, table_name):
    self._oprot.writeMessageBegin('get_schema', TMessageType.CALL, self._seqid)
    args = get_schema_args()
    args.db_name = db_name
    args.table_name = table_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_schema(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_schema_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result");

  def create_table(self, tbl):
    """
    Parameters:
     - tbl
    """
    self.send_create_table(tbl)
    self.recv_create_table()

  def send_create_table(self, tbl):
    self._oprot.writeMessageBegin('create_table', TMessageType.CALL, self._seqid)
    args = create_table_args()
    args.tbl = tbl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def create_table_by_user(self, tbl, user):
    """
    Parameters:
     - tbl
     - user
    """
    self.send_create_table_by_user(tbl, user)
    self.recv_create_table_by_user()

  def send_create_table_by_user(self, tbl, user):
    self._oprot.writeMessageBegin('create_table_by_user', TMessageType.CALL, self._seqid)
    args = create_table_by_user_args()
    args.tbl = tbl
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table_by_user(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_table_by_user_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def create_table_with_environment_context(self, tbl, environment_context):
    """
    Parameters:
     - tbl
     - environment_context
    """
    self.send_create_table_with_environment_context(tbl, environment_context)
    self.recv_create_table_with_environment_context()

  def send_create_table_with_environment_context(self, tbl, environment_context):
    self._oprot.writeMessageBegin('create_table_with_environment_context', TMessageType.CALL, self._seqid)
    args = create_table_with_environment_context_args()
    args.tbl = tbl
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_table_with_environment_context(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_table_with_environment_context_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    return

  def drop_table(self, dbname, name, deleteData):
    """
    Parameters:
     - dbname
     - name
     - deleteData
    """
    self.send_drop_table(dbname, name, deleteData)
    self.recv_drop_table()

  def send_drop_table(self, dbname, name, deleteData):
    self._oprot.writeMessageBegin('drop_table', TMessageType.CALL, self._seqid)
    args = drop_table_args()
    args.dbname = dbname
    args.name = name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o3 is not None:
      raise result.o3
    return

  def get_tables(self, db_name, pattern):
    """
    Parameters:
     - db_name
     - pattern
    """
    self.send_get_tables(db_name, pattern)
    return self.recv_get_tables()

  def send_get_tables(self, db_name, pattern):
    self._oprot.writeMessageBegin('get_tables', TMessageType.CALL, self._seqid)
    args = get_tables_args()
    args.db_name = db_name
    args.pattern = pattern
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_tables(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_tables_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result");

  def get_all_tables(self, db_name):
    """
    Parameters:
     - db_name
    """
    self.send_get_all_tables(db_name)
    return self.recv_get_all_tables()

  def send_get_all_tables(self, db_name):
    self._oprot.writeMessageBegin('get_all_tables', TMessageType.CALL, self._seqid)
    args = get_all_tables_args()
    args.db_name = db_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_tables(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_all_tables_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_tables failed: unknown result");

  def get_table(self, dbname, tbl_name):
    """
    Parameters:
     - dbname
     - tbl_name
    """
    self.send_get_table(dbname, tbl_name)
    return self.recv_get_table()

  def send_get_table(self, dbname, tbl_name):
    self._oprot.writeMessageBegin('get_table', TMessageType.CALL, self._seqid)
    args = get_table_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table failed: unknown result");

  def get_table_objects_by_name(self, dbname, tbl_names):
    """
    Parameters:
     - dbname
     - tbl_names
    """
    self.send_get_table_objects_by_name(dbname, tbl_names)
    return self.recv_get_table_objects_by_name()

  def send_get_table_objects_by_name(self, dbname, tbl_names):
    self._oprot.writeMessageBegin('get_table_objects_by_name', TMessageType.CALL, self._seqid)
    args = get_table_objects_by_name_args()
    args.dbname = dbname
    args.tbl_names = tbl_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_objects_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_objects_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_objects_by_name failed: unknown result");

  def get_table_names_by_filter(self, dbname, filter, max_tables):
    """
    Parameters:
     - dbname
     - filter
     - max_tables
    """
    self.send_get_table_names_by_filter(dbname, filter, max_tables)
    return self.recv_get_table_names_by_filter()

  def send_get_table_names_by_filter(self, dbname, filter, max_tables):
    self._oprot.writeMessageBegin('get_table_names_by_filter', TMessageType.CALL, self._seqid)
    args = get_table_names_by_filter_args()
    args.dbname = dbname
    args.filter = filter
    args.max_tables = max_tables
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_names_by_filter(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_names_by_filter_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_names_by_filter failed: unknown result");

  def alter_table(self, dbname, tbl_name, new_tbl):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
    """
    self.send_alter_table(dbname, tbl_name, new_tbl)
    self.recv_alter_table()

  def send_alter_table(self, dbname, tbl_name, new_tbl):
    self._oprot.writeMessageBegin('alter_table', TMessageType.CALL, self._seqid)
    args = alter_table_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.new_tbl = new_tbl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_table_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
    """
    Parameters:
     - dbname
     - tbl_name
     - new_tbl
     - environment_context
    """
    self.send_alter_table_with_environment_context(dbname, tbl_name, new_tbl, environment_context)
    self.recv_alter_table_with_environment_context()

  def send_alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
    self._oprot.writeMessageBegin('alter_table_with_environment_context', TMessageType.CALL, self._seqid)
    args = alter_table_with_environment_context_args()
    args.dbname = dbname
    args.tbl_name = tbl_name
    args.new_tbl = new_tbl
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_table_with_environment_context(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_table_with_environment_context_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def add_partition(self, new_part):
    """
    Parameters:
     - new_part
    """
    self.send_add_partition(new_part)
    return self.recv_add_partition()

  def send_add_partition(self, new_part):
    self._oprot.writeMessageBegin('add_partition', TMessageType.CALL, self._seqid)
    args = add_partition_args()
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition failed: unknown result");

  def add_partition_with_environment_context(self, new_part, environment_context):
    """
    Parameters:
     - new_part
     - environment_context
    """
    self.send_add_partition_with_environment_context(new_part, environment_context)
    return self.recv_add_partition_with_environment_context()

  def send_add_partition_with_environment_context(self, new_part, environment_context):
    self._oprot.writeMessageBegin('add_partition_with_environment_context', TMessageType.CALL, self._seqid)
    args = add_partition_with_environment_context_args()
    args.new_part = new_part
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partition_with_environment_context(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_partition_with_environment_context_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition_with_environment_context failed: unknown result");

  def add_partitions(self, new_parts):
    """
    Parameters:
     - new_parts
    """
    self.send_add_partitions(new_parts)
    return self.recv_add_partitions()

  def send_add_partitions(self, new_parts):
    self._oprot.writeMessageBegin('add_partitions', TMessageType.CALL, self._seqid)
    args = add_partitions_args()
    args.new_parts = new_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_partitions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_partitions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions failed: unknown result");

  def append_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    self.send_append_partition(db_name, tbl_name, part_vals)
    return self.recv_append_partition()

  def send_append_partition(self, db_name, tbl_name, part_vals):
    self._oprot.writeMessageBegin('append_partition', TMessageType.CALL, self._seqid)
    args = append_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = append_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition failed: unknown result");

  def append_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    self.send_append_partition_by_name(db_name, tbl_name, part_name)
    return self.recv_append_partition_by_name()

  def send_append_partition_by_name(self, db_name, tbl_name, part_name):
    self._oprot.writeMessageBegin('append_partition_by_name', TMessageType.CALL, self._seqid)
    args = append_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_append_partition_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = append_partition_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name failed: unknown result");

  def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """
    self.send_drop_partition(db_name, tbl_name, part_vals, deleteData)
    return self.recv_drop_partition()

  def send_drop_partition(self, db_name, tbl_name, part_vals, deleteData):
    self._oprot.writeMessageBegin('drop_partition', TMessageType.CALL, self._seqid)
    args = drop_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition failed: unknown result");

  def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """
    self.send_drop_partition_by_name(db_name, tbl_name, part_name, deleteData)
    return self.recv_drop_partition_by_name()

  def send_drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
    self._oprot.writeMessageBegin('drop_partition_by_name', TMessageType.CALL, self._seqid)
    args = drop_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_partition_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_partition_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name failed: unknown result");

  def get_partition(self, db_name, tbl_name, part_vals):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
    """
    self.send_get_partition(db_name, tbl_name, part_vals)
    return self.recv_get_partition()

  def send_get_partition(self, db_name, tbl_name, part_vals):
    self._oprot.writeMessageBegin('get_partition', TMessageType.CALL, self._seqid)
    args = get_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition failed: unknown result");

  def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names
    """
    self.send_get_partition_with_auth(db_name, tbl_name, part_vals, user_name, group_names)
    return self.recv_get_partition_with_auth()

  def send_get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
    self._oprot.writeMessageBegin('get_partition_with_auth', TMessageType.CALL, self._seqid)
    args = get_partition_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_with_auth(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_with_auth_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_with_auth failed: unknown result");

  def get_partition_by_name(self, db_name, tbl_name, part_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
    """
    self.send_get_partition_by_name(db_name, tbl_name, part_name)
    return self.recv_get_partition_by_name()

  def send_get_partition_by_name(self, db_name, tbl_name, part_name):
    self._oprot.writeMessageBegin('get_partition_by_name', TMessageType.CALL, self._seqid)
    args = get_partition_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_by_name failed: unknown result");

  def get_partitions(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partitions(db_name, tbl_name, max_parts)
    return self.recv_get_partitions()

  def send_get_partitions(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partitions', TMessageType.CALL, self._seqid)
    args = get_partitions_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions failed: unknown result");

  def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names
    """
    self.send_get_partitions_with_auth(db_name, tbl_name, max_parts, user_name, group_names)
    return self.recv_get_partitions_with_auth()

  def send_get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
    self._oprot.writeMessageBegin('get_partitions_with_auth', TMessageType.CALL, self._seqid)
    args = get_partitions_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_with_auth(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_with_auth_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_with_auth failed: unknown result");

  def get_partition_names(self, db_name, tbl_name, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_parts
    """
    self.send_get_partition_names(db_name, tbl_name, max_parts)
    return self.recv_get_partition_names()

  def send_get_partition_names(self, db_name, tbl_name, max_parts):
    self._oprot.writeMessageBegin('get_partition_names', TMessageType.CALL, self._seqid)
    args = get_partition_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names failed: unknown result");

  def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    self.send_get_partitions_ps(db_name, tbl_name, part_vals, max_parts)
    return self.recv_get_partitions_ps()

  def send_get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
    self._oprot.writeMessageBegin('get_partitions_ps', TMessageType.CALL, self._seqid)
    args = get_partitions_ps_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_ps(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_ps_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps failed: unknown result");

  def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names
    """
    self.send_get_partitions_ps_with_auth(db_name, tbl_name, part_vals, max_parts, user_name, group_names)
    return self.recv_get_partitions_ps_with_auth()

  def send_get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
    self._oprot.writeMessageBegin('get_partitions_ps_with_auth', TMessageType.CALL, self._seqid)
    args = get_partitions_ps_with_auth_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_ps_with_auth(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_ps_with_auth_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps_with_auth failed: unknown result");

  def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """
    self.send_get_partition_names_ps(db_name, tbl_name, part_vals, max_parts)
    return self.recv_get_partition_names_ps()

  def send_get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
    self._oprot.writeMessageBegin('get_partition_names_ps', TMessageType.CALL, self._seqid)
    args = get_partition_names_ps_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_names_ps(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_names_ps_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_ps failed: unknown result");

  def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """
    self.send_get_partitions_by_filter(db_name, tbl_name, filter, max_parts)
    return self.recv_get_partitions_by_filter()

  def send_get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
    self._oprot.writeMessageBegin('get_partitions_by_filter', TMessageType.CALL, self._seqid)
    args = get_partitions_by_filter_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.filter = filter
    args.max_parts = max_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_by_filter(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_by_filter_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_filter failed: unknown result");

  def get_partitions_by_names(self, db_name, tbl_name, names):
    """
    Parameters:
     - db_name
     - tbl_name
     - names
    """
    self.send_get_partitions_by_names(db_name, tbl_name, names)
    return self.recv_get_partitions_by_names()

  def send_get_partitions_by_names(self, db_name, tbl_name, names):
    self._oprot.writeMessageBegin('get_partitions_by_names', TMessageType.CALL, self._seqid)
    args = get_partitions_by_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.names = names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partitions_by_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partitions_by_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_names failed: unknown result");

  def alter_partition(self, db_name, tbl_name, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
    """
    self.send_alter_partition(db_name, tbl_name, new_part)
    self.recv_alter_partition()

  def send_alter_partition(self, db_name, tbl_name, new_part):
    self._oprot.writeMessageBegin('alter_partition', TMessageType.CALL, self._seqid)
    args = alter_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_partitions(self, db_name, tbl_name, new_parts):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_parts
    """
    self.send_alter_partitions(db_name, tbl_name, new_parts)
    self.recv_alter_partitions()

  def send_alter_partitions(self, db_name, tbl_name, new_parts):
    self._oprot.writeMessageBegin('alter_partitions', TMessageType.CALL, self._seqid)
    args = alter_partitions_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_parts = new_parts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partitions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_partitions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
    """
    Parameters:
     - db_name
     - tbl_name
     - new_part
     - environment_context
    """
    self.send_alter_partition_with_environment_context(db_name, tbl_name, new_part, environment_context)
    self.recv_alter_partition_with_environment_context()

  def send_alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
    self._oprot.writeMessageBegin('alter_partition_with_environment_context', TMessageType.CALL, self._seqid)
    args = alter_partition_with_environment_context_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.new_part = new_part
    args.environment_context = environment_context
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_partition_with_environment_context(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_partition_with_environment_context_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def rename_partition(self, db_name, tbl_name, part_vals, new_part):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - new_part
    """
    self.send_rename_partition(db_name, tbl_name, part_vals, new_part)
    self.recv_rename_partition()

  def send_rename_partition(self, db_name, tbl_name, part_vals, new_part):
    self._oprot.writeMessageBegin('rename_partition', TMessageType.CALL, self._seqid)
    args = rename_partition_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.new_part = new_part
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rename_partition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = rename_partition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def get_config_value(self, name, defaultValue):
    """
    Parameters:
     - name
     - defaultValue
    """
    self.send_get_config_value(name, defaultValue)
    return self.recv_get_config_value()

  def send_get_config_value(self, name, defaultValue):
    self._oprot.writeMessageBegin('get_config_value', TMessageType.CALL, self._seqid)
    args = get_config_value_args()
    args.name = name
    args.defaultValue = defaultValue
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_config_value(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_config_value_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_config_value failed: unknown result");

  def partition_name_to_vals(self, part_name):
    """
    Parameters:
     - part_name
    """
    self.send_partition_name_to_vals(part_name)
    return self.recv_partition_name_to_vals()

  def send_partition_name_to_vals(self, part_name):
    self._oprot.writeMessageBegin('partition_name_to_vals', TMessageType.CALL, self._seqid)
    args = partition_name_to_vals_args()
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_to_vals(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = partition_name_to_vals_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_vals failed: unknown result");

  def partition_name_to_spec(self, part_name):
    """
    Parameters:
     - part_name
    """
    self.send_partition_name_to_spec(part_name)
    return self.recv_partition_name_to_spec()

  def send_partition_name_to_spec(self, part_name):
    self._oprot.writeMessageBegin('partition_name_to_spec', TMessageType.CALL, self._seqid)
    args = partition_name_to_spec_args()
    args.part_name = part_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_partition_name_to_spec(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = partition_name_to_spec_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_spec failed: unknown result");

  def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    self.send_markPartitionForEvent(db_name, tbl_name, part_vals, eventType)
    self.recv_markPartitionForEvent()

  def send_markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
    self._oprot.writeMessageBegin('markPartitionForEvent', TMessageType.CALL, self._seqid)
    args = markPartitionForEvent_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.eventType = eventType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_markPartitionForEvent(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = markPartitionForEvent_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    if result.o5 is not None:
      raise result.o5
    if result.o6 is not None:
      raise result.o6
    return

  def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """
    self.send_isPartitionMarkedForEvent(db_name, tbl_name, part_vals, eventType)
    return self.recv_isPartitionMarkedForEvent()

  def send_isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
    self._oprot.writeMessageBegin('isPartitionMarkedForEvent', TMessageType.CALL, self._seqid)
    args = isPartitionMarkedForEvent_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_vals = part_vals
    args.eventType = eventType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isPartitionMarkedForEvent(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = isPartitionMarkedForEvent_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    if result.o5 is not None:
      raise result.o5
    if result.o6 is not None:
      raise result.o6
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isPartitionMarkedForEvent failed: unknown result");

  def add_index(self, new_index, index_table):
    """
    Parameters:
     - new_index
     - index_table
    """
    self.send_add_index(new_index, index_table)
    return self.recv_add_index()

  def send_add_index(self, new_index, index_table):
    self._oprot.writeMessageBegin('add_index', TMessageType.CALL, self._seqid)
    args = add_index_args()
    args.new_index = new_index
    args.index_table = index_table
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_index failed: unknown result");

  def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    """
    Parameters:
     - dbname
     - base_tbl_name
     - idx_name
     - new_idx
    """
    self.send_alter_index(dbname, base_tbl_name, idx_name, new_idx)
    self.recv_alter_index()

  def send_alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
    self._oprot.writeMessageBegin('alter_index', TMessageType.CALL, self._seqid)
    args = alter_index_args()
    args.dbname = dbname
    args.base_tbl_name = base_tbl_name
    args.idx_name = idx_name
    args.new_idx = new_idx
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    return

  def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """
    self.send_drop_index_by_name(db_name, tbl_name, index_name, deleteData)
    return self.recv_drop_index_by_name()

  def send_drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
    self._oprot.writeMessageBegin('drop_index_by_name', TMessageType.CALL, self._seqid)
    args = drop_index_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.index_name = index_name
    args.deleteData = deleteData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_index_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_index_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_index_by_name failed: unknown result");

  def get_index_by_name(self, db_name, tbl_name, index_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - index_name
    """
    self.send_get_index_by_name(db_name, tbl_name, index_name)
    return self.recv_get_index_by_name()

  def send_get_index_by_name(self, db_name, tbl_name, index_name):
    self._oprot.writeMessageBegin('get_index_by_name', TMessageType.CALL, self._seqid)
    args = get_index_by_name_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.index_name = index_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_index_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_index_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_by_name failed: unknown result");

  def get_indexes(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_indexes(db_name, tbl_name, max_indexes)
    return self.recv_get_indexes()

  def send_get_indexes(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_indexes', TMessageType.CALL, self._seqid)
    args = get_indexes_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_indexes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_indexes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_indexes failed: unknown result");

  def get_index_names(self, db_name, tbl_name, max_indexes):
    """
    Parameters:
     - db_name
     - tbl_name
     - max_indexes
    """
    self.send_get_index_names(db_name, tbl_name, max_indexes)
    return self.recv_get_index_names()

  def send_get_index_names(self, db_name, tbl_name, max_indexes):
    self._oprot.writeMessageBegin('get_index_names', TMessageType.CALL, self._seqid)
    args = get_index_names_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.max_indexes = max_indexes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_index_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_index_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_names failed: unknown result");

  def update_table_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    self.send_update_table_column_statistics(stats_obj)
    return self.recv_update_table_column_statistics()

  def send_update_table_column_statistics(self, stats_obj):
    self._oprot.writeMessageBegin('update_table_column_statistics', TMessageType.CALL, self._seqid)
    args = update_table_column_statistics_args()
    args.stats_obj = stats_obj
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_table_column_statistics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = update_table_column_statistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_table_column_statistics failed: unknown result");

  def update_partition_column_statistics(self, stats_obj):
    """
    Parameters:
     - stats_obj
    """
    self.send_update_partition_column_statistics(stats_obj)
    return self.recv_update_partition_column_statistics()

  def send_update_partition_column_statistics(self, stats_obj):
    self._oprot.writeMessageBegin('update_partition_column_statistics', TMessageType.CALL, self._seqid)
    args = update_partition_column_statistics_args()
    args.stats_obj = stats_obj
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_partition_column_statistics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = update_partition_column_statistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_partition_column_statistics failed: unknown result");

  def get_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    self.send_get_table_column_statistics(db_name, tbl_name, col_name)
    return self.recv_get_table_column_statistics()

  def send_get_table_column_statistics(self, db_name, tbl_name, col_name):
    self._oprot.writeMessageBegin('get_table_column_statistics', TMessageType.CALL, self._seqid)
    args = get_table_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_table_column_statistics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_table_column_statistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_column_statistics failed: unknown result");

  def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    self.send_get_partition_column_statistics(db_name, tbl_name, part_name, col_name)
    return self.recv_get_partition_column_statistics()

  def send_get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    self._oprot.writeMessageBegin('get_partition_column_statistics', TMessageType.CALL, self._seqid)
    args = get_partition_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_partition_column_statistics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_partition_column_statistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_column_statistics failed: unknown result");

  def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """
    self.send_delete_partition_column_statistics(db_name, tbl_name, part_name, col_name)
    return self.recv_delete_partition_column_statistics()

  def send_delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
    self._oprot.writeMessageBegin('delete_partition_column_statistics', TMessageType.CALL, self._seqid)
    args = delete_partition_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.part_name = part_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_partition_column_statistics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = delete_partition_column_statistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_partition_column_statistics failed: unknown result");

  def delete_table_column_statistics(self, db_name, tbl_name, col_name):
    """
    Parameters:
     - db_name
     - tbl_name
     - col_name
    """
    self.send_delete_table_column_statistics(db_name, tbl_name, col_name)
    return self.recv_delete_table_column_statistics()

  def send_delete_table_column_statistics(self, db_name, tbl_name, col_name):
    self._oprot.writeMessageBegin('delete_table_column_statistics', TMessageType.CALL, self._seqid)
    args = delete_table_column_statistics_args()
    args.db_name = db_name
    args.tbl_name = tbl_name
    args.col_name = col_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_table_column_statistics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = delete_table_column_statistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    if result.o4 is not None:
      raise result.o4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_table_column_statistics failed: unknown result");

  def create_user(self, user):
    """
    Parameters:
     - user
    """
    self.send_create_user(user)
    return self.recv_create_user()

  def send_create_user(self, user):
    self._oprot.writeMessageBegin('create_user', TMessageType.CALL, self._seqid)
    args = create_user_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_user(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_user_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_user failed: unknown result");

  def drop_user(self, user_name):
    """
    Parameters:
     - user_name
    """
    self.send_drop_user(user_name)
    return self.recv_drop_user()

  def send_drop_user(self, user_name):
    self._oprot.writeMessageBegin('drop_user', TMessageType.CALL, self._seqid)
    args = drop_user_args()
    args.user_name = user_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_user(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_user_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_user failed: unknown result");

  def modify_user(self, user):
    """
    Parameters:
     - user
    """
    self.send_modify_user(user)
    return self.recv_modify_user()

  def send_modify_user(self, user):
    self._oprot.writeMessageBegin('modify_user', TMessageType.CALL, self._seqid)
    args = modify_user_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_modify_user(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = modify_user_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "modify_user failed: unknown result");

  def list_users_names(self, ):
    self.send_list_users_names()
    return self.recv_list_users_names()

  def send_list_users_names(self, ):
    self._oprot.writeMessageBegin('list_users_names', TMessageType.CALL, self._seqid)
    args = list_users_names_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_users_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_users_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_users_names failed: unknown result");

  def list_users(self, db):
    """
    Parameters:
     - db
    """
    self.send_list_users(db)
    return self.recv_list_users()

  def send_list_users(self, db):
    self._oprot.writeMessageBegin('list_users', TMessageType.CALL, self._seqid)
    args = list_users_args()
    args.db = db
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_users(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_users_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_users failed: unknown result");

  def authentication(self, user_name, passwd):
    """
    Parameters:
     - user_name
     - passwd
    """
    self.send_authentication(user_name, passwd)
    return self.recv_authentication()

  def send_authentication(self, user_name, passwd):
    self._oprot.writeMessageBegin('authentication', TMessageType.CALL, self._seqid)
    args = authentication_args()
    args.user_name = user_name
    args.passwd = passwd
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authentication(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authentication_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authentication failed: unknown result");

  def user_authority_check(self, user, tbl, ops):
    """
    Parameters:
     - user
     - tbl
     - ops
    """
    self.send_user_authority_check(user, tbl, ops)
    return self.recv_user_authority_check()

  def send_user_authority_check(self, user, tbl, ops):
    self._oprot.writeMessageBegin('user_authority_check', TMessageType.CALL, self._seqid)
    args = user_authority_check_args()
    args.user = user
    args.tbl = tbl
    args.ops = ops
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_user_authority_check(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = user_authority_check_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "user_authority_check failed: unknown result");

  def create_role(self, role):
    """
    Parameters:
     - role
    """
    self.send_create_role(role)
    return self.recv_create_role()

  def send_create_role(self, role):
    self._oprot.writeMessageBegin('create_role', TMessageType.CALL, self._seqid)
    args = create_role_args()
    args.role = role
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_role(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_role_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_role failed: unknown result");

  def drop_role(self, role_name):
    """
    Parameters:
     - role_name
    """
    self.send_drop_role(role_name)
    return self.recv_drop_role()

  def send_drop_role(self, role_name):
    self._oprot.writeMessageBegin('drop_role', TMessageType.CALL, self._seqid)
    args = drop_role_args()
    args.role_name = role_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drop_role(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drop_role_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_role failed: unknown result");

  def get_role_names(self, ):
    self.send_get_role_names()
    return self.recv_get_role_names()

  def send_get_role_names(self, ):
    self._oprot.writeMessageBegin('get_role_names', TMessageType.CALL, self._seqid)
    args = get_role_names_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_role_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_role_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_names failed: unknown result");

  def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option
    """
    self.send_grant_role(role_name, principal_name, principal_type, grantor, grantorType, grant_option)
    return self.recv_grant_role()

  def send_grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
    self._oprot.writeMessageBegin('grant_role', TMessageType.CALL, self._seqid)
    args = grant_role_args()
    args.role_name = role_name
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.grantor = grantor
    args.grantorType = grantorType
    args.grant_option = grant_option
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_role(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = grant_role_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_role failed: unknown result");

  def revoke_role(self, role_name, principal_name, principal_type):
    """
    Parameters:
     - role_name
     - principal_name
     - principal_type
    """
    self.send_revoke_role(role_name, principal_name, principal_type)
    return self.recv_revoke_role()

  def send_revoke_role(self, role_name, principal_name, principal_type):
    self._oprot.writeMessageBegin('revoke_role', TMessageType.CALL, self._seqid)
    args = revoke_role_args()
    args.role_name = role_name
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revoke_role(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = revoke_role_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_role failed: unknown result");

  def list_roles(self, principal_name, principal_type):
    """
    Parameters:
     - principal_name
     - principal_type
    """
    self.send_list_roles(principal_name, principal_type)
    return self.recv_list_roles()

  def send_list_roles(self, principal_name, principal_type):
    self._oprot.writeMessageBegin('list_roles', TMessageType.CALL, self._seqid)
    args = list_roles_args()
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_roles(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_roles_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_roles failed: unknown result");

  def get_privilege_set(self, hiveObject, user_name, group_names):
    """
    Parameters:
     - hiveObject
     - user_name
     - group_names
    """
    self.send_get_privilege_set(hiveObject, user_name, group_names)
    return self.recv_get_privilege_set()

  def send_get_privilege_set(self, hiveObject, user_name, group_names):
    self._oprot.writeMessageBegin('get_privilege_set', TMessageType.CALL, self._seqid)
    args = get_privilege_set_args()
    args.hiveObject = hiveObject
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_privilege_set(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_privilege_set_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_privilege_set failed: unknown result");

  def list_privileges(self, principal_name, principal_type, hiveObject):
    """
    Parameters:
     - principal_name
     - principal_type
     - hiveObject
    """
    self.send_list_privileges(principal_name, principal_type, hiveObject)
    return self.recv_list_privileges()

  def send_list_privileges(self, principal_name, principal_type, hiveObject):
    self._oprot.writeMessageBegin('list_privileges', TMessageType.CALL, self._seqid)
    args = list_privileges_args()
    args.principal_name = principal_name
    args.principal_type = principal_type
    args.hiveObject = hiveObject
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_privileges(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_privileges_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_privileges failed: unknown result");

  def grant_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    self.send_grant_privileges(privileges)
    return self.recv_grant_privileges()

  def send_grant_privileges(self, privileges):
    self._oprot.writeMessageBegin('grant_privileges', TMessageType.CALL, self._seqid)
    args = grant_privileges_args()
    args.privileges = privileges
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_grant_privileges(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = grant_privileges_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_privileges failed: unknown result");

  def revoke_privileges(self, privileges):
    """
    Parameters:
     - privileges
    """
    self.send_revoke_privileges(privileges)
    return self.recv_revoke_privileges()

  def send_revoke_privileges(self, privileges):
    self._oprot.writeMessageBegin('revoke_privileges', TMessageType.CALL, self._seqid)
    args = revoke_privileges_args()
    args.privileges = privileges
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revoke_privileges(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = revoke_privileges_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_privileges failed: unknown result");

  def set_ugi(self, user_name, group_names):
    """
    Parameters:
     - user_name
     - group_names
    """
    self.send_set_ugi(user_name, group_names)
    return self.recv_set_ugi()

  def send_set_ugi(self, user_name, group_names):
    self._oprot.writeMessageBegin('set_ugi', TMessageType.CALL, self._seqid)
    args = set_ugi_args()
    args.user_name = user_name
    args.group_names = group_names
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_ugi(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = set_ugi_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_ugi failed: unknown result");

  def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    """
    Parameters:
     - token_owner
     - renewer_kerberos_principal_name
    """
    self.send_get_delegation_token(token_owner, renewer_kerberos_principal_name)
    return self.recv_get_delegation_token()

  def send_get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
    self._oprot.writeMessageBegin('get_delegation_token', TMessageType.CALL, self._seqid)
    args = get_delegation_token_args()
    args.token_owner = token_owner
    args.renewer_kerberos_principal_name = renewer_kerberos_principal_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_delegation_token(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_delegation_token_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_delegation_token failed: unknown result");

  def renew_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    self.send_renew_delegation_token(token_str_form)
    return self.recv_renew_delegation_token()

  def send_renew_delegation_token(self, token_str_form):
    self._oprot.writeMessageBegin('renew_delegation_token', TMessageType.CALL, self._seqid)
    args = renew_delegation_token_args()
    args.token_str_form = token_str_form
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_renew_delegation_token(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = renew_delegation_token_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "renew_delegation_token failed: unknown result");

  def cancel_delegation_token(self, token_str_form):
    """
    Parameters:
     - token_str_form
    """
    self.send_cancel_delegation_token(token_str_form)
    self.recv_cancel_delegation_token()

  def send_cancel_delegation_token(self, token_str_form):
    self._oprot.writeMessageBegin('cancel_delegation_token', TMessageType.CALL, self._seqid)
    args = cancel_delegation_token_args()
    args.token_str_form = token_str_form
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cancel_delegation_token(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cancel_delegation_token_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def create_file(self, node_name, repnr, db_name, table_name, values):
    """
    Parameters:
     - node_name
     - repnr
     - db_name
     - table_name
     - values
    """
    self.send_create_file(node_name, repnr, db_name, table_name, values)
    return self.recv_create_file()

  def send_create_file(self, node_name, repnr, db_name, table_name, values):
    self._oprot.writeMessageBegin('create_file', TMessageType.CALL, self._seqid)
    args = create_file_args()
    args.node_name = node_name
    args.repnr = repnr
    args.db_name = db_name
    args.table_name = table_name
    args.values = values
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_file(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_file_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_file failed: unknown result");

  def create_file_by_policy(self, policy, repnr, db_name, table_name, values):
    """
    Parameters:
     - policy
     - repnr
     - db_name
     - table_name
     - values
    """
    self.send_create_file_by_policy(policy, repnr, db_name, table_name, values)
    return self.recv_create_file_by_policy()

  def send_create_file_by_policy(self, policy, repnr, db_name, table_name, values):
    self._oprot.writeMessageBegin('create_file_by_policy', TMessageType.CALL, self._seqid)
    args = create_file_by_policy_args()
    args.policy = policy
    args.repnr = repnr
    args.db_name = db_name
    args.table_name = table_name
    args.values = values
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_file_by_policy(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_file_by_policy_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_file_by_policy failed: unknown result");

  def set_file_repnr(self, fid, repnr):
    """
    Parameters:
     - fid
     - repnr
    """
    self.send_set_file_repnr(fid, repnr)
    self.recv_set_file_repnr()

  def send_set_file_repnr(self, fid, repnr):
    self._oprot.writeMessageBegin('set_file_repnr', TMessageType.CALL, self._seqid)
    args = set_file_repnr_args()
    args.fid = fid
    args.repnr = repnr
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_file_repnr(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = set_file_repnr_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def reopen_file(self, fid):
    """
    Parameters:
     - fid
    """
    self.send_reopen_file(fid)
    return self.recv_reopen_file()

  def send_reopen_file(self, fid):
    self._oprot.writeMessageBegin('reopen_file', TMessageType.CALL, self._seqid)
    args = reopen_file_args()
    args.fid = fid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_reopen_file(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = reopen_file_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "reopen_file failed: unknown result");

  def close_file(self, file):
    """
    Parameters:
     - file
    """
    self.send_close_file(file)
    return self.recv_close_file()

  def send_close_file(self, file):
    self._oprot.writeMessageBegin('close_file', TMessageType.CALL, self._seqid)
    args = close_file_args()
    args.file = file
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_close_file(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = close_file_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "close_file failed: unknown result");

  def online_filelocation(self, file):
    """
    Parameters:
     - file
    """
    self.send_online_filelocation(file)
    return self.recv_online_filelocation()

  def send_online_filelocation(self, file):
    self._oprot.writeMessageBegin('online_filelocation', TMessageType.CALL, self._seqid)
    args = online_filelocation_args()
    args.file = file
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_online_filelocation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = online_filelocation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "online_filelocation failed: unknown result");

  def offline_filelocation(self, sfl):
    """
    Parameters:
     - sfl
    """
    self.send_offline_filelocation(sfl)
    return self.recv_offline_filelocation()

  def send_offline_filelocation(self, sfl):
    self._oprot.writeMessageBegin('offline_filelocation', TMessageType.CALL, self._seqid)
    args = offline_filelocation_args()
    args.sfl = sfl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_offline_filelocation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = offline_filelocation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "offline_filelocation failed: unknown result");

  def set_loadstatus_bad(self, fid):
    """
    Parameters:
     - fid
    """
    self.send_set_loadstatus_bad(fid)
    return self.recv_set_loadstatus_bad()

  def send_set_loadstatus_bad(self, fid):
    self._oprot.writeMessageBegin('set_loadstatus_bad', TMessageType.CALL, self._seqid)
    args = set_loadstatus_bad_args()
    args.fid = fid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_loadstatus_bad(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = set_loadstatus_bad_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "set_loadstatus_bad failed: unknown result");

  def toggle_safemode(self, ):
    self.send_toggle_safemode()
    return self.recv_toggle_safemode()

  def send_toggle_safemode(self, ):
    self._oprot.writeMessageBegin('toggle_safemode', TMessageType.CALL, self._seqid)
    args = toggle_safemode_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_toggle_safemode(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = toggle_safemode_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "toggle_safemode failed: unknown result");

  def get_file_by_id(self, fid):
    """
    Parameters:
     - fid
    """
    self.send_get_file_by_id(fid)
    return self.recv_get_file_by_id()

  def send_get_file_by_id(self, fid):
    self._oprot.writeMessageBegin('get_file_by_id', TMessageType.CALL, self._seqid)
    args = get_file_by_id_args()
    args.fid = fid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_file_by_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_file_by_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_file_by_id failed: unknown result");

  def get_file_by_name(self, node, devid, location):
    """
    Parameters:
     - node
     - devid
     - location
    """
    self.send_get_file_by_name(node, devid, location)
    return self.recv_get_file_by_name()

  def send_get_file_by_name(self, node, devid, location):
    self._oprot.writeMessageBegin('get_file_by_name', TMessageType.CALL, self._seqid)
    args = get_file_by_name_args()
    args.node = node
    args.devid = devid
    args.location = location
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_file_by_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_file_by_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_file_by_name failed: unknown result");

  def rm_file_logical(self, file):
    """
    Parameters:
     - file
    """
    self.send_rm_file_logical(file)
    return self.recv_rm_file_logical()

  def send_rm_file_logical(self, file):
    self._oprot.writeMessageBegin('rm_file_logical', TMessageType.CALL, self._seqid)
    args = rm_file_logical_args()
    args.file = file
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rm_file_logical(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = rm_file_logical_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "rm_file_logical failed: unknown result");

  def restore_file(self, file):
    """
    Parameters:
     - file
    """
    self.send_restore_file(file)
    return self.recv_restore_file()

  def send_restore_file(self, file):
    self._oprot.writeMessageBegin('restore_file', TMessageType.CALL, self._seqid)
    args = restore_file_args()
    args.file = file
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_restore_file(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = restore_file_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "restore_file failed: unknown result");

  def rm_file_physical(self, file):
    """
    Parameters:
     - file
    """
    self.send_rm_file_physical(file)
    return self.recv_rm_file_physical()

  def send_rm_file_physical(self, file):
    self._oprot.writeMessageBegin('rm_file_physical', TMessageType.CALL, self._seqid)
    args = rm_file_physical_args()
    args.file = file
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rm_file_physical(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = rm_file_physical_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "rm_file_physical failed: unknown result");

  def get_node(self, node_name):
    """
    Parameters:
     - node_name
    """
    self.send_get_node(node_name)
    return self.recv_get_node()

  def send_get_node(self, node_name):
    self._oprot.writeMessageBegin('get_node', TMessageType.CALL, self._seqid)
    args = get_node_args()
    args.node_name = node_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_node(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_node_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_node failed: unknown result");

  def add_node(self, node_name, ipl):
    """
    Parameters:
     - node_name
     - ipl
    """
    self.send_add_node(node_name, ipl)
    return self.recv_add_node()

  def send_add_node(self, node_name, ipl):
    self._oprot.writeMessageBegin('add_node', TMessageType.CALL, self._seqid)
    args = add_node_args()
    args.node_name = node_name
    args.ipl = ipl
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_node(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_node_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_node failed: unknown result");

  def del_node(self, node_name):
    """
    Parameters:
     - node_name
    """
    self.send_del_node(node_name)
    return self.recv_del_node()

  def send_del_node(self, node_name):
    self._oprot.writeMessageBegin('del_node', TMessageType.CALL, self._seqid)
    args = del_node_args()
    args.node_name = node_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_del_node(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = del_node_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "del_node failed: unknown result");

  def create_device(self, devid, prop, node_name):
    """
    Parameters:
     - devid
     - prop
     - node_name
    """
    self.send_create_device(devid, prop, node_name)
    return self.recv_create_device()

  def send_create_device(self, devid, prop, node_name):
    self._oprot.writeMessageBegin('create_device', TMessageType.CALL, self._seqid)
    args = create_device_args()
    args.devid = devid
    args.prop = prop
    args.node_name = node_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_device(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_device_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_device failed: unknown result");

  def get_device(self, devid):
    """
    Parameters:
     - devid
    """
    self.send_get_device(devid)
    return self.recv_get_device()

  def send_get_device(self, devid):
    self._oprot.writeMessageBegin('get_device', TMessageType.CALL, self._seqid)
    args = get_device_args()
    args.devid = devid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_device(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_device_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_device failed: unknown result");

  def del_device(self, devid):
    """
    Parameters:
     - devid
    """
    self.send_del_device(devid)
    return self.recv_del_device()

  def send_del_device(self, devid):
    self._oprot.writeMessageBegin('del_device', TMessageType.CALL, self._seqid)
    args = del_device_args()
    args.devid = devid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_del_device(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = del_device_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "del_device failed: unknown result");

  def modify_device(self, dev, node):
    """
    Parameters:
     - dev
     - node
    """
    self.send_modify_device(dev, node)
    return self.recv_modify_device()

  def send_modify_device(self, dev, node):
    self._oprot.writeMessageBegin('modify_device', TMessageType.CALL, self._seqid)
    args = modify_device_args()
    args.dev = dev
    args.node = node
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_modify_device(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = modify_device_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "modify_device failed: unknown result");

  def list_device(self, ):
    self.send_list_device()
    return self.recv_list_device()

  def send_list_device(self, ):
    self._oprot.writeMessageBegin('list_device', TMessageType.CALL, self._seqid)
    args = list_device_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_device(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_device_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_device failed: unknown result");

  def alter_node(self, node_name, ipl, status):
    """
    Parameters:
     - node_name
     - ipl
     - status
    """
    self.send_alter_node(node_name, ipl, status)
    return self.recv_alter_node()

  def send_alter_node(self, node_name, ipl, status):
    self._oprot.writeMessageBegin('alter_node', TMessageType.CALL, self._seqid)
    args = alter_node_args()
    args.node_name = node_name
    args.ipl = ipl
    args.status = status
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_alter_node(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = alter_node_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "alter_node failed: unknown result");

  def find_best_nodes(self, nr):
    """
    Parameters:
     - nr
    """
    self.send_find_best_nodes(nr)
    return self.recv_find_best_nodes()

  def send_find_best_nodes(self, nr):
    self._oprot.writeMessageBegin('find_best_nodes', TMessageType.CALL, self._seqid)
    args = find_best_nodes_args()
    args.nr = nr
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_find_best_nodes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = find_best_nodes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "find_best_nodes failed: unknown result");

  def find_best_nodes_in_groups(self, dbName, tableName, nr, policy):
    """
    Parameters:
     - dbName
     - tableName
     - nr
     - policy
    """
    self.send_find_best_nodes_in_groups(dbName, tableName, nr, policy)
    return self.recv_find_best_nodes_in_groups()

  def send_find_best_nodes_in_groups(self, dbName, tableName, nr, policy):
    self._oprot.writeMessageBegin('find_best_nodes_in_groups', TMessageType.CALL, self._seqid)
    args = find_best_nodes_in_groups_args()
    args.dbName = dbName
    args.tableName = tableName
    args.nr = nr
    args.policy = policy
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_find_best_nodes_in_groups(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = find_best_nodes_in_groups_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "find_best_nodes_in_groups failed: unknown result");

  def get_all_nodes(self, ):
    self.send_get_all_nodes()
    return self.recv_get_all_nodes()

  def send_get_all_nodes(self, ):
    self._oprot.writeMessageBegin('get_all_nodes', TMessageType.CALL, self._seqid)
    args = get_all_nodes_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_all_nodes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_all_nodes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_nodes failed: unknown result");

  def getDMStatus(self, ):
    self.send_getDMStatus()
    return self.recv_getDMStatus()

  def send_getDMStatus(self, ):
    self._oprot.writeMessageBegin('getDMStatus', TMessageType.CALL, self._seqid)
    args = getDMStatus_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDMStatus(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDMStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDMStatus failed: unknown result");

  def getNodeInfo(self, ):
    self.send_getNodeInfo()
    return self.recv_getNodeInfo()

  def send_getNodeInfo(self, ):
    self._oprot.writeMessageBegin('getNodeInfo', TMessageType.CALL, self._seqid)
    args = getNodeInfo_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNodeInfo(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNodeInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNodeInfo failed: unknown result");

  def migrate_in(self, tbl, files, idxs, from_db, to_devid, fileMap):
    """
    Parameters:
     - tbl
     - files
     - idxs
     - from_db
     - to_devid
     - fileMap
    """
    self.send_migrate_in(tbl, files, idxs, from_db, to_devid, fileMap)
    return self.recv_migrate_in()

  def send_migrate_in(self, tbl, files, idxs, from_db, to_devid, fileMap):
    self._oprot.writeMessageBegin('migrate_in', TMessageType.CALL, self._seqid)
    args = migrate_in_args()
    args.tbl = tbl
    args.files = files
    args.idxs = idxs
    args.from_db = from_db
    args.to_devid = to_devid
    args.fileMap = fileMap
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_migrate_in(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = migrate_in_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "migrate_in failed: unknown result");

  def migrate_stage1(self, dbName, tableName, files, to_db):
    """
    Parameters:
     - dbName
     - tableName
     - files
     - to_db
    """
    self.send_migrate_stage1(dbName, tableName, files, to_db)
    return self.recv_migrate_stage1()

  def send_migrate_stage1(self, dbName, tableName, files, to_db):
    self._oprot.writeMessageBegin('migrate_stage1', TMessageType.CALL, self._seqid)
    args = migrate_stage1_args()
    args.dbName = dbName
    args.tableName = tableName
    args.files = files
    args.to_db = to_db
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_migrate_stage1(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = migrate_stage1_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "migrate_stage1 failed: unknown result");

  def migrate_stage2(self, dbName, tableName, files, from_db, to_db, to_devid, user, password):
    """
    Parameters:
     - dbName
     - tableName
     - files
     - from_db
     - to_db
     - to_devid
     - user
     - password
    """
    self.send_migrate_stage2(dbName, tableName, files, from_db, to_db, to_devid, user, password)
    return self.recv_migrate_stage2()

  def send_migrate_stage2(self, dbName, tableName, files, from_db, to_db, to_devid, user, password):
    self._oprot.writeMessageBegin('migrate_stage2', TMessageType.CALL, self._seqid)
    args = migrate_stage2_args()
    args.dbName = dbName
    args.tableName = tableName
    args.files = files
    args.from_db = from_db
    args.to_db = to_db
    args.to_devid = to_devid
    args.user = user
    args.password = password
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_migrate_stage2(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = migrate_stage2_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "migrate_stage2 failed: unknown result");

  def migrate2_in(self, tbl, parts, idxs, from_db, to_nas_devid, fileMap):
    """
    Parameters:
     - tbl
     - parts
     - idxs
     - from_db
     - to_nas_devid
     - fileMap
    """
    self.send_migrate2_in(tbl, parts, idxs, from_db, to_nas_devid, fileMap)
    return self.recv_migrate2_in()

  def send_migrate2_in(self, tbl, parts, idxs, from_db, to_nas_devid, fileMap):
    self._oprot.writeMessageBegin('migrate2_in', TMessageType.CALL, self._seqid)
    args = migrate2_in_args()
    args.tbl = tbl
    args.parts = parts
    args.idxs = idxs
    args.from_db = from_db
    args.to_nas_devid = to_nas_devid
    args.fileMap = fileMap
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_migrate2_in(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = migrate2_in_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "migrate2_in failed: unknown result");

  def migrate2_stage1(self, dbName, tableName, partNames, to_db):
    """
    Parameters:
     - dbName
     - tableName
     - partNames
     - to_db
    """
    self.send_migrate2_stage1(dbName, tableName, partNames, to_db)
    return self.recv_migrate2_stage1()

  def send_migrate2_stage1(self, dbName, tableName, partNames, to_db):
    self._oprot.writeMessageBegin('migrate2_stage1', TMessageType.CALL, self._seqid)
    args = migrate2_stage1_args()
    args.dbName = dbName
    args.tableName = tableName
    args.partNames = partNames
    args.to_db = to_db
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_migrate2_stage1(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = migrate2_stage1_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "migrate2_stage1 failed: unknown result");

  def migrate2_stage2(self, dbName, tableName, partNames, from_db, to_db, to_nas_devid):
    """
    Parameters:
     - dbName
     - tableName
     - partNames
     - from_db
     - to_db
     - to_nas_devid
    """
    self.send_migrate2_stage2(dbName, tableName, partNames, from_db, to_db, to_nas_devid)
    return self.recv_migrate2_stage2()

  def send_migrate2_stage2(self, dbName, tableName, partNames, from_db, to_db, to_nas_devid):
    self._oprot.writeMessageBegin('migrate2_stage2', TMessageType.CALL, self._seqid)
    args = migrate2_stage2_args()
    args.dbName = dbName
    args.tableName = tableName
    args.partNames = partNames
    args.from_db = from_db
    args.to_db = to_db
    args.to_nas_devid = to_nas_devid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_migrate2_stage2(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = migrate2_stage2_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "migrate2_stage2 failed: unknown result");

  def getMP(self, node_name, devid):
    """
    Parameters:
     - node_name
     - devid
    """
    self.send_getMP(node_name, devid)
    return self.recv_getMP()

  def send_getMP(self, node_name, devid):
    self._oprot.writeMessageBegin('getMP', TMessageType.CALL, self._seqid)
    args = getMP_args()
    args.node_name = node_name
    args.devid = devid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMP(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getMP_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMP failed: unknown result");

  def getSessionId(self, ):
    self.send_getSessionId()
    return self.recv_getSessionId()

  def send_getSessionId(self, ):
    self._oprot.writeMessageBegin('getSessionId', TMessageType.CALL, self._seqid)
    args = getSessionId_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSessionId(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSessionId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSessionId failed: unknown result");

  def createSchema(self, schema):
    """
    Parameters:
     - schema
    """
    self.send_createSchema(schema)
    return self.recv_createSchema()

  def send_createSchema(self, schema):
    self._oprot.writeMessageBegin('createSchema', TMessageType.CALL, self._seqid)
    args = createSchema_args()
    args.schema = schema
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createSchema(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createSchema_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createSchema failed: unknown result");

  def modifySchema(self, schemaName, schema):
    """
    Parameters:
     - schemaName
     - schema
    """
    self.send_modifySchema(schemaName, schema)
    return self.recv_modifySchema()

  def send_modifySchema(self, schemaName, schema):
    self._oprot.writeMessageBegin('modifySchema', TMessageType.CALL, self._seqid)
    args = modifySchema_args()
    args.schemaName = schemaName
    args.schema = schema
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_modifySchema(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = modifySchema_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "modifySchema failed: unknown result");

  def deleteSchema(self, schemaName):
    """
    Parameters:
     - schemaName
    """
    self.send_deleteSchema(schemaName)
    return self.recv_deleteSchema()

  def send_deleteSchema(self, schemaName):
    self._oprot.writeMessageBegin('deleteSchema', TMessageType.CALL, self._seqid)
    args = deleteSchema_args()
    args.schemaName = schemaName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteSchema(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteSchema_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteSchema failed: unknown result");

  def listSchemas(self, ):
    self.send_listSchemas()
    return self.recv_listSchemas()

  def send_listSchemas(self, ):
    self._oprot.writeMessageBegin('listSchemas', TMessageType.CALL, self._seqid)
    args = listSchemas_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSchemas(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listSchemas_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSchemas failed: unknown result");

  def getSchemaByName(self, schemaName):
    """
    Parameters:
     - schemaName
    """
    self.send_getSchemaByName(schemaName)
    return self.recv_getSchemaByName()

  def send_getSchemaByName(self, schemaName):
    self._oprot.writeMessageBegin('getSchemaByName', TMessageType.CALL, self._seqid)
    args = getSchemaByName_args()
    args.schemaName = schemaName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSchemaByName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSchemaByName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSchemaByName failed: unknown result");

  def getTableNodeGroups(self, dbName, tabName):
    """
    Parameters:
     - dbName
     - tabName
    """
    self.send_getTableNodeGroups(dbName, tabName)
    return self.recv_getTableNodeGroups()

  def send_getTableNodeGroups(self, dbName, tabName):
    self._oprot.writeMessageBegin('getTableNodeGroups', TMessageType.CALL, self._seqid)
    args = getTableNodeGroups_args()
    args.dbName = dbName
    args.tabName = tabName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTableNodeGroups(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTableNodeGroups_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTableNodeGroups failed: unknown result");

  def getTableNodeFiles(self, dbName, tabName, nodeName):
    """
    Parameters:
     - dbName
     - tabName
     - nodeName
    """
    self.send_getTableNodeFiles(dbName, tabName, nodeName)
    return self.recv_getTableNodeFiles()

  def send_getTableNodeFiles(self, dbName, tabName, nodeName):
    self._oprot.writeMessageBegin('getTableNodeFiles', TMessageType.CALL, self._seqid)
    args = getTableNodeFiles_args()
    args.dbName = dbName
    args.tabName = tabName
    args.nodeName = nodeName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTableNodeFiles(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTableNodeFiles_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTableNodeFiles failed: unknown result");

  def listTableFiles(self, dbName, tabName, from, to):
    """
    Parameters:
     - dbName
     - tabName
     - from
     - to
    """
    self.send_listTableFiles(dbName, tabName, from, to)
    return self.recv_listTableFiles()

  def send_listTableFiles(self, dbName, tabName, from, to):
    self._oprot.writeMessageBegin('listTableFiles', TMessageType.CALL, self._seqid)
    args = listTableFiles_args()
    args.dbName = dbName
    args.tabName = tabName
    args.from = from
    args.to = to
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listTableFiles(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listTableFiles_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listTableFiles failed: unknown result");

  def listFilesByDigest(self, digest):
    """
    Parameters:
     - digest
    """
    self.send_listFilesByDigest(digest)
    return self.recv_listFilesByDigest()

  def send_listFilesByDigest(self, digest):
    self._oprot.writeMessageBegin('listFilesByDigest', TMessageType.CALL, self._seqid)
    args = listFilesByDigest_args()
    args.digest = digest
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listFilesByDigest(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listFilesByDigest_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listFilesByDigest failed: unknown result");

  def filterTableFiles(self, dbName, tabName, values):
    """
    Parameters:
     - dbName
     - tabName
     - values
    """
    self.send_filterTableFiles(dbName, tabName, values)
    return self.recv_filterTableFiles()

  def send_filterTableFiles(self, dbName, tabName, values):
    self._oprot.writeMessageBegin('filterTableFiles', TMessageType.CALL, self._seqid)
    args = filterTableFiles_args()
    args.dbName = dbName
    args.tabName = tabName
    args.values = values
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_filterTableFiles(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = filterTableFiles_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "filterTableFiles failed: unknown result");

  def truncTableFiles(self, dbName, tabName):
    """
    Parameters:
     - dbName
     - tabName
    """
    self.send_truncTableFiles(dbName, tabName)
    self.recv_truncTableFiles()

  def send_truncTableFiles(self, dbName, tabName):
    self._oprot.writeMessageBegin('truncTableFiles', TMessageType.CALL, self._seqid)
    args = truncTableFiles_args()
    args.dbName = dbName
    args.tabName = tabName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_truncTableFiles(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = truncTableFiles_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.o1 is not None:
      raise result.o1
    return

  def addNodeGroup(self, ng):
    """
    Parameters:
     - ng
    """
    self.send_addNodeGroup(ng)
    return self.recv_addNodeGroup()

  def send_addNodeGroup(self, ng):
    self._oprot.writeMessageBegin('addNodeGroup', TMessageType.CALL, self._seqid)
    args = addNodeGroup_args()
    args.ng = ng
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addNodeGroup(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addNodeGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addNodeGroup failed: unknown result");

  def modifyNodeGroup(self, schemaName, ng):
    """
    Parameters:
     - schemaName
     - ng
    """
    self.send_modifyNodeGroup(schemaName, ng)
    return self.recv_modifyNodeGroup()

  def send_modifyNodeGroup(self, schemaName, ng):
    self._oprot.writeMessageBegin('modifyNodeGroup', TMessageType.CALL, self._seqid)
    args = modifyNodeGroup_args()
    args.schemaName = schemaName
    args.ng = ng
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_modifyNodeGroup(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = modifyNodeGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "modifyNodeGroup failed: unknown result");

  def deleteNodeGroup(self, ng):
    """
    Parameters:
     - ng
    """
    self.send_deleteNodeGroup(ng)
    return self.recv_deleteNodeGroup()

  def send_deleteNodeGroup(self, ng):
    self._oprot.writeMessageBegin('deleteNodeGroup', TMessageType.CALL, self._seqid)
    args = deleteNodeGroup_args()
    args.ng = ng
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteNodeGroup(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteNodeGroup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteNodeGroup failed: unknown result");

  def listNodeGroups(self, ):
    self.send_listNodeGroups()
    return self.recv_listNodeGroups()

  def send_listNodeGroups(self, ):
    self._oprot.writeMessageBegin('listNodeGroups', TMessageType.CALL, self._seqid)
    args = listNodeGroups_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listNodeGroups(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listNodeGroups_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listNodeGroups failed: unknown result");

  def listDBNodeGroups(self, dbName):
    """
    Parameters:
     - dbName
    """
    self.send_listDBNodeGroups(dbName)
    return self.recv_listDBNodeGroups()

  def send_listDBNodeGroups(self, dbName):
    self._oprot.writeMessageBegin('listDBNodeGroups', TMessageType.CALL, self._seqid)
    args = listDBNodeGroups_args()
    args.dbName = dbName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listDBNodeGroups(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listDBNodeGroups_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listDBNodeGroups failed: unknown result");

  def listNodeGroupByNames(self, ngNames):
    """
    Parameters:
     - ngNames
    """
    self.send_listNodeGroupByNames(ngNames)
    return self.recv_listNodeGroupByNames()

  def send_listNodeGroupByNames(self, ngNames):
    self._oprot.writeMessageBegin('listNodeGroupByNames', TMessageType.CALL, self._seqid)
    args = listNodeGroupByNames_args()
    args.ngNames = ngNames
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listNodeGroupByNames(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listNodeGroupByNames_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listNodeGroupByNames failed: unknown result");

  def addTableNodeDist(self, db, tab, ng):
    """
    Parameters:
     - db
     - tab
     - ng
    """
    self.send_addTableNodeDist(db, tab, ng)
    return self.recv_addTableNodeDist()

  def send_addTableNodeDist(self, db, tab, ng):
    self._oprot.writeMessageBegin('addTableNodeDist', TMessageType.CALL, self._seqid)
    args = addTableNodeDist_args()
    args.db = db
    args.tab = tab
    args.ng = ng
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addTableNodeDist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addTableNodeDist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addTableNodeDist failed: unknown result");

  def deleteTableNodeDist(self, db, tab, ng):
    """
    Parameters:
     - db
     - tab
     - ng
    """
    self.send_deleteTableNodeDist(db, tab, ng)
    return self.recv_deleteTableNodeDist()

  def send_deleteTableNodeDist(self, db, tab, ng):
    self._oprot.writeMessageBegin('deleteTableNodeDist', TMessageType.CALL, self._seqid)
    args = deleteTableNodeDist_args()
    args.db = db
    args.tab = tab
    args.ng = ng
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteTableNodeDist(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteTableNodeDist_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteTableNodeDist failed: unknown result");

  def listTableNodeDists(self, dbName, tabName):
    """
    Parameters:
     - dbName
     - tabName
    """
    self.send_listTableNodeDists(dbName, tabName)
    return self.recv_listTableNodeDists()

  def send_listTableNodeDists(self, dbName, tabName):
    self._oprot.writeMessageBegin('listTableNodeDists', TMessageType.CALL, self._seqid)
    args = listTableNodeDists_args()
    args.dbName = dbName
    args.tabName = tabName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listTableNodeDists(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listTableNodeDists_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listTableNodeDists failed: unknown result");

  def assiginSchematoDB(self, dbName, schemaName, fileSplitKeys, part_keys, ngs):
    """
    Parameters:
     - dbName
     - schemaName
     - fileSplitKeys
     - part_keys
     - ngs
    """
    self.send_assiginSchematoDB(dbName, schemaName, fileSplitKeys, part_keys, ngs)
    return self.recv_assiginSchematoDB()

  def send_assiginSchematoDB(self, dbName, schemaName, fileSplitKeys, part_keys, ngs):
    self._oprot.writeMessageBegin('assiginSchematoDB', TMessageType.CALL, self._seqid)
    args = assiginSchematoDB_args()
    args.dbName = dbName
    args.schemaName = schemaName
    args.fileSplitKeys = fileSplitKeys
    args.part_keys = part_keys
    args.ngs = ngs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_assiginSchematoDB(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = assiginSchematoDB_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    if result.o2 is not None:
      raise result.o2
    if result.o3 is not None:
      raise result.o3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "assiginSchematoDB failed: unknown result");

  def statFileSystem(self, begin_time, end_time):
    """
    Parameters:
     - begin_time
     - end_time
    """
    self.send_statFileSystem(begin_time, end_time)
    return self.recv_statFileSystem()

  def send_statFileSystem(self, begin_time, end_time):
    self._oprot.writeMessageBegin('statFileSystem', TMessageType.CALL, self._seqid)
    args = statFileSystem_args()
    args.begin_time = begin_time
    args.end_time = end_time
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_statFileSystem(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = statFileSystem_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "statFileSystem failed: unknown result");

  def getMaxFid(self, ):
    self.send_getMaxFid()
    return self.recv_getMaxFid()

  def send_getMaxFid(self, ):
    self._oprot.writeMessageBegin('getMaxFid', TMessageType.CALL, self._seqid)
    args = getMaxFid_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMaxFid(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getMaxFid_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.o1 is not None:
      raise result.o1
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMaxFid failed: unknown result");


class Processor(fb303.FacebookService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    fb303.FacebookService.Processor.__init__(self, handler)
    self._processMap["create_attribution"] = Processor.process_create_attribution
    self._processMap["get_attribution"] = Processor.process_get_attribution
    self._processMap["drop_attribution"] = Processor.process_drop_attribution
    self._processMap["update_attribution"] = Processor.process_update_attribution
    self._processMap["get_all_attributions"] = Processor.process_get_all_attributions
    self._processMap["get_local_attribution"] = Processor.process_get_local_attribution
    self._processMap["get_lucene_index_names"] = Processor.process_get_lucene_index_names
    self._processMap["get_all_busi_type_cols"] = Processor.process_get_all_busi_type_cols
    self._processMap["get_all_busi_type_datacenters"] = Processor.process_get_all_busi_type_datacenters
    self._processMap["append_busi_type_datacenter"] = Processor.process_append_busi_type_datacenter
    self._processMap["add_datawarehouse_sql"] = Processor.process_add_datawarehouse_sql
    self._processMap["showBusitypes"] = Processor.process_showBusitypes
    self._processMap["createBusitype"] = Processor.process_createBusitype
    self._processMap["add_partition_files"] = Processor.process_add_partition_files
    self._processMap["drop_partition_files"] = Processor.process_drop_partition_files
    self._processMap["add_subpartition_files"] = Processor.process_add_subpartition_files
    self._processMap["drop_subpartition_files"] = Processor.process_drop_subpartition_files
    self._processMap["add_partition_index"] = Processor.process_add_partition_index
    self._processMap["drop_partition_index"] = Processor.process_drop_partition_index
    self._processMap["add_subpartition_index"] = Processor.process_add_subpartition_index
    self._processMap["drop_subpartition_index"] = Processor.process_drop_subpartition_index
    self._processMap["add_subpartition"] = Processor.process_add_subpartition
    self._processMap["get_subpartitions"] = Processor.process_get_subpartitions
    self._processMap["add_partition_index_files"] = Processor.process_add_partition_index_files
    self._processMap["get_partition_index_files"] = Processor.process_get_partition_index_files
    self._processMap["drop_partition_index_files"] = Processor.process_drop_partition_index_files
    self._processMap["add_subpartition_index_files"] = Processor.process_add_subpartition_index_files
    self._processMap["get_subpartition_index_files"] = Processor.process_get_subpartition_index_files
    self._processMap["drop_subpartition_index_files"] = Processor.process_drop_subpartition_index_files
    self._processMap["addGeoLocation"] = Processor.process_addGeoLocation
    self._processMap["modifyGeoLocation"] = Processor.process_modifyGeoLocation
    self._processMap["deleteGeoLocation"] = Processor.process_deleteGeoLocation
    self._processMap["listGeoLocation"] = Processor.process_listGeoLocation
    self._processMap["addEquipRoom"] = Processor.process_addEquipRoom
    self._processMap["modifyEquipRoom"] = Processor.process_modifyEquipRoom
    self._processMap["deleteEquipRoom"] = Processor.process_deleteEquipRoom
    self._processMap["listEquipRoom"] = Processor.process_listEquipRoom
    self._processMap["getGeoLocationByName"] = Processor.process_getGeoLocationByName
    self._processMap["getGeoLocationByNames"] = Processor.process_getGeoLocationByNames
    self._processMap["addNodeAssignment"] = Processor.process_addNodeAssignment
    self._processMap["deleteNodeAssignment"] = Processor.process_deleteNodeAssignment
    self._processMap["listNodes"] = Processor.process_listNodes
    self._processMap["addUserAssignment"] = Processor.process_addUserAssignment
    self._processMap["deleteUserAssignment"] = Processor.process_deleteUserAssignment
    self._processMap["listUsers"] = Processor.process_listUsers
    self._processMap["addRoleAssignment"] = Processor.process_addRoleAssignment
    self._processMap["deleteRoleAssignment"] = Processor.process_deleteRoleAssignment
    self._processMap["listRoles"] = Processor.process_listRoles
    self._processMap["addNodeGroupAssignment"] = Processor.process_addNodeGroupAssignment
    self._processMap["deleteNodeGroupAssignment"] = Processor.process_deleteNodeGroupAssignment
    self._processMap["pingPong"] = Processor.process_pingPong
    self._processMap["alterNodeGroup"] = Processor.process_alterNodeGroup
    self._processMap["create_database"] = Processor.process_create_database
    self._processMap["get_database"] = Processor.process_get_database
    self._processMap["drop_database"] = Processor.process_drop_database
    self._processMap["get_databases"] = Processor.process_get_databases
    self._processMap["get_all_databases"] = Processor.process_get_all_databases
    self._processMap["alter_database"] = Processor.process_alter_database
    self._processMap["get_type"] = Processor.process_get_type
    self._processMap["create_type"] = Processor.process_create_type
    self._processMap["drop_type"] = Processor.process_drop_type
    self._processMap["get_type_all"] = Processor.process_get_type_all
    self._processMap["get_fields"] = Processor.process_get_fields
    self._processMap["get_schema"] = Processor.process_get_schema
    self._processMap["create_table"] = Processor.process_create_table
    self._processMap["create_table_by_user"] = Processor.process_create_table_by_user
    self._processMap["create_table_with_environment_context"] = Processor.process_create_table_with_environment_context
    self._processMap["drop_table"] = Processor.process_drop_table
    self._processMap["get_tables"] = Processor.process_get_tables
    self._processMap["get_all_tables"] = Processor.process_get_all_tables
    self._processMap["get_table"] = Processor.process_get_table
    self._processMap["get_table_objects_by_name"] = Processor.process_get_table_objects_by_name
    self._processMap["get_table_names_by_filter"] = Processor.process_get_table_names_by_filter
    self._processMap["alter_table"] = Processor.process_alter_table
    self._processMap["alter_table_with_environment_context"] = Processor.process_alter_table_with_environment_context
    self._processMap["add_partition"] = Processor.process_add_partition
    self._processMap["add_partition_with_environment_context"] = Processor.process_add_partition_with_environment_context
    self._processMap["add_partitions"] = Processor.process_add_partitions
    self._processMap["append_partition"] = Processor.process_append_partition
    self._processMap["append_partition_by_name"] = Processor.process_append_partition_by_name
    self._processMap["drop_partition"] = Processor.process_drop_partition
    self._processMap["drop_partition_by_name"] = Processor.process_drop_partition_by_name
    self._processMap["get_partition"] = Processor.process_get_partition
    self._processMap["get_partition_with_auth"] = Processor.process_get_partition_with_auth
    self._processMap["get_partition_by_name"] = Processor.process_get_partition_by_name
    self._processMap["get_partitions"] = Processor.process_get_partitions
    self._processMap["get_partitions_with_auth"] = Processor.process_get_partitions_with_auth
    self._processMap["get_partition_names"] = Processor.process_get_partition_names
    self._processMap["get_partitions_ps"] = Processor.process_get_partitions_ps
    self._processMap["get_partitions_ps_with_auth"] = Processor.process_get_partitions_ps_with_auth
    self._processMap["get_partition_names_ps"] = Processor.process_get_partition_names_ps
    self._processMap["get_partitions_by_filter"] = Processor.process_get_partitions_by_filter
    self._processMap["get_partitions_by_names"] = Processor.process_get_partitions_by_names
    self._processMap["alter_partition"] = Processor.process_alter_partition
    self._processMap["alter_partitions"] = Processor.process_alter_partitions
    self._processMap["alter_partition_with_environment_context"] = Processor.process_alter_partition_with_environment_context
    self._processMap["rename_partition"] = Processor.process_rename_partition
    self._processMap["get_config_value"] = Processor.process_get_config_value
    self._processMap["partition_name_to_vals"] = Processor.process_partition_name_to_vals
    self._processMap["partition_name_to_spec"] = Processor.process_partition_name_to_spec
    self._processMap["markPartitionForEvent"] = Processor.process_markPartitionForEvent
    self._processMap["isPartitionMarkedForEvent"] = Processor.process_isPartitionMarkedForEvent
    self._processMap["add_index"] = Processor.process_add_index
    self._processMap["alter_index"] = Processor.process_alter_index
    self._processMap["drop_index_by_name"] = Processor.process_drop_index_by_name
    self._processMap["get_index_by_name"] = Processor.process_get_index_by_name
    self._processMap["get_indexes"] = Processor.process_get_indexes
    self._processMap["get_index_names"] = Processor.process_get_index_names
    self._processMap["update_table_column_statistics"] = Processor.process_update_table_column_statistics
    self._processMap["update_partition_column_statistics"] = Processor.process_update_partition_column_statistics
    self._processMap["get_table_column_statistics"] = Processor.process_get_table_column_statistics
    self._processMap["get_partition_column_statistics"] = Processor.process_get_partition_column_statistics
    self._processMap["delete_partition_column_statistics"] = Processor.process_delete_partition_column_statistics
    self._processMap["delete_table_column_statistics"] = Processor.process_delete_table_column_statistics
    self._processMap["create_user"] = Processor.process_create_user
    self._processMap["drop_user"] = Processor.process_drop_user
    self._processMap["modify_user"] = Processor.process_modify_user
    self._processMap["list_users_names"] = Processor.process_list_users_names
    self._processMap["list_users"] = Processor.process_list_users
    self._processMap["authentication"] = Processor.process_authentication
    self._processMap["user_authority_check"] = Processor.process_user_authority_check
    self._processMap["create_role"] = Processor.process_create_role
    self._processMap["drop_role"] = Processor.process_drop_role
    self._processMap["get_role_names"] = Processor.process_get_role_names
    self._processMap["grant_role"] = Processor.process_grant_role
    self._processMap["revoke_role"] = Processor.process_revoke_role
    self._processMap["list_roles"] = Processor.process_list_roles
    self._processMap["get_privilege_set"] = Processor.process_get_privilege_set
    self._processMap["list_privileges"] = Processor.process_list_privileges
    self._processMap["grant_privileges"] = Processor.process_grant_privileges
    self._processMap["revoke_privileges"] = Processor.process_revoke_privileges
    self._processMap["set_ugi"] = Processor.process_set_ugi
    self._processMap["get_delegation_token"] = Processor.process_get_delegation_token
    self._processMap["renew_delegation_token"] = Processor.process_renew_delegation_token
    self._processMap["cancel_delegation_token"] = Processor.process_cancel_delegation_token
    self._processMap["create_file"] = Processor.process_create_file
    self._processMap["create_file_by_policy"] = Processor.process_create_file_by_policy
    self._processMap["set_file_repnr"] = Processor.process_set_file_repnr
    self._processMap["reopen_file"] = Processor.process_reopen_file
    self._processMap["close_file"] = Processor.process_close_file
    self._processMap["online_filelocation"] = Processor.process_online_filelocation
    self._processMap["offline_filelocation"] = Processor.process_offline_filelocation
    self._processMap["set_loadstatus_bad"] = Processor.process_set_loadstatus_bad
    self._processMap["toggle_safemode"] = Processor.process_toggle_safemode
    self._processMap["get_file_by_id"] = Processor.process_get_file_by_id
    self._processMap["get_file_by_name"] = Processor.process_get_file_by_name
    self._processMap["rm_file_logical"] = Processor.process_rm_file_logical
    self._processMap["restore_file"] = Processor.process_restore_file
    self._processMap["rm_file_physical"] = Processor.process_rm_file_physical
    self._processMap["get_node"] = Processor.process_get_node
    self._processMap["add_node"] = Processor.process_add_node
    self._processMap["del_node"] = Processor.process_del_node
    self._processMap["create_device"] = Processor.process_create_device
    self._processMap["get_device"] = Processor.process_get_device
    self._processMap["del_device"] = Processor.process_del_device
    self._processMap["modify_device"] = Processor.process_modify_device
    self._processMap["list_device"] = Processor.process_list_device
    self._processMap["alter_node"] = Processor.process_alter_node
    self._processMap["find_best_nodes"] = Processor.process_find_best_nodes
    self._processMap["find_best_nodes_in_groups"] = Processor.process_find_best_nodes_in_groups
    self._processMap["get_all_nodes"] = Processor.process_get_all_nodes
    self._processMap["getDMStatus"] = Processor.process_getDMStatus
    self._processMap["getNodeInfo"] = Processor.process_getNodeInfo
    self._processMap["migrate_in"] = Processor.process_migrate_in
    self._processMap["migrate_stage1"] = Processor.process_migrate_stage1
    self._processMap["migrate_stage2"] = Processor.process_migrate_stage2
    self._processMap["migrate2_in"] = Processor.process_migrate2_in
    self._processMap["migrate2_stage1"] = Processor.process_migrate2_stage1
    self._processMap["migrate2_stage2"] = Processor.process_migrate2_stage2
    self._processMap["getMP"] = Processor.process_getMP
    self._processMap["getSessionId"] = Processor.process_getSessionId
    self._processMap["createSchema"] = Processor.process_createSchema
    self._processMap["modifySchema"] = Processor.process_modifySchema
    self._processMap["deleteSchema"] = Processor.process_deleteSchema
    self._processMap["listSchemas"] = Processor.process_listSchemas
    self._processMap["getSchemaByName"] = Processor.process_getSchemaByName
    self._processMap["getTableNodeGroups"] = Processor.process_getTableNodeGroups
    self._processMap["getTableNodeFiles"] = Processor.process_getTableNodeFiles
    self._processMap["listTableFiles"] = Processor.process_listTableFiles
    self._processMap["listFilesByDigest"] = Processor.process_listFilesByDigest
    self._processMap["filterTableFiles"] = Processor.process_filterTableFiles
    self._processMap["truncTableFiles"] = Processor.process_truncTableFiles
    self._processMap["addNodeGroup"] = Processor.process_addNodeGroup
    self._processMap["modifyNodeGroup"] = Processor.process_modifyNodeGroup
    self._processMap["deleteNodeGroup"] = Processor.process_deleteNodeGroup
    self._processMap["listNodeGroups"] = Processor.process_listNodeGroups
    self._processMap["listDBNodeGroups"] = Processor.process_listDBNodeGroups
    self._processMap["listNodeGroupByNames"] = Processor.process_listNodeGroupByNames
    self._processMap["addTableNodeDist"] = Processor.process_addTableNodeDist
    self._processMap["deleteTableNodeDist"] = Processor.process_deleteTableNodeDist
    self._processMap["listTableNodeDists"] = Processor.process_listTableNodeDists
    self._processMap["assiginSchematoDB"] = Processor.process_assiginSchematoDB
    self._processMap["statFileSystem"] = Processor.process_statFileSystem
    self._processMap["getMaxFid"] = Processor.process_getMaxFid

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_create_attribution(self, seqid, iprot, oprot):
    args = create_attribution_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_attribution_result()
    try:
      self._handler.create_attribution(args.db)
    except AlreadyExistsException as o1:
      result.o1 = o1
    except InvalidObjectException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("create_attribution", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_attribution(self, seqid, iprot, oprot):
    args = get_attribution_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_attribution_result()
    try:
      result.success = self._handler.get_attribution(args.name)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_attribution", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_attribution(self, seqid, iprot, oprot):
    args = drop_attribution_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_attribution_result()
    try:
      self._handler.drop_attribution(args.name, args.deleteData, args.cascade)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except InvalidOperationException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("drop_attribution", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_attribution(self, seqid, iprot, oprot):
    args = update_attribution_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_attribution_result()
    try:
      self._handler.update_attribution(args.db)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except InvalidOperationException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("update_attribution", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_attributions(self, seqid, iprot, oprot):
    args = get_all_attributions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_attributions_result()
    try:
      result.success = self._handler.get_all_attributions()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_all_attributions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_local_attribution(self, seqid, iprot, oprot):
    args = get_local_attribution_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_local_attribution_result()
    try:
      result.success = self._handler.get_local_attribution()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_local_attribution", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_lucene_index_names(self, seqid, iprot, oprot):
    args = get_lucene_index_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_lucene_index_names_result()
    try:
      result.success = self._handler.get_lucene_index_names(args.db_name, args.tbl_name, args.max_indexes)
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_lucene_index_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_busi_type_cols(self, seqid, iprot, oprot):
    args = get_all_busi_type_cols_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_busi_type_cols_result()
    try:
      result.success = self._handler.get_all_busi_type_cols()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_all_busi_type_cols", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_busi_type_datacenters(self, seqid, iprot, oprot):
    args = get_all_busi_type_datacenters_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_busi_type_datacenters_result()
    try:
      result.success = self._handler.get_all_busi_type_datacenters()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_all_busi_type_datacenters", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_busi_type_datacenter(self, seqid, iprot, oprot):
    args = append_busi_type_datacenter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_busi_type_datacenter_result()
    try:
      self._handler.append_busi_type_datacenter(args.busiTypeDatacenter)
    except InvalidObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("append_busi_type_datacenter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_datawarehouse_sql(self, seqid, iprot, oprot):
    args = add_datawarehouse_sql_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_datawarehouse_sql_result()
    try:
      result.success = self._handler.add_datawarehouse_sql(args.dwNum, args.sql)
    except InvalidObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("add_datawarehouse_sql", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_showBusitypes(self, seqid, iprot, oprot):
    args = showBusitypes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = showBusitypes_result()
    try:
      result.success = self._handler.showBusitypes()
    except InvalidObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("showBusitypes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createBusitype(self, seqid, iprot, oprot):
    args = createBusitype_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createBusitype_result()
    try:
      result.success = self._handler.createBusitype(args.busitype)
    except InvalidObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("createBusitype", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition_files(self, seqid, iprot, oprot):
    args = add_partition_files_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_files_result()
    result.success = self._handler.add_partition_files(args.part, args.files)
    oprot.writeMessageBegin("add_partition_files", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_files(self, seqid, iprot, oprot):
    args = drop_partition_files_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_files_result()
    result.success = self._handler.drop_partition_files(args.part, args.files)
    oprot.writeMessageBegin("drop_partition_files", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_subpartition_files(self, seqid, iprot, oprot):
    args = add_subpartition_files_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_subpartition_files_result()
    result.success = self._handler.add_subpartition_files(args.subpart, args.files)
    oprot.writeMessageBegin("add_subpartition_files", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_subpartition_files(self, seqid, iprot, oprot):
    args = drop_subpartition_files_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_subpartition_files_result()
    result.success = self._handler.drop_subpartition_files(args.subpart, args.files)
    oprot.writeMessageBegin("drop_subpartition_files", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition_index(self, seqid, iprot, oprot):
    args = add_partition_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_index_result()
    try:
      result.success = self._handler.add_partition_index(args.index, args.part)
    except MetaException as o1:
      result.o1 = o1
    except AlreadyExistsException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("add_partition_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_index(self, seqid, iprot, oprot):
    args = drop_partition_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_index_result()
    try:
      result.success = self._handler.drop_partition_index(args.index, args.part)
    except MetaException as o1:
      result.o1 = o1
    except AlreadyExistsException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_partition_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_subpartition_index(self, seqid, iprot, oprot):
    args = add_subpartition_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_subpartition_index_result()
    try:
      result.success = self._handler.add_subpartition_index(args.index, args.part)
    except MetaException as o1:
      result.o1 = o1
    except AlreadyExistsException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("add_subpartition_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_subpartition_index(self, seqid, iprot, oprot):
    args = drop_subpartition_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_subpartition_index_result()
    try:
      result.success = self._handler.drop_subpartition_index(args.index, args.part)
    except MetaException as o1:
      result.o1 = o1
    except AlreadyExistsException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_subpartition_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_subpartition(self, seqid, iprot, oprot):
    args = add_subpartition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_subpartition_result()
    result.success = self._handler.add_subpartition(args.dbname, args.tbl_name, args.part_vals, args.sub_part)
    oprot.writeMessageBegin("add_subpartition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_subpartitions(self, seqid, iprot, oprot):
    args = get_subpartitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_subpartitions_result()
    result.success = self._handler.get_subpartitions(args.dbname, args.tbl_name, args.part)
    oprot.writeMessageBegin("get_subpartitions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition_index_files(self, seqid, iprot, oprot):
    args = add_partition_index_files_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_index_files_result()
    try:
      result.success = self._handler.add_partition_index_files(args.index, args.part, args.file, args.originfid)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("add_partition_index_files", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_index_files(self, seqid, iprot, oprot):
    args = get_partition_index_files_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_index_files_result()
    try:
      result.success = self._handler.get_partition_index_files(args.index, args.part)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_partition_index_files", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_index_files(self, seqid, iprot, oprot):
    args = drop_partition_index_files_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_index_files_result()
    try:
      result.success = self._handler.drop_partition_index_files(args.index, args.part, args.file)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("drop_partition_index_files", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_subpartition_index_files(self, seqid, iprot, oprot):
    args = add_subpartition_index_files_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_subpartition_index_files_result()
    try:
      result.success = self._handler.add_subpartition_index_files(args.index, args.subpart, args.file, args.originfid)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("add_subpartition_index_files", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_subpartition_index_files(self, seqid, iprot, oprot):
    args = get_subpartition_index_files_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_subpartition_index_files_result()
    try:
      result.success = self._handler.get_subpartition_index_files(args.index, args.subpart)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_subpartition_index_files", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_subpartition_index_files(self, seqid, iprot, oprot):
    args = drop_subpartition_index_files_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_subpartition_index_files_result()
    try:
      result.success = self._handler.drop_subpartition_index_files(args.index, args.subpart, args.file)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("drop_subpartition_index_files", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addGeoLocation(self, seqid, iprot, oprot):
    args = addGeoLocation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addGeoLocation_result()
    try:
      result.success = self._handler.addGeoLocation(args.gl)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("addGeoLocation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_modifyGeoLocation(self, seqid, iprot, oprot):
    args = modifyGeoLocation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = modifyGeoLocation_result()
    try:
      result.success = self._handler.modifyGeoLocation(args.gl)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("modifyGeoLocation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteGeoLocation(self, seqid, iprot, oprot):
    args = deleteGeoLocation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteGeoLocation_result()
    try:
      result.success = self._handler.deleteGeoLocation(args.gl)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("deleteGeoLocation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listGeoLocation(self, seqid, iprot, oprot):
    args = listGeoLocation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listGeoLocation_result()
    try:
      result.success = self._handler.listGeoLocation()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listGeoLocation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addEquipRoom(self, seqid, iprot, oprot):
    args = addEquipRoom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addEquipRoom_result()
    try:
      result.success = self._handler.addEquipRoom(args.er)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("addEquipRoom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_modifyEquipRoom(self, seqid, iprot, oprot):
    args = modifyEquipRoom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = modifyEquipRoom_result()
    try:
      result.success = self._handler.modifyEquipRoom(args.er)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("modifyEquipRoom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteEquipRoom(self, seqid, iprot, oprot):
    args = deleteEquipRoom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteEquipRoom_result()
    try:
      result.success = self._handler.deleteEquipRoom(args.er)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("deleteEquipRoom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listEquipRoom(self, seqid, iprot, oprot):
    args = listEquipRoom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listEquipRoom_result()
    try:
      result.success = self._handler.listEquipRoom()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listEquipRoom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGeoLocationByName(self, seqid, iprot, oprot):
    args = getGeoLocationByName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGeoLocationByName_result()
    try:
      result.success = self._handler.getGeoLocationByName(args.geoLocName)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("getGeoLocationByName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGeoLocationByNames(self, seqid, iprot, oprot):
    args = getGeoLocationByNames_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGeoLocationByNames_result()
    try:
      result.success = self._handler.getGeoLocationByNames(args.geoLocNames)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("getGeoLocationByNames", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addNodeAssignment(self, seqid, iprot, oprot):
    args = addNodeAssignment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addNodeAssignment_result()
    try:
      result.success = self._handler.addNodeAssignment(args.nodeName, args.dbName)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("addNodeAssignment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteNodeAssignment(self, seqid, iprot, oprot):
    args = deleteNodeAssignment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteNodeAssignment_result()
    try:
      result.success = self._handler.deleteNodeAssignment(args.nodeName, args.dbName)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("deleteNodeAssignment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listNodes(self, seqid, iprot, oprot):
    args = listNodes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listNodes_result()
    try:
      result.success = self._handler.listNodes()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listNodes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addUserAssignment(self, seqid, iprot, oprot):
    args = addUserAssignment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addUserAssignment_result()
    try:
      result.success = self._handler.addUserAssignment(args.roleName, args.dbName)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("addUserAssignment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteUserAssignment(self, seqid, iprot, oprot):
    args = deleteUserAssignment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteUserAssignment_result()
    try:
      result.success = self._handler.deleteUserAssignment(args.roleName, args.dbName)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("deleteUserAssignment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listUsers(self, seqid, iprot, oprot):
    args = listUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listUsers_result()
    try:
      result.success = self._handler.listUsers()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listUsers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addRoleAssignment(self, seqid, iprot, oprot):
    args = addRoleAssignment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addRoleAssignment_result()
    try:
      result.success = self._handler.addRoleAssignment(args.userName, args.dbName)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("addRoleAssignment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteRoleAssignment(self, seqid, iprot, oprot):
    args = deleteRoleAssignment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteRoleAssignment_result()
    try:
      result.success = self._handler.deleteRoleAssignment(args.userName, args.dbName)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("deleteRoleAssignment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listRoles(self, seqid, iprot, oprot):
    args = listRoles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listRoles_result()
    try:
      result.success = self._handler.listRoles()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listRoles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addNodeGroupAssignment(self, seqid, iprot, oprot):
    args = addNodeGroupAssignment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addNodeGroupAssignment_result()
    try:
      result.success = self._handler.addNodeGroupAssignment(args.ng, args.dbName)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("addNodeGroupAssignment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteNodeGroupAssignment(self, seqid, iprot, oprot):
    args = deleteNodeGroupAssignment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteNodeGroupAssignment_result()
    try:
      result.success = self._handler.deleteNodeGroupAssignment(args.ng, args.dbName)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("deleteNodeGroupAssignment", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pingPong(self, seqid, iprot, oprot):
    args = pingPong_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pingPong_result()
    try:
      result.success = self._handler.pingPong(args.str)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("pingPong", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alterNodeGroup(self, seqid, iprot, oprot):
    args = alterNodeGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alterNodeGroup_result()
    try:
      result.success = self._handler.alterNodeGroup(args.ng)
    except AlreadyExistsException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("alterNodeGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_database(self, seqid, iprot, oprot):
    args = create_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_database_result()
    try:
      self._handler.create_database(args.database)
    except AlreadyExistsException as o1:
      result.o1 = o1
    except InvalidObjectException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("create_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_database(self, seqid, iprot, oprot):
    args = get_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_database_result()
    try:
      result.success = self._handler.get_database(args.name)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_database(self, seqid, iprot, oprot):
    args = drop_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_database_result()
    try:
      self._handler.drop_database(args.name, args.deleteData, args.cascade)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except InvalidOperationException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("drop_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_databases(self, seqid, iprot, oprot):
    args = get_databases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_databases_result()
    try:
      result.success = self._handler.get_databases(args.pattern)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_databases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_databases(self, seqid, iprot, oprot):
    args = get_all_databases_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_databases_result()
    try:
      result.success = self._handler.get_all_databases()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_all_databases", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_database(self, seqid, iprot, oprot):
    args = alter_database_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_database_result()
    try:
      self._handler.alter_database(args.dbname, args.db)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_database", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_type(self, seqid, iprot, oprot):
    args = get_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_type_result()
    try:
      result.success = self._handler.get_type(args.name)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_type(self, seqid, iprot, oprot):
    args = create_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_type_result()
    try:
      result.success = self._handler.create_type(args.type)
    except AlreadyExistsException as o1:
      result.o1 = o1
    except InvalidObjectException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("create_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_type(self, seqid, iprot, oprot):
    args = drop_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_type_result()
    try:
      result.success = self._handler.drop_type(args.type)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_type_all(self, seqid, iprot, oprot):
    args = get_type_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_type_all_result()
    try:
      result.success = self._handler.get_type_all(args.name)
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_type_all", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_fields(self, seqid, iprot, oprot):
    args = get_fields_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_fields_result()
    try:
      result.success = self._handler.get_fields(args.db_name, args.table_name)
    except MetaException as o1:
      result.o1 = o1
    except UnknownTableException as o2:
      result.o2 = o2
    except UnknownDBException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("get_fields", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_schema(self, seqid, iprot, oprot):
    args = get_schema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_schema_result()
    try:
      result.success = self._handler.get_schema(args.db_name, args.table_name)
    except MetaException as o1:
      result.o1 = o1
    except UnknownTableException as o2:
      result.o2 = o2
    except UnknownDBException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("get_schema", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table(self, seqid, iprot, oprot):
    args = create_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_result()
    try:
      self._handler.create_table(args.tbl)
    except AlreadyExistsException as o1:
      result.o1 = o1
    except InvalidObjectException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    except NoSuchObjectException as o4:
      result.o4 = o4
    oprot.writeMessageBegin("create_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table_by_user(self, seqid, iprot, oprot):
    args = create_table_by_user_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_by_user_result()
    try:
      self._handler.create_table_by_user(args.tbl, args.user)
    except AlreadyExistsException as o1:
      result.o1 = o1
    except InvalidObjectException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    except NoSuchObjectException as o4:
      result.o4 = o4
    oprot.writeMessageBegin("create_table_by_user", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_table_with_environment_context(self, seqid, iprot, oprot):
    args = create_table_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_table_with_environment_context_result()
    try:
      self._handler.create_table_with_environment_context(args.tbl, args.environment_context)
    except AlreadyExistsException as o1:
      result.o1 = o1
    except InvalidObjectException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    except NoSuchObjectException as o4:
      result.o4 = o4
    oprot.writeMessageBegin("create_table_with_environment_context", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_table(self, seqid, iprot, oprot):
    args = drop_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_table_result()
    try:
      self._handler.drop_table(args.dbname, args.name, args.deleteData)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("drop_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_tables(self, seqid, iprot, oprot):
    args = get_tables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_tables_result()
    try:
      result.success = self._handler.get_tables(args.db_name, args.pattern)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_tables", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_tables(self, seqid, iprot, oprot):
    args = get_all_tables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_tables_result()
    try:
      result.success = self._handler.get_all_tables(args.db_name)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_all_tables", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table(self, seqid, iprot, oprot):
    args = get_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_result()
    try:
      result.success = self._handler.get_table(args.dbname, args.tbl_name)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_objects_by_name(self, seqid, iprot, oprot):
    args = get_table_objects_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_objects_by_name_result()
    try:
      result.success = self._handler.get_table_objects_by_name(args.dbname, args.tbl_names)
    except MetaException as o1:
      result.o1 = o1
    except InvalidOperationException as o2:
      result.o2 = o2
    except UnknownDBException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("get_table_objects_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_names_by_filter(self, seqid, iprot, oprot):
    args = get_table_names_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_names_by_filter_result()
    try:
      result.success = self._handler.get_table_names_by_filter(args.dbname, args.filter, args.max_tables)
    except MetaException as o1:
      result.o1 = o1
    except InvalidOperationException as o2:
      result.o2 = o2
    except UnknownDBException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("get_table_names_by_filter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table(self, seqid, iprot, oprot):
    args = alter_table_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_result()
    try:
      self._handler.alter_table(args.dbname, args.tbl_name, args.new_tbl)
    except InvalidOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_table", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_table_with_environment_context(self, seqid, iprot, oprot):
    args = alter_table_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_table_with_environment_context_result()
    try:
      self._handler.alter_table_with_environment_context(args.dbname, args.tbl_name, args.new_tbl, args.environment_context)
    except InvalidOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_table_with_environment_context", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition(self, seqid, iprot, oprot):
    args = add_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_result()
    try:
      result.success = self._handler.add_partition(args.new_part)
    except InvalidObjectException as o1:
      result.o1 = o1
    except AlreadyExistsException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("add_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partition_with_environment_context(self, seqid, iprot, oprot):
    args = add_partition_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partition_with_environment_context_result()
    try:
      result.success = self._handler.add_partition_with_environment_context(args.new_part, args.environment_context)
    except InvalidObjectException as o1:
      result.o1 = o1
    except AlreadyExistsException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("add_partition_with_environment_context", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_partitions(self, seqid, iprot, oprot):
    args = add_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_partitions_result()
    try:
      result.success = self._handler.add_partitions(args.new_parts)
    except InvalidObjectException as o1:
      result.o1 = o1
    except AlreadyExistsException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("add_partitions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition(self, seqid, iprot, oprot):
    args = append_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_result()
    try:
      result.success = self._handler.append_partition(args.db_name, args.tbl_name, args.part_vals)
    except InvalidObjectException as o1:
      result.o1 = o1
    except AlreadyExistsException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("append_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_append_partition_by_name(self, seqid, iprot, oprot):
    args = append_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = append_partition_by_name_result()
    try:
      result.success = self._handler.append_partition_by_name(args.db_name, args.tbl_name, args.part_name)
    except InvalidObjectException as o1:
      result.o1 = o1
    except AlreadyExistsException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("append_partition_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition(self, seqid, iprot, oprot):
    args = drop_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_result()
    try:
      result.success = self._handler.drop_partition(args.db_name, args.tbl_name, args.part_vals, args.deleteData)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_partition_by_name(self, seqid, iprot, oprot):
    args = drop_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_partition_by_name_result()
    try:
      result.success = self._handler.drop_partition_by_name(args.db_name, args.tbl_name, args.part_name, args.deleteData)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_partition_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition(self, seqid, iprot, oprot):
    args = get_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_result()
    try:
      result.success = self._handler.get_partition(args.db_name, args.tbl_name, args.part_vals)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_with_auth(self, seqid, iprot, oprot):
    args = get_partition_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_with_auth_result()
    try:
      result.success = self._handler.get_partition_with_auth(args.db_name, args.tbl_name, args.part_vals, args.user_name, args.group_names)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition_with_auth", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_by_name(self, seqid, iprot, oprot):
    args = get_partition_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_by_name_result()
    try:
      result.success = self._handler.get_partition_by_name(args.db_name, args.tbl_name, args.part_name)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions(self, seqid, iprot, oprot):
    args = get_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_result()
    try:
      result.success = self._handler.get_partitions(args.db_name, args.tbl_name, args.max_parts)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_with_auth(self, seqid, iprot, oprot):
    args = get_partitions_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_with_auth_result()
    try:
      result.success = self._handler.get_partitions_with_auth(args.db_name, args.tbl_name, args.max_parts, args.user_name, args.group_names)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions_with_auth", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_names(self, seqid, iprot, oprot):
    args = get_partition_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_names_result()
    try:
      result.success = self._handler.get_partition_names(args.db_name, args.tbl_name, args.max_parts)
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_ps(self, seqid, iprot, oprot):
    args = get_partitions_ps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_ps_result()
    try:
      result.success = self._handler.get_partitions_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions_ps", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_ps_with_auth(self, seqid, iprot, oprot):
    args = get_partitions_ps_with_auth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_ps_with_auth_result()
    try:
      result.success = self._handler.get_partitions_ps_with_auth(args.db_name, args.tbl_name, args.part_vals, args.max_parts, args.user_name, args.group_names)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions_ps_with_auth", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_names_ps(self, seqid, iprot, oprot):
    args = get_partition_names_ps_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_names_ps_result()
    try:
      result.success = self._handler.get_partition_names_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partition_names_ps", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_by_filter(self, seqid, iprot, oprot):
    args = get_partitions_by_filter_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_by_filter_result()
    try:
      result.success = self._handler.get_partitions_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions_by_filter", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partitions_by_names(self, seqid, iprot, oprot):
    args = get_partitions_by_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partitions_by_names_result()
    try:
      result.success = self._handler.get_partitions_by_names(args.db_name, args.tbl_name, args.names)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_partitions_by_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partition(self, seqid, iprot, oprot):
    args = alter_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partition_result()
    try:
      self._handler.alter_partition(args.db_name, args.tbl_name, args.new_part)
    except InvalidOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partitions(self, seqid, iprot, oprot):
    args = alter_partitions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partitions_result()
    try:
      self._handler.alter_partitions(args.db_name, args.tbl_name, args.new_parts)
    except InvalidOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_partitions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_partition_with_environment_context(self, seqid, iprot, oprot):
    args = alter_partition_with_environment_context_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_partition_with_environment_context_result()
    try:
      self._handler.alter_partition_with_environment_context(args.db_name, args.tbl_name, args.new_part, args.environment_context)
    except InvalidOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_partition_with_environment_context", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rename_partition(self, seqid, iprot, oprot):
    args = rename_partition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rename_partition_result()
    try:
      self._handler.rename_partition(args.db_name, args.tbl_name, args.part_vals, args.new_part)
    except InvalidOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("rename_partition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_config_value(self, seqid, iprot, oprot):
    args = get_config_value_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_config_value_result()
    try:
      result.success = self._handler.get_config_value(args.name, args.defaultValue)
    except ConfigValSecurityException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_config_value", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_to_vals(self, seqid, iprot, oprot):
    args = partition_name_to_vals_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_to_vals_result()
    try:
      result.success = self._handler.partition_name_to_vals(args.part_name)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("partition_name_to_vals", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_partition_name_to_spec(self, seqid, iprot, oprot):
    args = partition_name_to_spec_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = partition_name_to_spec_result()
    try:
      result.success = self._handler.partition_name_to_spec(args.part_name)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("partition_name_to_spec", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_markPartitionForEvent(self, seqid, iprot, oprot):
    args = markPartitionForEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = markPartitionForEvent_result()
    try:
      self._handler.markPartitionForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    except UnknownDBException as o3:
      result.o3 = o3
    except UnknownTableException as o4:
      result.o4 = o4
    except UnknownPartitionException as o5:
      result.o5 = o5
    except InvalidPartitionException as o6:
      result.o6 = o6
    oprot.writeMessageBegin("markPartitionForEvent", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isPartitionMarkedForEvent(self, seqid, iprot, oprot):
    args = isPartitionMarkedForEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isPartitionMarkedForEvent_result()
    try:
      result.success = self._handler.isPartitionMarkedForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    except UnknownDBException as o3:
      result.o3 = o3
    except UnknownTableException as o4:
      result.o4 = o4
    except UnknownPartitionException as o5:
      result.o5 = o5
    except InvalidPartitionException as o6:
      result.o6 = o6
    oprot.writeMessageBegin("isPartitionMarkedForEvent", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_index(self, seqid, iprot, oprot):
    args = add_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_index_result()
    try:
      result.success = self._handler.add_index(args.new_index, args.index_table)
    except InvalidObjectException as o1:
      result.o1 = o1
    except AlreadyExistsException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("add_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_index(self, seqid, iprot, oprot):
    args = alter_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_index_result()
    try:
      self._handler.alter_index(args.dbname, args.base_tbl_name, args.idx_name, args.new_idx)
    except InvalidOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("alter_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_index_by_name(self, seqid, iprot, oprot):
    args = drop_index_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_index_by_name_result()
    try:
      result.success = self._handler.drop_index_by_name(args.db_name, args.tbl_name, args.index_name, args.deleteData)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_index_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_index_by_name(self, seqid, iprot, oprot):
    args = get_index_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_index_by_name_result()
    try:
      result.success = self._handler.get_index_by_name(args.db_name, args.tbl_name, args.index_name)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_index_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_indexes(self, seqid, iprot, oprot):
    args = get_indexes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_indexes_result()
    try:
      result.success = self._handler.get_indexes(args.db_name, args.tbl_name, args.max_indexes)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_indexes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_index_names(self, seqid, iprot, oprot):
    args = get_index_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_index_names_result()
    try:
      result.success = self._handler.get_index_names(args.db_name, args.tbl_name, args.max_indexes)
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_index_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_table_column_statistics(self, seqid, iprot, oprot):
    args = update_table_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_table_column_statistics_result()
    try:
      result.success = self._handler.update_table_column_statistics(args.stats_obj)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except InvalidObjectException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    except InvalidInputException as o4:
      result.o4 = o4
    oprot.writeMessageBegin("update_table_column_statistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_partition_column_statistics(self, seqid, iprot, oprot):
    args = update_partition_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_partition_column_statistics_result()
    try:
      result.success = self._handler.update_partition_column_statistics(args.stats_obj)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except InvalidObjectException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    except InvalidInputException as o4:
      result.o4 = o4
    oprot.writeMessageBegin("update_partition_column_statistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_table_column_statistics(self, seqid, iprot, oprot):
    args = get_table_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_table_column_statistics_result()
    try:
      result.success = self._handler.get_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    except InvalidInputException as o3:
      result.o3 = o3
    except InvalidObjectException as o4:
      result.o4 = o4
    oprot.writeMessageBegin("get_table_column_statistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_partition_column_statistics(self, seqid, iprot, oprot):
    args = get_partition_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_partition_column_statistics_result()
    try:
      result.success = self._handler.get_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    except InvalidInputException as o3:
      result.o3 = o3
    except InvalidObjectException as o4:
      result.o4 = o4
    oprot.writeMessageBegin("get_partition_column_statistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_partition_column_statistics(self, seqid, iprot, oprot):
    args = delete_partition_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_partition_column_statistics_result()
    try:
      result.success = self._handler.delete_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    except InvalidObjectException as o3:
      result.o3 = o3
    except InvalidInputException as o4:
      result.o4 = o4
    oprot.writeMessageBegin("delete_partition_column_statistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_table_column_statistics(self, seqid, iprot, oprot):
    args = delete_table_column_statistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_table_column_statistics_result()
    try:
      result.success = self._handler.delete_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    except InvalidObjectException as o3:
      result.o3 = o3
    except InvalidInputException as o4:
      result.o4 = o4
    oprot.writeMessageBegin("delete_table_column_statistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_user(self, seqid, iprot, oprot):
    args = create_user_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_user_result()
    try:
      result.success = self._handler.create_user(args.user)
    except InvalidObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("create_user", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_user(self, seqid, iprot, oprot):
    args = drop_user_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_user_result()
    try:
      result.success = self._handler.drop_user(args.user_name)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("drop_user", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_modify_user(self, seqid, iprot, oprot):
    args = modify_user_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = modify_user_result()
    try:
      result.success = self._handler.modify_user(args.user)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("modify_user", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_users_names(self, seqid, iprot, oprot):
    args = list_users_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_users_names_result()
    try:
      result.success = self._handler.list_users_names()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("list_users_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_users(self, seqid, iprot, oprot):
    args = list_users_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_users_result()
    try:
      result.success = self._handler.list_users(args.db)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("list_users", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authentication(self, seqid, iprot, oprot):
    args = authentication_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authentication_result()
    try:
      result.success = self._handler.authentication(args.user_name, args.passwd)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("authentication", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_user_authority_check(self, seqid, iprot, oprot):
    args = user_authority_check_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = user_authority_check_result()
    try:
      result.success = self._handler.user_authority_check(args.user, args.tbl, args.ops)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("user_authority_check", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_role(self, seqid, iprot, oprot):
    args = create_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_role_result()
    try:
      result.success = self._handler.create_role(args.role)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("create_role", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drop_role(self, seqid, iprot, oprot):
    args = drop_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drop_role_result()
    try:
      result.success = self._handler.drop_role(args.role_name)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("drop_role", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_role_names(self, seqid, iprot, oprot):
    args = get_role_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_role_names_result()
    try:
      result.success = self._handler.get_role_names()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_role_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_role(self, seqid, iprot, oprot):
    args = grant_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_role_result()
    try:
      result.success = self._handler.grant_role(args.role_name, args.principal_name, args.principal_type, args.grantor, args.grantorType, args.grant_option)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("grant_role", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revoke_role(self, seqid, iprot, oprot):
    args = revoke_role_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revoke_role_result()
    try:
      result.success = self._handler.revoke_role(args.role_name, args.principal_name, args.principal_type)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("revoke_role", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_roles(self, seqid, iprot, oprot):
    args = list_roles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_roles_result()
    try:
      result.success = self._handler.list_roles(args.principal_name, args.principal_type)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("list_roles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_privilege_set(self, seqid, iprot, oprot):
    args = get_privilege_set_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_privilege_set_result()
    try:
      result.success = self._handler.get_privilege_set(args.hiveObject, args.user_name, args.group_names)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_privilege_set", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_privileges(self, seqid, iprot, oprot):
    args = list_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_privileges_result()
    try:
      result.success = self._handler.list_privileges(args.principal_name, args.principal_type, args.hiveObject)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("list_privileges", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_grant_privileges(self, seqid, iprot, oprot):
    args = grant_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = grant_privileges_result()
    try:
      result.success = self._handler.grant_privileges(args.privileges)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("grant_privileges", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revoke_privileges(self, seqid, iprot, oprot):
    args = revoke_privileges_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revoke_privileges_result()
    try:
      result.success = self._handler.revoke_privileges(args.privileges)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("revoke_privileges", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_ugi(self, seqid, iprot, oprot):
    args = set_ugi_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_ugi_result()
    try:
      result.success = self._handler.set_ugi(args.user_name, args.group_names)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("set_ugi", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_delegation_token(self, seqid, iprot, oprot):
    args = get_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_delegation_token_result()
    try:
      result.success = self._handler.get_delegation_token(args.token_owner, args.renewer_kerberos_principal_name)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_delegation_token", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_renew_delegation_token(self, seqid, iprot, oprot):
    args = renew_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = renew_delegation_token_result()
    try:
      result.success = self._handler.renew_delegation_token(args.token_str_form)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("renew_delegation_token", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cancel_delegation_token(self, seqid, iprot, oprot):
    args = cancel_delegation_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cancel_delegation_token_result()
    try:
      self._handler.cancel_delegation_token(args.token_str_form)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("cancel_delegation_token", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_file(self, seqid, iprot, oprot):
    args = create_file_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_file_result()
    try:
      result.success = self._handler.create_file(args.node_name, args.repnr, args.db_name, args.table_name, args.values)
    except FileOperationException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("create_file", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_file_by_policy(self, seqid, iprot, oprot):
    args = create_file_by_policy_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_file_by_policy_result()
    try:
      result.success = self._handler.create_file_by_policy(args.policy, args.repnr, args.db_name, args.table_name, args.values)
    except FileOperationException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("create_file_by_policy", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_file_repnr(self, seqid, iprot, oprot):
    args = set_file_repnr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_file_repnr_result()
    try:
      self._handler.set_file_repnr(args.fid, args.repnr)
    except FileOperationException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("set_file_repnr", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_reopen_file(self, seqid, iprot, oprot):
    args = reopen_file_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = reopen_file_result()
    try:
      result.success = self._handler.reopen_file(args.fid)
    except FileOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("reopen_file", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_close_file(self, seqid, iprot, oprot):
    args = close_file_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = close_file_result()
    try:
      result.success = self._handler.close_file(args.file)
    except FileOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("close_file", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_online_filelocation(self, seqid, iprot, oprot):
    args = online_filelocation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = online_filelocation_result()
    try:
      result.success = self._handler.online_filelocation(args.file)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("online_filelocation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_offline_filelocation(self, seqid, iprot, oprot):
    args = offline_filelocation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = offline_filelocation_result()
    try:
      result.success = self._handler.offline_filelocation(args.sfl)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("offline_filelocation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_loadstatus_bad(self, seqid, iprot, oprot):
    args = set_loadstatus_bad_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_loadstatus_bad_result()
    try:
      result.success = self._handler.set_loadstatus_bad(args.fid)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("set_loadstatus_bad", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_toggle_safemode(self, seqid, iprot, oprot):
    args = toggle_safemode_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = toggle_safemode_result()
    try:
      result.success = self._handler.toggle_safemode()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("toggle_safemode", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_file_by_id(self, seqid, iprot, oprot):
    args = get_file_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_file_by_id_result()
    try:
      result.success = self._handler.get_file_by_id(args.fid)
    except FileOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_file_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_file_by_name(self, seqid, iprot, oprot):
    args = get_file_by_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_file_by_name_result()
    try:
      result.success = self._handler.get_file_by_name(args.node, args.devid, args.location)
    except FileOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_file_by_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rm_file_logical(self, seqid, iprot, oprot):
    args = rm_file_logical_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rm_file_logical_result()
    try:
      result.success = self._handler.rm_file_logical(args.file)
    except FileOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("rm_file_logical", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_restore_file(self, seqid, iprot, oprot):
    args = restore_file_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = restore_file_result()
    try:
      result.success = self._handler.restore_file(args.file)
    except FileOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("restore_file", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rm_file_physical(self, seqid, iprot, oprot):
    args = rm_file_physical_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rm_file_physical_result()
    try:
      result.success = self._handler.rm_file_physical(args.file)
    except FileOperationException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("rm_file_physical", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_node(self, seqid, iprot, oprot):
    args = get_node_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_node_result()
    try:
      result.success = self._handler.get_node(args.node_name)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_node", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_node(self, seqid, iprot, oprot):
    args = add_node_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_node_result()
    try:
      result.success = self._handler.add_node(args.node_name, args.ipl)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("add_node", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_del_node(self, seqid, iprot, oprot):
    args = del_node_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = del_node_result()
    try:
      result.success = self._handler.del_node(args.node_name)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("del_node", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_device(self, seqid, iprot, oprot):
    args = create_device_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_device_result()
    try:
      result.success = self._handler.create_device(args.devid, args.prop, args.node_name)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("create_device", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_device(self, seqid, iprot, oprot):
    args = get_device_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_device_result()
    try:
      result.success = self._handler.get_device(args.devid)
    except MetaException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("get_device", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_del_device(self, seqid, iprot, oprot):
    args = del_device_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = del_device_result()
    try:
      result.success = self._handler.del_device(args.devid)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("del_device", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_modify_device(self, seqid, iprot, oprot):
    args = modify_device_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = modify_device_result()
    try:
      result.success = self._handler.modify_device(args.dev, args.node)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("modify_device", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_device(self, seqid, iprot, oprot):
    args = list_device_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_device_result()
    try:
      result.success = self._handler.list_device()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("list_device", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_alter_node(self, seqid, iprot, oprot):
    args = alter_node_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = alter_node_result()
    try:
      result.success = self._handler.alter_node(args.node_name, args.ipl, args.status)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("alter_node", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_find_best_nodes(self, seqid, iprot, oprot):
    args = find_best_nodes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = find_best_nodes_result()
    try:
      result.success = self._handler.find_best_nodes(args.nr)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("find_best_nodes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_find_best_nodes_in_groups(self, seqid, iprot, oprot):
    args = find_best_nodes_in_groups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = find_best_nodes_in_groups_result()
    try:
      result.success = self._handler.find_best_nodes_in_groups(args.dbName, args.tableName, args.nr, args.policy)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("find_best_nodes_in_groups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_all_nodes(self, seqid, iprot, oprot):
    args = get_all_nodes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_all_nodes_result()
    try:
      result.success = self._handler.get_all_nodes()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("get_all_nodes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDMStatus(self, seqid, iprot, oprot):
    args = getDMStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDMStatus_result()
    try:
      result.success = self._handler.getDMStatus()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("getDMStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNodeInfo(self, seqid, iprot, oprot):
    args = getNodeInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNodeInfo_result()
    try:
      result.success = self._handler.getNodeInfo()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("getNodeInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_migrate_in(self, seqid, iprot, oprot):
    args = migrate_in_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = migrate_in_result()
    try:
      result.success = self._handler.migrate_in(args.tbl, args.files, args.idxs, args.from_db, args.to_devid, args.fileMap)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("migrate_in", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_migrate_stage1(self, seqid, iprot, oprot):
    args = migrate_stage1_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = migrate_stage1_result()
    try:
      result.success = self._handler.migrate_stage1(args.dbName, args.tableName, args.files, args.to_db)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("migrate_stage1", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_migrate_stage2(self, seqid, iprot, oprot):
    args = migrate_stage2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = migrate_stage2_result()
    try:
      result.success = self._handler.migrate_stage2(args.dbName, args.tableName, args.files, args.from_db, args.to_db, args.to_devid, args.user, args.password)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("migrate_stage2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_migrate2_in(self, seqid, iprot, oprot):
    args = migrate2_in_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = migrate2_in_result()
    try:
      result.success = self._handler.migrate2_in(args.tbl, args.parts, args.idxs, args.from_db, args.to_nas_devid, args.fileMap)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("migrate2_in", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_migrate2_stage1(self, seqid, iprot, oprot):
    args = migrate2_stage1_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = migrate2_stage1_result()
    try:
      result.success = self._handler.migrate2_stage1(args.dbName, args.tableName, args.partNames, args.to_db)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("migrate2_stage1", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_migrate2_stage2(self, seqid, iprot, oprot):
    args = migrate2_stage2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = migrate2_stage2_result()
    try:
      result.success = self._handler.migrate2_stage2(args.dbName, args.tableName, args.partNames, args.from_db, args.to_db, args.to_nas_devid)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("migrate2_stage2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getMP(self, seqid, iprot, oprot):
    args = getMP_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMP_result()
    try:
      result.success = self._handler.getMP(args.node_name, args.devid)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("getMP", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSessionId(self, seqid, iprot, oprot):
    args = getSessionId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSessionId_result()
    try:
      result.success = self._handler.getSessionId()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("getSessionId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createSchema(self, seqid, iprot, oprot):
    args = createSchema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createSchema_result()
    try:
      result.success = self._handler.createSchema(args.schema)
    except AlreadyExistsException as o1:
      result.o1 = o1
    except InvalidObjectException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("createSchema", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_modifySchema(self, seqid, iprot, oprot):
    args = modifySchema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = modifySchema_result()
    try:
      result.success = self._handler.modifySchema(args.schemaName, args.schema)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("modifySchema", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteSchema(self, seqid, iprot, oprot):
    args = deleteSchema_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteSchema_result()
    try:
      result.success = self._handler.deleteSchema(args.schemaName)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("deleteSchema", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSchemas(self, seqid, iprot, oprot):
    args = listSchemas_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSchemas_result()
    try:
      result.success = self._handler.listSchemas()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listSchemas", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSchemaByName(self, seqid, iprot, oprot):
    args = getSchemaByName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSchemaByName_result()
    try:
      result.success = self._handler.getSchemaByName(args.schemaName)
    except NoSuchObjectException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("getSchemaByName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTableNodeGroups(self, seqid, iprot, oprot):
    args = getTableNodeGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTableNodeGroups_result()
    try:
      result.success = self._handler.getTableNodeGroups(args.dbName, args.tabName)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("getTableNodeGroups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTableNodeFiles(self, seqid, iprot, oprot):
    args = getTableNodeFiles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTableNodeFiles_result()
    try:
      result.success = self._handler.getTableNodeFiles(args.dbName, args.tabName, args.nodeName)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("getTableNodeFiles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listTableFiles(self, seqid, iprot, oprot):
    args = listTableFiles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listTableFiles_result()
    try:
      result.success = self._handler.listTableFiles(args.dbName, args.tabName, args.from, args.to)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listTableFiles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listFilesByDigest(self, seqid, iprot, oprot):
    args = listFilesByDigest_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listFilesByDigest_result()
    try:
      result.success = self._handler.listFilesByDigest(args.digest)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listFilesByDigest", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_filterTableFiles(self, seqid, iprot, oprot):
    args = filterTableFiles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = filterTableFiles_result()
    try:
      result.success = self._handler.filterTableFiles(args.dbName, args.tabName, args.values)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("filterTableFiles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_truncTableFiles(self, seqid, iprot, oprot):
    args = truncTableFiles_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = truncTableFiles_result()
    try:
      self._handler.truncTableFiles(args.dbName, args.tabName)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("truncTableFiles", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addNodeGroup(self, seqid, iprot, oprot):
    args = addNodeGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addNodeGroup_result()
    try:
      result.success = self._handler.addNodeGroup(args.ng)
    except AlreadyExistsException as o1:
      result.o1 = o1
    except MetaException as o2:
      result.o2 = o2
    oprot.writeMessageBegin("addNodeGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_modifyNodeGroup(self, seqid, iprot, oprot):
    args = modifyNodeGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = modifyNodeGroup_result()
    try:
      result.success = self._handler.modifyNodeGroup(args.schemaName, args.ng)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("modifyNodeGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteNodeGroup(self, seqid, iprot, oprot):
    args = deleteNodeGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteNodeGroup_result()
    try:
      result.success = self._handler.deleteNodeGroup(args.ng)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("deleteNodeGroup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listNodeGroups(self, seqid, iprot, oprot):
    args = listNodeGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listNodeGroups_result()
    try:
      result.success = self._handler.listNodeGroups()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listNodeGroups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listDBNodeGroups(self, seqid, iprot, oprot):
    args = listDBNodeGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listDBNodeGroups_result()
    try:
      result.success = self._handler.listDBNodeGroups(args.dbName)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listDBNodeGroups", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listNodeGroupByNames(self, seqid, iprot, oprot):
    args = listNodeGroupByNames_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listNodeGroupByNames_result()
    try:
      result.success = self._handler.listNodeGroupByNames(args.ngNames)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listNodeGroupByNames", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addTableNodeDist(self, seqid, iprot, oprot):
    args = addTableNodeDist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addTableNodeDist_result()
    try:
      result.success = self._handler.addTableNodeDist(args.db, args.tab, args.ng)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("addTableNodeDist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteTableNodeDist(self, seqid, iprot, oprot):
    args = deleteTableNodeDist_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteTableNodeDist_result()
    try:
      result.success = self._handler.deleteTableNodeDist(args.db, args.tab, args.ng)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("deleteTableNodeDist", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listTableNodeDists(self, seqid, iprot, oprot):
    args = listTableNodeDists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listTableNodeDists_result()
    try:
      result.success = self._handler.listTableNodeDists(args.dbName, args.tabName)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("listTableNodeDists", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_assiginSchematoDB(self, seqid, iprot, oprot):
    args = assiginSchematoDB_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = assiginSchematoDB_result()
    try:
      result.success = self._handler.assiginSchematoDB(args.dbName, args.schemaName, args.fileSplitKeys, args.part_keys, args.ngs)
    except InvalidObjectException as o1:
      result.o1 = o1
    except NoSuchObjectException as o2:
      result.o2 = o2
    except MetaException as o3:
      result.o3 = o3
    oprot.writeMessageBegin("assiginSchematoDB", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_statFileSystem(self, seqid, iprot, oprot):
    args = statFileSystem_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = statFileSystem_result()
    try:
      result.success = self._handler.statFileSystem(args.begin_time, args.end_time)
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("statFileSystem", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getMaxFid(self, seqid, iprot, oprot):
    args = getMaxFid_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMaxFid_result()
    try:
      result.success = self._handler.getMaxFid()
    except MetaException as o1:
      result.o1 = o1
    oprot.writeMessageBegin("getMaxFid", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class create_attribution_args:
  """
  Attributes:
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'db', (Database, Database.thrift_spec), None, ), # 1
  )

  def __init__(self, db=None,):
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.db = Database()
          self.db.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_attribution_args')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRUCT, 1)
      self.db.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_attribution_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_attribution_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_attribution_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_attribution_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_attribution_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Database, Database.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Database()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_attribution_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_attribution_args:
  """
  Attributes:
   - name
   - deleteData
   - cascade
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.BOOL, 'deleteData', None, None, ), # 2
    (3, TType.BOOL, 'cascade', None, None, ), # 3
  )

  def __init__(self, name=None, deleteData=None, cascade=None,):
    self.name = name
    self.deleteData = deleteData
    self.cascade = cascade

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.cascade = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_attribution_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 2)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.cascade is not None:
      oprot.writeFieldBegin('cascade', TType.BOOL, 3)
      oprot.writeBool(self.cascade)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_attribution_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_attribution_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_attribution_args:
  """
  Attributes:
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'db', (Database, Database.thrift_spec), None, ), # 1
  )

  def __init__(self, db=None,):
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.db = Database()
          self.db.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_attribution_args')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRUCT, 1)
      self.db.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_attribution_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_attribution_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_attributions_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_attributions_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_attributions_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Database, Database.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype362, _size359) = iprot.readListBegin()
          for _i363 in xrange(_size359):
            _elem364 = Database()
            _elem364.read(iprot)
            self.success.append(_elem364)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_attributions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter365 in self.success:
        iter365.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_local_attribution_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_local_attribution_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_local_attribution_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Database, Database.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Database()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_local_attribution_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_lucene_index_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_lucene_index_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes is not None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_lucene_index_names_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype369, _size366) = iprot.readListBegin()
          for _i370 in xrange(_size366):
            _elem371 = iprot.readString();
            self.success.append(_elem371)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_lucene_index_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter372 in self.success:
        oprot.writeString(iter372)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_busi_type_cols_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_busi_type_cols_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_busi_type_cols_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(BusiTypeColumn, BusiTypeColumn.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype376, _size373) = iprot.readListBegin()
          for _i377 in xrange(_size373):
            _elem378 = BusiTypeColumn()
            _elem378.read(iprot)
            self.success.append(_elem378)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_busi_type_cols_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter379 in self.success:
        iter379.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_busi_type_datacenters_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_busi_type_datacenters_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_busi_type_datacenters_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(BusiTypeDatacenter, BusiTypeDatacenter.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype383, _size380) = iprot.readListBegin()
          for _i384 in xrange(_size380):
            _elem385 = BusiTypeDatacenter()
            _elem385.read(iprot)
            self.success.append(_elem385)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_busi_type_datacenters_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter386 in self.success:
        iter386.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_busi_type_datacenter_args:
  """
  Attributes:
   - busiTypeDatacenter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'busiTypeDatacenter', (BusiTypeDatacenter, BusiTypeDatacenter.thrift_spec), None, ), # 1
  )

  def __init__(self, busiTypeDatacenter=None,):
    self.busiTypeDatacenter = busiTypeDatacenter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.busiTypeDatacenter = BusiTypeDatacenter()
          self.busiTypeDatacenter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_busi_type_datacenter_args')
    if self.busiTypeDatacenter is not None:
      oprot.writeFieldBegin('busiTypeDatacenter', TType.STRUCT, 1)
      self.busiTypeDatacenter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_busi_type_datacenter_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_busi_type_datacenter_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_datawarehouse_sql_args:
  """
  Attributes:
   - dwNum
   - sql
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dwNum', None, None, ), # 1
    (2, TType.STRING, 'sql', None, None, ), # 2
  )

  def __init__(self, dwNum=None, sql=None,):
    self.dwNum = dwNum
    self.sql = sql

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dwNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.sql = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_datawarehouse_sql_args')
    if self.dwNum is not None:
      oprot.writeFieldBegin('dwNum', TType.I32, 1)
      oprot.writeI32(self.dwNum)
      oprot.writeFieldEnd()
    if self.sql is not None:
      oprot.writeFieldBegin('sql', TType.STRING, 2)
      oprot.writeString(self.sql)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_datawarehouse_sql_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_datawarehouse_sql_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class showBusitypes_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('showBusitypes_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class showBusitypes_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Busitype, Busitype.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype390, _size387) = iprot.readListBegin()
          for _i391 in xrange(_size387):
            _elem392 = Busitype()
            _elem392.read(iprot)
            self.success.append(_elem392)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('showBusitypes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter393 in self.success:
        iter393.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createBusitype_args:
  """
  Attributes:
   - busitype
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'busitype', (Busitype, Busitype.thrift_spec), None, ), # 1
  )

  def __init__(self, busitype=None,):
    self.busitype = busitype

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.busitype = Busitype()
          self.busitype.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createBusitype_args')
    if self.busitype is not None:
      oprot.writeFieldBegin('busitype', TType.STRUCT, 1)
      self.busitype.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createBusitype_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createBusitype_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_files_args:
  """
  Attributes:
   - part
   - files
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'part', (Partition, Partition.thrift_spec), None, ), # 1
    (2, TType.LIST, 'files', (TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 2
  )

  def __init__(self, part=None, files=None,):
    self.part = part
    self.files = files

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.part = Partition()
          self.part.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.files = []
          (_etype397, _size394) = iprot.readListBegin()
          for _i398 in xrange(_size394):
            _elem399 = SFile()
            _elem399.read(iprot)
            self.files.append(_elem399)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_files_args')
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.STRUCT, 1)
      self.part.write(oprot)
      oprot.writeFieldEnd()
    if self.files is not None:
      oprot.writeFieldBegin('files', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.files))
      for iter400 in self.files:
        iter400.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_files_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_files_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_files_args:
  """
  Attributes:
   - part
   - files
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'part', (Partition, Partition.thrift_spec), None, ), # 1
    (2, TType.LIST, 'files', (TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 2
  )

  def __init__(self, part=None, files=None,):
    self.part = part
    self.files = files

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.part = Partition()
          self.part.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.files = []
          (_etype404, _size401) = iprot.readListBegin()
          for _i405 in xrange(_size401):
            _elem406 = SFile()
            _elem406.read(iprot)
            self.files.append(_elem406)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_files_args')
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.STRUCT, 1)
      self.part.write(oprot)
      oprot.writeFieldEnd()
    if self.files is not None:
      oprot.writeFieldBegin('files', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.files))
      for iter407 in self.files:
        iter407.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_files_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_files_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_subpartition_files_args:
  """
  Attributes:
   - subpart
   - files
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'subpart', (Subpartition, Subpartition.thrift_spec), None, ), # 1
    (2, TType.LIST, 'files', (TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 2
  )

  def __init__(self, subpart=None, files=None,):
    self.subpart = subpart
    self.files = files

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.subpart = Subpartition()
          self.subpart.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.files = []
          (_etype411, _size408) = iprot.readListBegin()
          for _i412 in xrange(_size408):
            _elem413 = SFile()
            _elem413.read(iprot)
            self.files.append(_elem413)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_subpartition_files_args')
    if self.subpart is not None:
      oprot.writeFieldBegin('subpart', TType.STRUCT, 1)
      self.subpart.write(oprot)
      oprot.writeFieldEnd()
    if self.files is not None:
      oprot.writeFieldBegin('files', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.files))
      for iter414 in self.files:
        iter414.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_subpartition_files_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_subpartition_files_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_subpartition_files_args:
  """
  Attributes:
   - subpart
   - files
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'subpart', (Subpartition, Subpartition.thrift_spec), None, ), # 1
    (2, TType.LIST, 'files', (TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 2
  )

  def __init__(self, subpart=None, files=None,):
    self.subpart = subpart
    self.files = files

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.subpart = Subpartition()
          self.subpart.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.files = []
          (_etype418, _size415) = iprot.readListBegin()
          for _i419 in xrange(_size415):
            _elem420 = SFile()
            _elem420.read(iprot)
            self.files.append(_elem420)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_subpartition_files_args')
    if self.subpart is not None:
      oprot.writeFieldBegin('subpart', TType.STRUCT, 1)
      self.subpart.write(oprot)
      oprot.writeFieldEnd()
    if self.files is not None:
      oprot.writeFieldBegin('files', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.files))
      for iter421 in self.files:
        iter421.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_subpartition_files_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_subpartition_files_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_index_args:
  """
  Attributes:
   - index
   - part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'part', (Partition, Partition.thrift_spec), None, ), # 2
  )

  def __init__(self, index=None, part=None,):
    self.index = index
    self.part = part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.index = Index()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.part = Partition()
          self.part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRUCT, 1)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.STRUCT, 2)
      self.part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_index_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_index_args:
  """
  Attributes:
   - index
   - part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'part', (Partition, Partition.thrift_spec), None, ), # 2
  )

  def __init__(self, index=None, part=None,):
    self.index = index
    self.part = part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.index = Index()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.part = Partition()
          self.part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRUCT, 1)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.STRUCT, 2)
      self.part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_index_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_subpartition_index_args:
  """
  Attributes:
   - index
   - part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'part', (Subpartition, Subpartition.thrift_spec), None, ), # 2
  )

  def __init__(self, index=None, part=None,):
    self.index = index
    self.part = part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.index = Index()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.part = Subpartition()
          self.part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_subpartition_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRUCT, 1)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.STRUCT, 2)
      self.part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_subpartition_index_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_subpartition_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_subpartition_index_args:
  """
  Attributes:
   - index
   - part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'part', (Subpartition, Subpartition.thrift_spec), None, ), # 2
  )

  def __init__(self, index=None, part=None,):
    self.index = index
    self.part = part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.index = Index()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.part = Subpartition()
          self.part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_subpartition_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRUCT, 1)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.STRUCT, 2)
      self.part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_subpartition_index_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_subpartition_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_subpartition_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - part_vals
   - sub_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'sub_part', (Subpartition, Subpartition.thrift_spec), None, ), # 4
  )

  def __init__(self, dbname=None, tbl_name=None, part_vals=None, sub_part=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.sub_part = sub_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype425, _size422) = iprot.readListBegin()
          for _i426 in xrange(_size422):
            _elem427 = iprot.readString();
            self.part_vals.append(_elem427)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.sub_part = Subpartition()
          self.sub_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_subpartition_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter428 in self.part_vals:
        oprot.writeString(iter428)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sub_part is not None:
      oprot.writeFieldBegin('sub_part', TType.STRUCT, 4)
      self.sub_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_subpartition_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_subpartition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_subpartitions_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'part', (Partition, Partition.thrift_spec), None, ), # 3
  )

  def __init__(self, dbname=None, tbl_name=None, part=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.part = part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.part = Partition()
          self.part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_subpartitions_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.STRUCT, 3)
      self.part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_subpartitions_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Subpartition, Subpartition.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype432, _size429) = iprot.readListBegin()
          for _i433 in xrange(_size429):
            _elem434 = Subpartition()
            _elem434.read(iprot)
            self.success.append(_elem434)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_subpartitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter435 in self.success:
        iter435.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_index_files_args:
  """
  Attributes:
   - index
   - part
   - file
   - originfid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'part', (Partition, Partition.thrift_spec), None, ), # 2
    (3, TType.LIST, 'file', (TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'originfid', (TType.I64,None), None, ), # 4
  )

  def __init__(self, index=None, part=None, file=None, originfid=None,):
    self.index = index
    self.part = part
    self.file = file
    self.originfid = originfid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.index = Index()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.part = Partition()
          self.part.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.file = []
          (_etype439, _size436) = iprot.readListBegin()
          for _i440 in xrange(_size436):
            _elem441 = SFile()
            _elem441.read(iprot)
            self.file.append(_elem441)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.originfid = []
          (_etype445, _size442) = iprot.readListBegin()
          for _i446 in xrange(_size442):
            _elem447 = iprot.readI64();
            self.originfid.append(_elem447)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_index_files_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRUCT, 1)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.STRUCT, 2)
      self.part.write(oprot)
      oprot.writeFieldEnd()
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.file))
      for iter448 in self.file:
        iter448.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.originfid is not None:
      oprot.writeFieldBegin('originfid', TType.LIST, 4)
      oprot.writeListBegin(TType.I64, len(self.originfid))
      for iter449 in self.originfid:
        oprot.writeI64(iter449)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_index_files_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_index_files_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_index_files_args:
  """
  Attributes:
   - index
   - part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'part', (Partition, Partition.thrift_spec), None, ), # 2
  )

  def __init__(self, index=None, part=None,):
    self.index = index
    self.part = part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.index = Index()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.part = Partition()
          self.part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_index_files_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRUCT, 1)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.STRUCT, 2)
      self.part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_index_files_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SFileRef, SFileRef.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype453, _size450) = iprot.readListBegin()
          for _i454 in xrange(_size450):
            _elem455 = SFileRef()
            _elem455.read(iprot)
            self.success.append(_elem455)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_index_files_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter456 in self.success:
        iter456.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_index_files_args:
  """
  Attributes:
   - index
   - part
   - file
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'part', (Partition, Partition.thrift_spec), None, ), # 2
    (3, TType.LIST, 'file', (TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 3
  )

  def __init__(self, index=None, part=None, file=None,):
    self.index = index
    self.part = part
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.index = Index()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.part = Partition()
          self.part.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.file = []
          (_etype460, _size457) = iprot.readListBegin()
          for _i461 in xrange(_size457):
            _elem462 = SFile()
            _elem462.read(iprot)
            self.file.append(_elem462)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_index_files_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRUCT, 1)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    if self.part is not None:
      oprot.writeFieldBegin('part', TType.STRUCT, 2)
      self.part.write(oprot)
      oprot.writeFieldEnd()
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.file))
      for iter463 in self.file:
        iter463.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_index_files_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_index_files_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_subpartition_index_files_args:
  """
  Attributes:
   - index
   - subpart
   - file
   - originfid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'subpart', (Subpartition, Subpartition.thrift_spec), None, ), # 2
    (3, TType.LIST, 'file', (TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'originfid', (TType.I64,None), None, ), # 4
  )

  def __init__(self, index=None, subpart=None, file=None, originfid=None,):
    self.index = index
    self.subpart = subpart
    self.file = file
    self.originfid = originfid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.index = Index()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.subpart = Subpartition()
          self.subpart.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.file = []
          (_etype467, _size464) = iprot.readListBegin()
          for _i468 in xrange(_size464):
            _elem469 = SFile()
            _elem469.read(iprot)
            self.file.append(_elem469)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.originfid = []
          (_etype473, _size470) = iprot.readListBegin()
          for _i474 in xrange(_size470):
            _elem475 = iprot.readI64();
            self.originfid.append(_elem475)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_subpartition_index_files_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRUCT, 1)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    if self.subpart is not None:
      oprot.writeFieldBegin('subpart', TType.STRUCT, 2)
      self.subpart.write(oprot)
      oprot.writeFieldEnd()
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.file))
      for iter476 in self.file:
        iter476.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.originfid is not None:
      oprot.writeFieldBegin('originfid', TType.LIST, 4)
      oprot.writeListBegin(TType.I64, len(self.originfid))
      for iter477 in self.originfid:
        oprot.writeI64(iter477)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_subpartition_index_files_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_subpartition_index_files_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_subpartition_index_files_args:
  """
  Attributes:
   - index
   - subpart
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'subpart', (Subpartition, Subpartition.thrift_spec), None, ), # 2
  )

  def __init__(self, index=None, subpart=None,):
    self.index = index
    self.subpart = subpart

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.index = Index()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.subpart = Subpartition()
          self.subpart.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_subpartition_index_files_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRUCT, 1)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    if self.subpart is not None:
      oprot.writeFieldBegin('subpart', TType.STRUCT, 2)
      self.subpart.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_subpartition_index_files_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SFileRef, SFileRef.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype481, _size478) = iprot.readListBegin()
          for _i482 in xrange(_size478):
            _elem483 = SFileRef()
            _elem483.read(iprot)
            self.success.append(_elem483)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_subpartition_index_files_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter484 in self.success:
        iter484.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_subpartition_index_files_args:
  """
  Attributes:
   - index
   - subpart
   - file
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'subpart', (Subpartition, Subpartition.thrift_spec), None, ), # 2
    (3, TType.LIST, 'file', (TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 3
  )

  def __init__(self, index=None, subpart=None, file=None,):
    self.index = index
    self.subpart = subpart
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.index = Index()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.subpart = Subpartition()
          self.subpart.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.file = []
          (_etype488, _size485) = iprot.readListBegin()
          for _i489 in xrange(_size485):
            _elem490 = SFile()
            _elem490.read(iprot)
            self.file.append(_elem490)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_subpartition_index_files_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.STRUCT, 1)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    if self.subpart is not None:
      oprot.writeFieldBegin('subpart', TType.STRUCT, 2)
      self.subpart.write(oprot)
      oprot.writeFieldEnd()
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.file))
      for iter491 in self.file:
        iter491.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_subpartition_index_files_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_subpartition_index_files_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addGeoLocation_args:
  """
  Attributes:
   - gl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'gl', (GeoLocation, GeoLocation.thrift_spec), None, ), # 1
  )

  def __init__(self, gl=None,):
    self.gl = gl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.gl = GeoLocation()
          self.gl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addGeoLocation_args')
    if self.gl is not None:
      oprot.writeFieldBegin('gl', TType.STRUCT, 1)
      self.gl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addGeoLocation_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addGeoLocation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modifyGeoLocation_args:
  """
  Attributes:
   - gl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'gl', (GeoLocation, GeoLocation.thrift_spec), None, ), # 1
  )

  def __init__(self, gl=None,):
    self.gl = gl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.gl = GeoLocation()
          self.gl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modifyGeoLocation_args')
    if self.gl is not None:
      oprot.writeFieldBegin('gl', TType.STRUCT, 1)
      self.gl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modifyGeoLocation_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modifyGeoLocation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteGeoLocation_args:
  """
  Attributes:
   - gl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'gl', (GeoLocation, GeoLocation.thrift_spec), None, ), # 1
  )

  def __init__(self, gl=None,):
    self.gl = gl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.gl = GeoLocation()
          self.gl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteGeoLocation_args')
    if self.gl is not None:
      oprot.writeFieldBegin('gl', TType.STRUCT, 1)
      self.gl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteGeoLocation_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteGeoLocation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listGeoLocation_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listGeoLocation_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listGeoLocation_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(GeoLocation, GeoLocation.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype495, _size492) = iprot.readListBegin()
          for _i496 in xrange(_size492):
            _elem497 = GeoLocation()
            _elem497.read(iprot)
            self.success.append(_elem497)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listGeoLocation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter498 in self.success:
        iter498.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addEquipRoom_args:
  """
  Attributes:
   - er
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'er', (EquipRoom, EquipRoom.thrift_spec), None, ), # 1
  )

  def __init__(self, er=None,):
    self.er = er

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.er = EquipRoom()
          self.er.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addEquipRoom_args')
    if self.er is not None:
      oprot.writeFieldBegin('er', TType.STRUCT, 1)
      self.er.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addEquipRoom_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addEquipRoom_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modifyEquipRoom_args:
  """
  Attributes:
   - er
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'er', (EquipRoom, EquipRoom.thrift_spec), None, ), # 1
  )

  def __init__(self, er=None,):
    self.er = er

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.er = EquipRoom()
          self.er.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modifyEquipRoom_args')
    if self.er is not None:
      oprot.writeFieldBegin('er', TType.STRUCT, 1)
      self.er.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modifyEquipRoom_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modifyEquipRoom_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteEquipRoom_args:
  """
  Attributes:
   - er
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'er', (EquipRoom, EquipRoom.thrift_spec), None, ), # 1
  )

  def __init__(self, er=None,):
    self.er = er

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.er = EquipRoom()
          self.er.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteEquipRoom_args')
    if self.er is not None:
      oprot.writeFieldBegin('er', TType.STRUCT, 1)
      self.er.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteEquipRoom_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteEquipRoom_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listEquipRoom_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listEquipRoom_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listEquipRoom_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(EquipRoom, EquipRoom.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype502, _size499) = iprot.readListBegin()
          for _i503 in xrange(_size499):
            _elem504 = EquipRoom()
            _elem504.read(iprot)
            self.success.append(_elem504)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listEquipRoom_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter505 in self.success:
        iter505.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGeoLocationByName_args:
  """
  Attributes:
   - geoLocName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'geoLocName', None, None, ), # 1
  )

  def __init__(self, geoLocName=None,):
    self.geoLocName = geoLocName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.geoLocName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGeoLocationByName_args')
    if self.geoLocName is not None:
      oprot.writeFieldBegin('geoLocName', TType.STRING, 1)
      oprot.writeString(self.geoLocName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGeoLocationByName_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GeoLocation, GeoLocation.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GeoLocation()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGeoLocationByName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGeoLocationByNames_args:
  """
  Attributes:
   - geoLocNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'geoLocNames', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, geoLocNames=None,):
    self.geoLocNames = geoLocNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.geoLocNames = []
          (_etype509, _size506) = iprot.readListBegin()
          for _i510 in xrange(_size506):
            _elem511 = iprot.readString();
            self.geoLocNames.append(_elem511)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGeoLocationByNames_args')
    if self.geoLocNames is not None:
      oprot.writeFieldBegin('geoLocNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.geoLocNames))
      for iter512 in self.geoLocNames:
        oprot.writeString(iter512)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGeoLocationByNames_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(GeoLocation, GeoLocation.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype516, _size513) = iprot.readListBegin()
          for _i517 in xrange(_size513):
            _elem518 = GeoLocation()
            _elem518.read(iprot)
            self.success.append(_elem518)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGeoLocationByNames_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter519 in self.success:
        iter519.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addNodeAssignment_args:
  """
  Attributes:
   - nodeName
   - dbName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'nodeName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
  )

  def __init__(self, nodeName=None, dbName=None,):
    self.nodeName = nodeName
    self.dbName = dbName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.nodeName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addNodeAssignment_args')
    if self.nodeName is not None:
      oprot.writeFieldBegin('nodeName', TType.STRING, 1)
      oprot.writeString(self.nodeName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addNodeAssignment_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addNodeAssignment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteNodeAssignment_args:
  """
  Attributes:
   - nodeName
   - dbName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'nodeName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
  )

  def __init__(self, nodeName=None, dbName=None,):
    self.nodeName = nodeName
    self.dbName = dbName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.nodeName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteNodeAssignment_args')
    if self.nodeName is not None:
      oprot.writeFieldBegin('nodeName', TType.STRING, 1)
      oprot.writeString(self.nodeName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteNodeAssignment_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteNodeAssignment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNodes_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNodes_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNodes_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Node, Node.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype523, _size520) = iprot.readListBegin()
          for _i524 in xrange(_size520):
            _elem525 = Node()
            _elem525.read(iprot)
            self.success.append(_elem525)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNodes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter526 in self.success:
        iter526.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addUserAssignment_args:
  """
  Attributes:
   - roleName
   - dbName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
  )

  def __init__(self, roleName=None, dbName=None,):
    self.roleName = roleName
    self.dbName = dbName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addUserAssignment_args')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addUserAssignment_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addUserAssignment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteUserAssignment_args:
  """
  Attributes:
   - roleName
   - dbName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'roleName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
  )

  def __init__(self, roleName=None, dbName=None,):
    self.roleName = roleName
    self.dbName = dbName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.roleName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteUserAssignment_args')
    if self.roleName is not None:
      oprot.writeFieldBegin('roleName', TType.STRING, 1)
      oprot.writeString(self.roleName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteUserAssignment_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteUserAssignment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listUsers_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listUsers_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listUsers_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(User, User.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype530, _size527) = iprot.readListBegin()
          for _i531 in xrange(_size527):
            _elem532 = User()
            _elem532.read(iprot)
            self.success.append(_elem532)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter533 in self.success:
        iter533.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addRoleAssignment_args:
  """
  Attributes:
   - userName
   - dbName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'userName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
  )

  def __init__(self, userName=None, dbName=None,):
    self.userName = userName
    self.dbName = dbName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.userName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addRoleAssignment_args')
    if self.userName is not None:
      oprot.writeFieldBegin('userName', TType.STRING, 1)
      oprot.writeString(self.userName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addRoleAssignment_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addRoleAssignment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteRoleAssignment_args:
  """
  Attributes:
   - userName
   - dbName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'userName', None, None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
  )

  def __init__(self, userName=None, dbName=None,):
    self.userName = userName
    self.dbName = dbName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.userName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteRoleAssignment_args')
    if self.userName is not None:
      oprot.writeFieldBegin('userName', TType.STRING, 1)
      oprot.writeString(self.userName)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteRoleAssignment_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteRoleAssignment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listRoles_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listRoles_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listRoles_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Role, Role.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype537, _size534) = iprot.readListBegin()
          for _i538 in xrange(_size534):
            _elem539 = Role()
            _elem539.read(iprot)
            self.success.append(_elem539)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listRoles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter540 in self.success:
        iter540.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addNodeGroupAssignment_args:
  """
  Attributes:
   - ng
   - dbName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ng', (NodeGroup, NodeGroup.thrift_spec), None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
  )

  def __init__(self, ng=None, dbName=None,):
    self.ng = ng
    self.dbName = dbName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ng = NodeGroup()
          self.ng.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addNodeGroupAssignment_args')
    if self.ng is not None:
      oprot.writeFieldBegin('ng', TType.STRUCT, 1)
      self.ng.write(oprot)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addNodeGroupAssignment_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addNodeGroupAssignment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteNodeGroupAssignment_args:
  """
  Attributes:
   - ng
   - dbName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ng', (NodeGroup, NodeGroup.thrift_spec), None, ), # 1
    (2, TType.STRING, 'dbName', None, None, ), # 2
  )

  def __init__(self, ng=None, dbName=None,):
    self.ng = ng
    self.dbName = dbName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ng = NodeGroup()
          self.ng.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteNodeGroupAssignment_args')
    if self.ng is not None:
      oprot.writeFieldBegin('ng', TType.STRUCT, 1)
      self.ng.write(oprot)
      oprot.writeFieldEnd()
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 2)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteNodeGroupAssignment_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteNodeGroupAssignment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingPong_args:
  """
  Attributes:
   - str
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'str', None, None, ), # 1
  )

  def __init__(self, str=None,):
    self.str = str

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.str = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingPong_args')
    if self.str is not None:
      oprot.writeFieldBegin('str', TType.STRING, 1)
      oprot.writeString(self.str)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingPong_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingPong_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alterNodeGroup_args:
  """
  Attributes:
   - ng
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ng', (NodeGroup, NodeGroup.thrift_spec), None, ), # 1
  )

  def __init__(self, ng=None,):
    self.ng = ng

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ng = NodeGroup()
          self.ng.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alterNodeGroup_args')
    if self.ng is not None:
      oprot.writeFieldBegin('ng', TType.STRUCT, 1)
      self.ng.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alterNodeGroup_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alterNodeGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_database_args:
  """
  Attributes:
   - database
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'database', (Database, Database.thrift_spec), None, ), # 1
  )

  def __init__(self, database=None,):
    self.database = database

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.database = Database()
          self.database.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_database_args')
    if self.database is not None:
      oprot.writeFieldBegin('database', TType.STRUCT, 1)
      self.database.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_database_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_database_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_database_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_database_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Database, Database.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Database()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_database_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_database_args:
  """
  Attributes:
   - name
   - deleteData
   - cascade
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.BOOL, 'deleteData', None, None, ), # 2
    (3, TType.BOOL, 'cascade', None, None, ), # 3
  )

  def __init__(self, name=None, deleteData=None, cascade=None,):
    self.name = name
    self.deleteData = deleteData
    self.cascade = cascade

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.cascade = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_database_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 2)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    if self.cascade is not None:
      oprot.writeFieldBegin('cascade', TType.BOOL, 3)
      oprot.writeBool(self.cascade)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_database_result:
  """
  Attributes:
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, o1=None, o2=None, o3=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_databases_args:
  """
  Attributes:
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pattern', None, None, ), # 1
  )

  def __init__(self, pattern=None,):
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_databases_args')
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 1)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_databases_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype544, _size541) = iprot.readListBegin()
          for _i545 in xrange(_size541):
            _elem546 = iprot.readString();
            self.success.append(_elem546)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_databases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter547 in self.success:
        oprot.writeString(iter547)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_databases_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_databases_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_databases_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype551, _size548) = iprot.readListBegin()
          for _i552 in xrange(_size548):
            _elem553 = iprot.readString();
            self.success.append(_elem553)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_databases_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter554 in self.success:
        oprot.writeString(iter554)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_database_args:
  """
  Attributes:
   - dbname
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRUCT, 'db', (Database, Database.thrift_spec), None, ), # 2
  )

  def __init__(self, dbname=None, db=None,):
    self.dbname = dbname
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.db = Database()
          self.db.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_database_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRUCT, 2)
      self.db.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_database_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_database_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Type, Type.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Type()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_type_args:
  """
  Attributes:
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'type', (Type, Type.thrift_spec), None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.type = Type()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_type_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRUCT, 1)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_type_args:
  """
  Attributes:
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'type', None, None, ), # 1
  )

  def __init__(self, type=None,):
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_type_args')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 1)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_type_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_all_args:
  """
  Attributes:
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
  )

  def __init__(self, name=None,):
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_all_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_type_all_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(Type, Type.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype556, _vtype557, _size555 ) = iprot.readMapBegin() 
          for _i559 in xrange(_size555):
            _key560 = iprot.readString();
            _val561 = Type()
            _val561.read(iprot)
            self.success[_key560] = _val561
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_type_all_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter562,viter563 in self.success.items():
        oprot.writeString(kiter562)
        viter563.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_args:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_fields_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype567, _size564) = iprot.readListBegin()
          for _i568 in xrange(_size564):
            _elem569 = FieldSchema()
            _elem569.read(iprot)
            self.success.append(_elem569)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_fields_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter570 in self.success:
        iter570.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_args:
  """
  Attributes:
   - db_name
   - table_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'table_name', None, None, ), # 2
  )

  def __init__(self, db_name=None, table_name=None,):
    self.db_name = db_name
    self.table_name = table_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 2)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_schema_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype574, _size571) = iprot.readListBegin()
          for _i575 in xrange(_size571):
            _elem576 = FieldSchema()
            _elem576.read(iprot)
            self.success.append(_elem576)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = UnknownTableException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_schema_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter577 in self.success:
        iter577.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_args:
  """
  Attributes:
   - tbl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
  )

  def __init__(self, tbl=None,):
    self.tbl = tbl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_by_user_args:
  """
  Attributes:
   - tbl
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 2
  )

  def __init__(self, tbl=None, user=None,):
    self.tbl = tbl
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_by_user_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 2)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_by_user_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_by_user_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_with_environment_context_args:
  """
  Attributes:
   - tbl
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 2
  )

  def __init__(self, tbl=None, environment_context=None,):
    self.tbl = tbl
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_with_environment_context_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 2)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_table_with_environment_context_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = NoSuchObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_table_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_args:
  """
  Attributes:
   - dbname
   - name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.BOOL, 'deleteData', None, None, ), # 3
  )

  def __init__(self, dbname=None, name=None, deleteData=None,):
    self.dbname = dbname
    self.name = name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_table_result:
  """
  Attributes:
   - o1
   - o3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o3=None,):
    self.o1 = o1
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 2)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_args:
  """
  Attributes:
   - db_name
   - pattern
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'pattern', None, None, ), # 2
  )

  def __init__(self, db_name=None, pattern=None,):
    self.db_name = db_name
    self.pattern = pattern

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pattern = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.pattern is not None:
      oprot.writeFieldBegin('pattern', TType.STRING, 2)
      oprot.writeString(self.pattern)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_tables_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype581, _size578) = iprot.readListBegin()
          for _i582 in xrange(_size578):
            _elem583 = iprot.readString();
            self.success.append(_elem583)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_tables_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter584 in self.success:
        oprot.writeString(iter584)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_tables_args:
  """
  Attributes:
   - db_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
  )

  def __init__(self, db_name=None,):
    self.db_name = db_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_tables_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_tables_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype588, _size585) = iprot.readListBegin()
          for _i589 in xrange(_size585):
            _elem590 = iprot.readString();
            self.success.append(_elem590)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_tables_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter591 in self.success:
        oprot.writeString(iter591)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_args:
  """
  Attributes:
   - dbname
   - tbl_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
  )

  def __init__(self, dbname=None, tbl_name=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Table, Table.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Table()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_objects_by_name_args:
  """
  Attributes:
   - dbname
   - tbl_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.LIST, 'tbl_names', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, dbname=None, tbl_names=None,):
    self.dbname = dbname
    self.tbl_names = tbl_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tbl_names = []
          (_etype595, _size592) = iprot.readListBegin()
          for _i596 in xrange(_size592):
            _elem597 = iprot.readString();
            self.tbl_names.append(_elem597)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_objects_by_name_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_names is not None:
      oprot.writeFieldBegin('tbl_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.tbl_names))
      for iter598 in self.tbl_names:
        oprot.writeString(iter598)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_objects_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Table, Table.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype602, _size599) = iprot.readListBegin()
          for _i603 in xrange(_size599):
            _elem604 = Table()
            _elem604.read(iprot)
            self.success.append(_elem604)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_objects_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter605 in self.success:
        iter605.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_names_by_filter_args:
  """
  Attributes:
   - dbname
   - filter
   - max_tables
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'filter', None, None, ), # 2
    (3, TType.I16, 'max_tables', None, -1, ), # 3
  )

  def __init__(self, dbname=None, filter=None, max_tables=thrift_spec[3][4],):
    self.dbname = dbname
    self.filter = filter
    self.max_tables = max_tables

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.filter = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_tables = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_names_by_filter_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 2)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.max_tables is not None:
      oprot.writeFieldBegin('max_tables', TType.I16, 3)
      oprot.writeI16(self.max_tables)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_names_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype609, _size606) = iprot.readListBegin()
          for _i610 in xrange(_size606):
            _elem611 = iprot.readString();
            self.success.append(_elem611)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidOperationException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_names_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter612 in self.success:
        oprot.writeString(iter612)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - new_tbl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ), # 3
  )

  def __init__(self, dbname=None, tbl_name=None, new_tbl=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.new_tbl = new_tbl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_tbl = Table()
          self.new_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_tbl is not None:
      oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
      self.new_tbl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_with_environment_context_args:
  """
  Attributes:
   - dbname
   - tbl_name
   - new_tbl
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, dbname=None, tbl_name=None, new_tbl=None, environment_context=None,):
    self.dbname = dbname
    self.tbl_name = tbl_name
    self.new_tbl = new_tbl
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_tbl = Table()
          self.new_tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_with_environment_context_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_tbl is not None:
      oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
      self.new_tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_table_with_environment_context_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_table_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_args:
  """
  Attributes:
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 1
  )

  def __init__(self, new_part=None,):
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_args')
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_with_environment_context_args:
  """
  Attributes:
   - new_part
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 2
  )

  def __init__(self, new_part=None, environment_context=None,):
    self.new_part = new_part
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_with_environment_context_args')
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 2)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partition_with_environment_context_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partition_with_environment_context_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_args:
  """
  Attributes:
   - new_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'new_parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 1
  )

  def __init__(self, new_parts=None,):
    self.new_parts = new_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.new_parts = []
          (_etype616, _size613) = iprot.readListBegin()
          for _i617 in xrange(_size613):
            _elem618 = Partition()
            _elem618.read(iprot)
            self.new_parts.append(_elem618)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_args')
    if self.new_parts is not None:
      oprot.writeFieldBegin('new_parts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
      for iter619 in self.new_parts:
        iter619.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_partitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype623, _size620) = iprot.readListBegin()
          for _i624 in xrange(_size620):
            _elem625 = iprot.readString();
            self.part_vals.append(_elem625)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter626 in self.part_vals:
        oprot.writeString(iter626)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class append_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('append_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype630, _size627) = iprot.readListBegin()
          for _i631 in xrange(_size627):
            _elem632 = iprot.readString();
            self.part_vals.append(_elem632)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter633 in self.part_vals:
        oprot.writeString(iter633)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype637, _size634) = iprot.readListBegin()
          for _i638 in xrange(_size634):
            _elem639 = iprot.readString();
            self.part_vals.append(_elem639)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter640 in self.part_vals:
        oprot.writeString(iter640)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'user_name', None, None, ), # 4
    (5, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype644, _size641) = iprot.readListBegin()
          for _i645 in xrange(_size641):
            _elem646 = iprot.readString();
            self.part_vals.append(_elem646)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype650, _size647) = iprot.readListBegin()
          for _i651 in xrange(_size647):
            _elem652 = iprot.readString();
            self.group_names.append(_elem652)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter653 in self.part_vals:
        oprot.writeString(iter653)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 4)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter654 in self.group_names:
        oprot.writeString(iter654)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Partition()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype658, _size655) = iprot.readListBegin()
          for _i659 in xrange(_size655):
            _elem660 = Partition()
            _elem660.read(iprot)
            self.success.append(_elem660)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter661 in self.success:
        iter661.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
    (4, TType.STRING, 'user_name', None, None, ), # 4
    (5, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 5
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4], user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype665, _size662) = iprot.readListBegin()
          for _i666 in xrange(_size662):
            _elem667 = iprot.readString();
            self.group_names.append(_elem667)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 4)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter668 in self.group_names:
        oprot.writeString(iter668)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype672, _size669) = iprot.readListBegin()
          for _i673 in xrange(_size669):
            _elem674 = Partition()
            _elem674.read(iprot)
            self.success.append(_elem674)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter675 in self.success:
        iter675.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_parts', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 3)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype679, _size676) = iprot.readListBegin()
          for _i680 in xrange(_size676):
            _elem681 = iprot.readString();
            self.success.append(_elem681)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter682 in self.success:
        oprot.writeString(iter682)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype686, _size683) = iprot.readListBegin()
          for _i687 in xrange(_size683):
            _elem688 = iprot.readString();
            self.part_vals.append(_elem688)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter689 in self.part_vals:
        oprot.writeString(iter689)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype693, _size690) = iprot.readListBegin()
          for _i694 in xrange(_size690):
            _elem695 = Partition()
            _elem695.read(iprot)
            self.success.append(_elem695)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter696 in self.success:
        iter696.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_with_auth_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
    (5, TType.STRING, 'user_name', None, None, ), # 5
    (6, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 6
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4], user_name=None, group_names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype700, _size697) = iprot.readListBegin()
          for _i701 in xrange(_size697):
            _elem702 = iprot.readString();
            self.part_vals.append(_elem702)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype706, _size703) = iprot.readListBegin()
          for _i707 in xrange(_size703):
            _elem708 = iprot.readString();
            self.group_names.append(_elem708)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_with_auth_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter709 in self.part_vals:
        oprot.writeString(iter709)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 5)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter710 in self.group_names:
        oprot.writeString(iter710)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_ps_with_auth_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype714, _size711) = iprot.readListBegin()
          for _i715 in xrange(_size711):
            _elem716 = Partition()
            _elem716.read(iprot)
            self.success.append(_elem716)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_ps_with_auth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter717 in self.success:
        iter717.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_ps_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype721, _size718) = iprot.readListBegin()
          for _i722 in xrange(_size718):
            _elem723 = iprot.readString();
            self.part_vals.append(_elem723)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_ps_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter724 in self.part_vals:
        oprot.writeString(iter724)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_names_ps_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype728, _size725) = iprot.readListBegin()
          for _i729 in xrange(_size725):
            _elem730 = iprot.readString();
            self.success.append(_elem730)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_names_ps_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter731 in self.success:
        oprot.writeString(iter731)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_filter_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - filter
   - max_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'filter', None, None, ), # 3
    (4, TType.I16, 'max_parts', None, -1, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, filter=None, max_parts=thrift_spec[4][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.filter = filter
    self.max_parts = max_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.filter = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.max_parts = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_filter_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 3)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.max_parts is not None:
      oprot.writeFieldBegin('max_parts', TType.I16, 4)
      oprot.writeI16(self.max_parts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_filter_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype735, _size732) = iprot.readListBegin()
          for _i736 in xrange(_size732):
            _elem737 = Partition()
            _elem737.read(iprot)
            self.success.append(_elem737)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_filter_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter738 in self.success:
        iter738.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'names', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, names=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.names = names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.names = []
          (_etype742, _size739) = iprot.readListBegin()
          for _i743 in xrange(_size739):
            _elem744 = iprot.readString();
            self.names.append(_elem744)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.names is not None:
      oprot.writeFieldBegin('names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.names))
      for iter745 in self.names:
        oprot.writeString(iter745)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partitions_by_names_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype749, _size746) = iprot.readListBegin()
          for _i750 in xrange(_size746):
            _elem751 = Partition()
            _elem751.read(iprot)
            self.success.append(_elem751)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partitions_by_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter752 in self.success:
        iter752.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, new_part=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partitions_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_parts
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'new_parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, new_parts=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_parts = new_parts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.new_parts = []
          (_etype756, _size753) = iprot.readListBegin()
          for _i757 in xrange(_size753):
            _elem758 = Partition()
            _elem758.read(iprot)
            self.new_parts.append(_elem758)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partitions_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_parts is not None:
      oprot.writeFieldBegin('new_parts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
      for iter759 in self.new_parts:
        iter759.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partitions_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partitions_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_with_environment_context_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - new_part
   - environment_context
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, new_part=None, environment_context=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.new_part = new_part
    self.environment_context = environment_context

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.environment_context = EnvironmentContext()
          self.environment_context.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_with_environment_context_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    if self.environment_context is not None:
      oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
      self.environment_context.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_partition_with_environment_context_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_partition_with_environment_context_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_partition_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - new_part
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.LIST, 'part_vals', (TType.STRING,None), None, ), # 3
    (4, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, new_part=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.new_part = new_part

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.part_vals = []
          (_etype763, _size760) = iprot.readListBegin()
          for _i764 in xrange(_size760):
            _elem765 = iprot.readString();
            self.part_vals.append(_elem765)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.new_part = Partition()
          self.new_part.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_partition_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.part_vals))
      for iter766 in self.part_vals:
        oprot.writeString(iter766)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.new_part is not None:
      oprot.writeFieldBegin('new_part', TType.STRUCT, 4)
      self.new_part.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rename_partition_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rename_partition_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_config_value_args:
  """
  Attributes:
   - name
   - defaultValue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'defaultValue', None, None, ), # 2
  )

  def __init__(self, name=None, defaultValue=None,):
    self.name = name
    self.defaultValue = defaultValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.defaultValue = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_config_value_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.defaultValue is not None:
      oprot.writeFieldBegin('defaultValue', TType.STRING, 2)
      oprot.writeString(self.defaultValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_config_value_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (ConfigValSecurityException, ConfigValSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = ConfigValSecurityException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_config_value_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_vals_args:
  """
  Attributes:
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'part_name', None, None, ), # 1
  )

  def __init__(self, part_name=None,):
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_vals_args')
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 1)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_vals_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype770, _size767) = iprot.readListBegin()
          for _i771 in xrange(_size767):
            _elem772 = iprot.readString();
            self.success.append(_elem772)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_vals_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter773 in self.success:
        oprot.writeString(iter773)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_spec_args:
  """
  Attributes:
   - part_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'part_name', None, None, ), # 1
  )

  def __init__(self, part_name=None,):
    self.part_name = part_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_spec_args')
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 1)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class partition_name_to_spec_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype775, _vtype776, _size774 ) = iprot.readMapBegin() 
          for _i778 in xrange(_size774):
            _key779 = iprot.readString();
            _val780 = iprot.readString();
            self.success[_key779] = _val780
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('partition_name_to_spec_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter781,viter782 in self.success.items():
        oprot.writeString(kiter781)
        oprot.writeString(viter782)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markPartitionForEvent_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - eventType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.MAP, 'part_vals', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.I32, 'eventType', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.eventType = eventType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.part_vals = {}
          (_ktype784, _vtype785, _size783 ) = iprot.readMapBegin() 
          for _i787 in xrange(_size783):
            _key788 = iprot.readString();
            _val789 = iprot.readString();
            self.part_vals[_key788] = _val789
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.eventType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markPartitionForEvent_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
      for kiter790,viter791 in self.part_vals.items():
        oprot.writeString(kiter790)
        oprot.writeString(viter791)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 4)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markPartitionForEvent_result:
  """
  Attributes:
   - o1
   - o2
   - o3
   - o4
   - o5
   - o6
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'o5', (UnknownPartitionException, UnknownPartitionException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'o6', (InvalidPartitionException, InvalidPartitionException.thrift_spec), None, ), # 6
  )

  def __init__(self, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4
    self.o5 = o5
    self.o6 = o6

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = UnknownTableException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.o5 = UnknownPartitionException()
          self.o5.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.o6 = InvalidPartitionException()
          self.o6.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markPartitionForEvent_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    if self.o5 is not None:
      oprot.writeFieldBegin('o5', TType.STRUCT, 5)
      self.o5.write(oprot)
      oprot.writeFieldEnd()
    if self.o6 is not None:
      oprot.writeFieldBegin('o6', TType.STRUCT, 6)
      self.o6.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPartitionMarkedForEvent_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_vals
   - eventType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.MAP, 'part_vals', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.I32, 'eventType', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_vals = part_vals
    self.eventType = eventType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.part_vals = {}
          (_ktype793, _vtype794, _size792 ) = iprot.readMapBegin() 
          for _i796 in xrange(_size792):
            _key797 = iprot.readString();
            _val798 = iprot.readString();
            self.part_vals[_key797] = _val798
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.eventType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPartitionMarkedForEvent_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_vals is not None:
      oprot.writeFieldBegin('part_vals', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
      for kiter799,viter800 in self.part_vals.items():
        oprot.writeString(kiter799)
        oprot.writeString(viter800)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 4)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPartitionMarkedForEvent_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
   - o5
   - o6
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (UnknownTableException, UnknownTableException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'o5', (UnknownPartitionException, UnknownPartitionException.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'o6', (InvalidPartitionException, InvalidPartitionException.thrift_spec), None, ), # 6
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4
    self.o5 = o5
    self.o6 = o6

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = UnknownDBException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = UnknownTableException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.o5 = UnknownPartitionException()
          self.o5.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.o6 = InvalidPartitionException()
          self.o6.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPartitionMarkedForEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    if self.o5 is not None:
      oprot.writeFieldBegin('o5', TType.STRUCT, 5)
      self.o5.write(oprot)
      oprot.writeFieldEnd()
    if self.o6 is not None:
      oprot.writeFieldBegin('o6', TType.STRUCT, 6)
      self.o6.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_index_args:
  """
  Attributes:
   - new_index
   - index_table
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'new_index', (Index, Index.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'index_table', (Table, Table.thrift_spec), None, ), # 2
  )

  def __init__(self, new_index=None, index_table=None,):
    self.new_index = new_index
    self.index_table = index_table

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.new_index = Index()
          self.new_index.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.index_table = Table()
          self.index_table.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_index_args')
    if self.new_index is not None:
      oprot.writeFieldBegin('new_index', TType.STRUCT, 1)
      self.new_index.write(oprot)
      oprot.writeFieldEnd()
    if self.index_table is not None:
      oprot.writeFieldBegin('index_table', TType.STRUCT, 2)
      self.index_table.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_index_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Index()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = AlreadyExistsException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_index_args:
  """
  Attributes:
   - dbname
   - base_tbl_name
   - idx_name
   - new_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbname', None, None, ), # 1
    (2, TType.STRING, 'base_tbl_name', None, None, ), # 2
    (3, TType.STRING, 'idx_name', None, None, ), # 3
    (4, TType.STRUCT, 'new_idx', (Index, Index.thrift_spec), None, ), # 4
  )

  def __init__(self, dbname=None, base_tbl_name=None, idx_name=None, new_idx=None,):
    self.dbname = dbname
    self.base_tbl_name = base_tbl_name
    self.idx_name = idx_name
    self.new_idx = new_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbname = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.base_tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.idx_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.new_idx = Index()
          self.new_idx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_index_args')
    if self.dbname is not None:
      oprot.writeFieldBegin('dbname', TType.STRING, 1)
      oprot.writeString(self.dbname)
      oprot.writeFieldEnd()
    if self.base_tbl_name is not None:
      oprot.writeFieldBegin('base_tbl_name', TType.STRING, 2)
      oprot.writeString(self.base_tbl_name)
      oprot.writeFieldEnd()
    if self.idx_name is not None:
      oprot.writeFieldBegin('idx_name', TType.STRING, 3)
      oprot.writeString(self.idx_name)
      oprot.writeFieldEnd()
    if self.new_idx is not None:
      oprot.writeFieldBegin('new_idx', TType.STRUCT, 4)
      self.new_idx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_index_result:
  """
  Attributes:
   - o1
   - o2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, o1=None, o2=None,):
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_index_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_index_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - index_name
   - deleteData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'index_name', None, None, ), # 3
    (4, TType.BOOL, 'deleteData', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, index_name=None, deleteData=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.index_name = index_name
    self.deleteData = deleteData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.deleteData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_index_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.index_name is not None:
      oprot.writeFieldBegin('index_name', TType.STRING, 3)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.deleteData is not None:
      oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
      oprot.writeBool(self.deleteData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_index_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_index_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_by_name_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - index_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'index_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, index_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.index_name = index_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_by_name_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.index_name is not None:
      oprot.writeFieldBegin('index_name', TType.STRING, 3)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Index()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_indexes_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_indexes_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes is not None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_indexes_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Index, Index.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype804, _size801) = iprot.readListBegin()
          for _i805 in xrange(_size801):
            _elem806 = Index()
            _elem806.read(iprot)
            self.success.append(_elem806)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_indexes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter807 in self.success:
        iter807.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_names_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - max_indexes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.I16, 'max_indexes', None, -1, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.max_indexes = max_indexes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.max_indexes = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_names_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.max_indexes is not None:
      oprot.writeFieldBegin('max_indexes', TType.I16, 3)
      oprot.writeI16(self.max_indexes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_index_names_result:
  """
  Attributes:
   - success
   - o2
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o2=None,):
    self.success = success
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype811, _size808) = iprot.readListBegin()
          for _i812 in xrange(_size808):
            _elem813 = iprot.readString();
            self.success.append(_elem813)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_index_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter814 in self.success:
        oprot.writeString(iter814)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 1)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_table_column_statistics_args:
  """
  Attributes:
   - stats_obj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'stats_obj', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 1
  )

  def __init__(self, stats_obj=None,):
    self.stats_obj = stats_obj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.stats_obj = ColumnStatistics()
          self.stats_obj.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_table_column_statistics_args')
    if self.stats_obj is not None:
      oprot.writeFieldBegin('stats_obj', TType.STRUCT, 1)
      self.stats_obj.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_table_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_table_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_partition_column_statistics_args:
  """
  Attributes:
   - stats_obj
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'stats_obj', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 1
  )

  def __init__(self, stats_obj=None,):
    self.stats_obj = stats_obj

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.stats_obj = ColumnStatistics()
          self.stats_obj.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_partition_column_statistics_args')
    if self.stats_obj is not None:
      oprot.writeFieldBegin('stats_obj', TType.STRUCT, 1)
      self.stats_obj.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_partition_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_partition_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'col_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 3)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_table_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ColumnStatistics()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidInputException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_table_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.STRING, 'col_name', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 4)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_partition_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ColumnStatistics()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidInputException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidObjectException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_partition_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_partition_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - part_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'part_name', None, None, ), # 3
    (4, TType.STRING, 'col_name', None, None, ), # 4
  )

  def __init__(self, db_name=None, tbl_name=None, part_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.part_name = part_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.part_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_partition_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.part_name is not None:
      oprot.writeFieldBegin('part_name', TType.STRING, 3)
      oprot.writeString(self.part_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 4)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_partition_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_partition_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_table_column_statistics_args:
  """
  Attributes:
   - db_name
   - tbl_name
   - col_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db_name', None, None, ), # 1
    (2, TType.STRING, 'tbl_name', None, None, ), # 2
    (3, TType.STRING, 'col_name', None, None, ), # 3
  )

  def __init__(self, db_name=None, tbl_name=None, col_name=None,):
    self.db_name = db_name
    self.tbl_name = tbl_name
    self.col_name = col_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tbl_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.col_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_table_column_statistics_args')
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 1)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
      oprot.writeString(self.tbl_name)
      oprot.writeFieldEnd()
    if self.col_name is not None:
      oprot.writeFieldBegin('col_name', TType.STRING, 3)
      oprot.writeString(self.col_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_table_column_statistics_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
   - o4
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3
    self.o4 = o4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = InvalidObjectException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.o4 = InvalidInputException()
          self.o4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_table_column_statistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    if self.o4 is not None:
      oprot.writeFieldBegin('o4', TType.STRUCT, 4)
      self.o4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_user_args:
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_user_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 1)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_user_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_user_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_user_args:
  """
  Attributes:
   - user_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user_name', None, None, ), # 1
  )

  def __init__(self, user_name=None,):
    self.user_name = user_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_user_args')
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 1)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_user_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_user_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modify_user_args:
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modify_user_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 1)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modify_user_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modify_user_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_users_names_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_users_names_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_users_names_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype818, _size815) = iprot.readListBegin()
          for _i819 in xrange(_size815):
            _elem820 = iprot.readString();
            self.success.append(_elem820)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_users_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter821 in self.success:
        oprot.writeString(iter821)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_users_args:
  """
  Attributes:
   - db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'db', (Database, Database.thrift_spec), None, ), # 1
  )

  def __init__(self, db=None,):
    self.db = db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.db = Database()
          self.db.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_users_args')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRUCT, 1)
      self.db.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_users_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype825, _size822) = iprot.readListBegin()
          for _i826 in xrange(_size822):
            _elem827 = iprot.readString();
            self.success.append(_elem827)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_users_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter828 in self.success:
        oprot.writeString(iter828)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authentication_args:
  """
  Attributes:
   - user_name
   - passwd
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user_name', None, None, ), # 1
    (2, TType.STRING, 'passwd', None, None, ), # 2
  )

  def __init__(self, user_name=None, passwd=None,):
    self.user_name = user_name
    self.passwd = passwd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.passwd = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authentication_args')
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 1)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.passwd is not None:
      oprot.writeFieldBegin('passwd', TType.STRING, 2)
      oprot.writeString(self.passwd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authentication_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authentication_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_authority_check_args:
  """
  Attributes:
   - user
   - tbl
   - ops
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'user', (User, User.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 2
    (3, TType.LIST, 'ops', (TType.I32,None), None, ), # 3
  )

  def __init__(self, user=None, tbl=None, ops=None,):
    self.user = user
    self.tbl = tbl
    self.ops = ops

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.user = User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.ops = []
          (_etype832, _size829) = iprot.readListBegin()
          for _i833 in xrange(_size829):
            _elem834 = iprot.readI32();
            self.ops.append(_elem834)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_authority_check_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 1)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 2)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.ops is not None:
      oprot.writeFieldBegin('ops', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.ops))
      for iter835 in self.ops:
        oprot.writeI32(iter835)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class user_authority_check_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('user_authority_check_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_role_args:
  """
  Attributes:
   - role
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'role', (Role, Role.thrift_spec), None, ), # 1
  )

  def __init__(self, role=None,):
    self.role = role

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.role = Role()
          self.role.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_role_args')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.STRUCT, 1)
      self.role.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_role_args:
  """
  Attributes:
   - role_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
  )

  def __init__(self, role_name=None,):
    self.role_name = role_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drop_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drop_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_names_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_names_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_role_names_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype839, _size836) = iprot.readListBegin()
          for _i840 in xrange(_size836):
            _elem841 = iprot.readString();
            self.success.append(_elem841)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_role_names_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter842 in self.success:
        oprot.writeString(iter842)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_role_args:
  """
  Attributes:
   - role_name
   - principal_name
   - principal_type
   - grantor
   - grantorType
   - grant_option
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
    (2, TType.STRING, 'principal_name', None, None, ), # 2
    (3, TType.I32, 'principal_type', None, None, ), # 3
    (4, TType.STRING, 'grantor', None, None, ), # 4
    (5, TType.I32, 'grantorType', None, None, ), # 5
    (6, TType.BOOL, 'grant_option', None, None, ), # 6
  )

  def __init__(self, role_name=None, principal_name=None, principal_type=None, grantor=None, grantorType=None, grant_option=None,):
    self.role_name = role_name
    self.principal_name = principal_name
    self.principal_type = principal_type
    self.grantor = grantor
    self.grantorType = grantorType
    self.grant_option = grant_option

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.grantor = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.grantorType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.grant_option = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 2)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 3)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    if self.grantor is not None:
      oprot.writeFieldBegin('grantor', TType.STRING, 4)
      oprot.writeString(self.grantor)
      oprot.writeFieldEnd()
    if self.grantorType is not None:
      oprot.writeFieldBegin('grantorType', TType.I32, 5)
      oprot.writeI32(self.grantorType)
      oprot.writeFieldEnd()
    if self.grant_option is not None:
      oprot.writeFieldBegin('grant_option', TType.BOOL, 6)
      oprot.writeBool(self.grant_option)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_role_args:
  """
  Attributes:
   - role_name
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'role_name', None, None, ), # 1
    (2, TType.STRING, 'principal_name', None, None, ), # 2
    (3, TType.I32, 'principal_type', None, None, ), # 3
  )

  def __init__(self, role_name=None, principal_name=None, principal_type=None,):
    self.role_name = role_name
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.role_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_role_args')
    if self.role_name is not None:
      oprot.writeFieldBegin('role_name', TType.STRING, 1)
      oprot.writeString(self.role_name)
      oprot.writeFieldEnd()
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 2)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 3)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_role_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_role_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_roles_args:
  """
  Attributes:
   - principal_name
   - principal_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
  )

  def __init__(self, principal_name=None, principal_type=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_roles_args')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_roles_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Role, Role.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype846, _size843) = iprot.readListBegin()
          for _i847 in xrange(_size843):
            _elem848 = Role()
            _elem848.read(iprot)
            self.success.append(_elem848)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_roles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter849 in self.success:
        iter849.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_privilege_set_args:
  """
  Attributes:
   - hiveObject
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 1
    (2, TType.STRING, 'user_name', None, None, ), # 2
    (3, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, hiveObject=None, user_name=None, group_names=None,):
    self.hiveObject = hiveObject
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype853, _size850) = iprot.readListBegin()
          for _i854 in xrange(_size850):
            _elem855 = iprot.readString();
            self.group_names.append(_elem855)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_privilege_set_args')
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 2)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter856 in self.group_names:
        oprot.writeString(iter856)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_privilege_set_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PrincipalPrivilegeSet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_privilege_set_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_privileges_args:
  """
  Attributes:
   - principal_name
   - principal_type
   - hiveObject
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'principal_name', None, None, ), # 1
    (2, TType.I32, 'principal_type', None, None, ), # 2
    (3, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ), # 3
  )

  def __init__(self, principal_name=None, principal_type=None, hiveObject=None,):
    self.principal_name = principal_name
    self.principal_type = principal_type
    self.hiveObject = hiveObject

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.principal_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.principal_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.hiveObject = HiveObjectRef()
          self.hiveObject.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_privileges_args')
    if self.principal_name is not None:
      oprot.writeFieldBegin('principal_name', TType.STRING, 1)
      oprot.writeString(self.principal_name)
      oprot.writeFieldEnd()
    if self.principal_type is not None:
      oprot.writeFieldBegin('principal_type', TType.I32, 2)
      oprot.writeI32(self.principal_type)
      oprot.writeFieldEnd()
    if self.hiveObject is not None:
      oprot.writeFieldBegin('hiveObject', TType.STRUCT, 3)
      self.hiveObject.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(HiveObjectPrivilege, HiveObjectPrivilege.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype860, _size857) = iprot.readListBegin()
          for _i861 in xrange(_size857):
            _elem862 = HiveObjectPrivilege()
            _elem862.read(iprot)
            self.success.append(_elem862)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter863 in self.success:
        iter863.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_privileges_args:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_privileges_args')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class grant_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('grant_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_privileges_args:
  """
  Attributes:
   - privileges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ), # 1
  )

  def __init__(self, privileges=None,):
    self.privileges = privileges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.privileges = PrivilegeBag()
          self.privileges.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_privileges_args')
    if self.privileges is not None:
      oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
      self.privileges.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revoke_privileges_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revoke_privileges_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_ugi_args:
  """
  Attributes:
   - user_name
   - group_names
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'user_name', None, None, ), # 1
    (2, TType.LIST, 'group_names', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, user_name=None, group_names=None,):
    self.user_name = user_name
    self.group_names = group_names

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.group_names = []
          (_etype867, _size864) = iprot.readListBegin()
          for _i868 in xrange(_size864):
            _elem869 = iprot.readString();
            self.group_names.append(_elem869)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_ugi_args')
    if self.user_name is not None:
      oprot.writeFieldBegin('user_name', TType.STRING, 1)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.group_names is not None:
      oprot.writeFieldBegin('group_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.group_names))
      for iter870 in self.group_names:
        oprot.writeString(iter870)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_ugi_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype874, _size871) = iprot.readListBegin()
          for _i875 in xrange(_size871):
            _elem876 = iprot.readString();
            self.success.append(_elem876)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_ugi_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter877 in self.success:
        oprot.writeString(iter877)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_delegation_token_args:
  """
  Attributes:
   - token_owner
   - renewer_kerberos_principal_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_owner', None, None, ), # 1
    (2, TType.STRING, 'renewer_kerberos_principal_name', None, None, ), # 2
  )

  def __init__(self, token_owner=None, renewer_kerberos_principal_name=None,):
    self.token_owner = token_owner
    self.renewer_kerberos_principal_name = renewer_kerberos_principal_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_owner = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.renewer_kerberos_principal_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_delegation_token_args')
    if self.token_owner is not None:
      oprot.writeFieldBegin('token_owner', TType.STRING, 1)
      oprot.writeString(self.token_owner)
      oprot.writeFieldEnd()
    if self.renewer_kerberos_principal_name is not None:
      oprot.writeFieldBegin('renewer_kerberos_principal_name', TType.STRING, 2)
      oprot.writeString(self.renewer_kerberos_principal_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_delegation_token_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_delegation_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renew_delegation_token_args:
  """
  Attributes:
   - token_str_form
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_str_form', None, None, ), # 1
  )

  def __init__(self, token_str_form=None,):
    self.token_str_form = token_str_form

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_str_form = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renew_delegation_token_args')
    if self.token_str_form is not None:
      oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
      oprot.writeString(self.token_str_form)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class renew_delegation_token_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('renew_delegation_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancel_delegation_token_args:
  """
  Attributes:
   - token_str_form
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'token_str_form', None, None, ), # 1
  )

  def __init__(self, token_str_form=None,):
    self.token_str_form = token_str_form

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.token_str_form = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancel_delegation_token_args')
    if self.token_str_form is not None:
      oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
      oprot.writeString(self.token_str_form)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cancel_delegation_token_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cancel_delegation_token_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_file_args:
  """
  Attributes:
   - node_name
   - repnr
   - db_name
   - table_name
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node_name', None, None, ), # 1
    (2, TType.I32, 'repnr', None, None, ), # 2
    (3, TType.STRING, 'db_name', None, None, ), # 3
    (4, TType.STRING, 'table_name', None, None, ), # 4
    (5, TType.LIST, 'values', (TType.STRUCT,(SplitValue, SplitValue.thrift_spec)), None, ), # 5
  )

  def __init__(self, node_name=None, repnr=None, db_name=None, table_name=None, values=None,):
    self.node_name = node_name
    self.repnr = repnr
    self.db_name = db_name
    self.table_name = table_name
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.repnr = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.values = []
          (_etype881, _size878) = iprot.readListBegin()
          for _i882 in xrange(_size878):
            _elem883 = SplitValue()
            _elem883.read(iprot)
            self.values.append(_elem883)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_file_args')
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 1)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    if self.repnr is not None:
      oprot.writeFieldBegin('repnr', TType.I32, 2)
      oprot.writeI32(self.repnr)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 3)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 4)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter884 in self.values:
        iter884.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_file_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SFile, SFile.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (FileOperationException, FileOperationException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SFile()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = FileOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_file_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_file_by_policy_args:
  """
  Attributes:
   - policy
   - repnr
   - db_name
   - table_name
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'policy', (CreatePolicy, CreatePolicy.thrift_spec), None, ), # 1
    (2, TType.I32, 'repnr', None, None, ), # 2
    (3, TType.STRING, 'db_name', None, None, ), # 3
    (4, TType.STRING, 'table_name', None, None, ), # 4
    (5, TType.LIST, 'values', (TType.STRUCT,(SplitValue, SplitValue.thrift_spec)), None, ), # 5
  )

  def __init__(self, policy=None, repnr=None, db_name=None, table_name=None, values=None,):
    self.policy = policy
    self.repnr = repnr
    self.db_name = db_name
    self.table_name = table_name
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.policy = CreatePolicy()
          self.policy.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.repnr = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.db_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.table_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.values = []
          (_etype888, _size885) = iprot.readListBegin()
          for _i889 in xrange(_size885):
            _elem890 = SplitValue()
            _elem890.read(iprot)
            self.values.append(_elem890)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_file_by_policy_args')
    if self.policy is not None:
      oprot.writeFieldBegin('policy', TType.STRUCT, 1)
      self.policy.write(oprot)
      oprot.writeFieldEnd()
    if self.repnr is not None:
      oprot.writeFieldBegin('repnr', TType.I32, 2)
      oprot.writeI32(self.repnr)
      oprot.writeFieldEnd()
    if self.db_name is not None:
      oprot.writeFieldBegin('db_name', TType.STRING, 3)
      oprot.writeString(self.db_name)
      oprot.writeFieldEnd()
    if self.table_name is not None:
      oprot.writeFieldBegin('table_name', TType.STRING, 4)
      oprot.writeString(self.table_name)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter891 in self.values:
        iter891.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_file_by_policy_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SFile, SFile.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (FileOperationException, FileOperationException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SFile()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = FileOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_file_by_policy_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_file_repnr_args:
  """
  Attributes:
   - fid
   - repnr
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'fid', None, None, ), # 1
    (2, TType.I32, 'repnr', None, None, ), # 2
  )

  def __init__(self, fid=None, repnr=None,):
    self.fid = fid
    self.repnr = repnr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.fid = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.repnr = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_file_repnr_args')
    if self.fid is not None:
      oprot.writeFieldBegin('fid', TType.I64, 1)
      oprot.writeI64(self.fid)
      oprot.writeFieldEnd()
    if self.repnr is not None:
      oprot.writeFieldBegin('repnr', TType.I32, 2)
      oprot.writeI32(self.repnr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_file_repnr_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (FileOperationException, FileOperationException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = FileOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_file_repnr_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reopen_file_args:
  """
  Attributes:
   - fid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'fid', None, None, ), # 1
  )

  def __init__(self, fid=None,):
    self.fid = fid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.fid = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reopen_file_args')
    if self.fid is not None:
      oprot.writeFieldBegin('fid', TType.I64, 1)
      oprot.writeI64(self.fid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reopen_file_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (FileOperationException, FileOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = FileOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reopen_file_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class close_file_args:
  """
  Attributes:
   - file
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file', (SFile, SFile.thrift_spec), None, ), # 1
  )

  def __init__(self, file=None,):
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file = SFile()
          self.file.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('close_file_args')
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRUCT, 1)
      self.file.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class close_file_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (FileOperationException, FileOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = FileOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('close_file_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class online_filelocation_args:
  """
  Attributes:
   - file
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file', (SFile, SFile.thrift_spec), None, ), # 1
  )

  def __init__(self, file=None,):
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file = SFile()
          self.file.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('online_filelocation_args')
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRUCT, 1)
      self.file.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class online_filelocation_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('online_filelocation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class offline_filelocation_args:
  """
  Attributes:
   - sfl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sfl', (SFileLocation, SFileLocation.thrift_spec), None, ), # 1
  )

  def __init__(self, sfl=None,):
    self.sfl = sfl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sfl = SFileLocation()
          self.sfl.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('offline_filelocation_args')
    if self.sfl is not None:
      oprot.writeFieldBegin('sfl', TType.STRUCT, 1)
      self.sfl.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class offline_filelocation_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('offline_filelocation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_loadstatus_bad_args:
  """
  Attributes:
   - fid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'fid', None, None, ), # 1
  )

  def __init__(self, fid=None,):
    self.fid = fid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.fid = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_loadstatus_bad_args')
    if self.fid is not None:
      oprot.writeFieldBegin('fid', TType.I64, 1)
      oprot.writeI64(self.fid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_loadstatus_bad_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_loadstatus_bad_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class toggle_safemode_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('toggle_safemode_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class toggle_safemode_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('toggle_safemode_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_by_id_args:
  """
  Attributes:
   - fid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'fid', None, None, ), # 1
  )

  def __init__(self, fid=None,):
    self.fid = fid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.fid = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_by_id_args')
    if self.fid is not None:
      oprot.writeFieldBegin('fid', TType.I64, 1)
      oprot.writeI64(self.fid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_by_id_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SFile, SFile.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (FileOperationException, FileOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SFile()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = FileOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_by_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_by_name_args:
  """
  Attributes:
   - node
   - devid
   - location
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node', None, None, ), # 1
    (2, TType.STRING, 'devid', None, None, ), # 2
    (3, TType.STRING, 'location', None, None, ), # 3
  )

  def __init__(self, node=None, devid=None, location=None,):
    self.node = node
    self.devid = devid
    self.location = location

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.devid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.location = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_by_name_args')
    if self.node is not None:
      oprot.writeFieldBegin('node', TType.STRING, 1)
      oprot.writeString(self.node)
      oprot.writeFieldEnd()
    if self.devid is not None:
      oprot.writeFieldBegin('devid', TType.STRING, 2)
      oprot.writeString(self.devid)
      oprot.writeFieldEnd()
    if self.location is not None:
      oprot.writeFieldBegin('location', TType.STRING, 3)
      oprot.writeString(self.location)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_file_by_name_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SFile, SFile.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (FileOperationException, FileOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SFile()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = FileOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_file_by_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rm_file_logical_args:
  """
  Attributes:
   - file
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file', (SFile, SFile.thrift_spec), None, ), # 1
  )

  def __init__(self, file=None,):
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file = SFile()
          self.file.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rm_file_logical_args')
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRUCT, 1)
      self.file.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rm_file_logical_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (FileOperationException, FileOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = FileOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rm_file_logical_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class restore_file_args:
  """
  Attributes:
   - file
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file', (SFile, SFile.thrift_spec), None, ), # 1
  )

  def __init__(self, file=None,):
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file = SFile()
          self.file.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('restore_file_args')
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRUCT, 1)
      self.file.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class restore_file_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (FileOperationException, FileOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = FileOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('restore_file_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rm_file_physical_args:
  """
  Attributes:
   - file
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'file', (SFile, SFile.thrift_spec), None, ), # 1
  )

  def __init__(self, file=None,):
    self.file = file

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.file = SFile()
          self.file.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rm_file_physical_args')
    if self.file is not None:
      oprot.writeFieldBegin('file', TType.STRUCT, 1)
      self.file.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rm_file_physical_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (FileOperationException, FileOperationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = FileOperationException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rm_file_physical_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_node_args:
  """
  Attributes:
   - node_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node_name', None, None, ), # 1
  )

  def __init__(self, node_name=None,):
    self.node_name = node_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_node_args')
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 1)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_node_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Node, Node.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Node()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_node_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_node_args:
  """
  Attributes:
   - node_name
   - ipl
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node_name', None, None, ), # 1
    (2, TType.LIST, 'ipl', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, node_name=None, ipl=None,):
    self.node_name = node_name
    self.ipl = ipl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.ipl = []
          (_etype895, _size892) = iprot.readListBegin()
          for _i896 in xrange(_size892):
            _elem897 = iprot.readString();
            self.ipl.append(_elem897)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_node_args')
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 1)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    if self.ipl is not None:
      oprot.writeFieldBegin('ipl', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.ipl))
      for iter898 in self.ipl:
        oprot.writeString(iter898)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_node_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Node, Node.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Node()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_node_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class del_node_args:
  """
  Attributes:
   - node_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node_name', None, None, ), # 1
  )

  def __init__(self, node_name=None,):
    self.node_name = node_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('del_node_args')
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 1)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class del_node_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('del_node_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_device_args:
  """
  Attributes:
   - devid
   - prop
   - node_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'devid', None, None, ), # 1
    (2, TType.I32, 'prop', None, None, ), # 2
    (3, TType.STRING, 'node_name', None, None, ), # 3
  )

  def __init__(self, devid=None, prop=None, node_name=None,):
    self.devid = devid
    self.prop = prop
    self.node_name = node_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.devid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.prop = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_device_args')
    if self.devid is not None:
      oprot.writeFieldBegin('devid', TType.STRING, 1)
      oprot.writeString(self.devid)
      oprot.writeFieldEnd()
    if self.prop is not None:
      oprot.writeFieldBegin('prop', TType.I32, 2)
      oprot.writeI32(self.prop)
      oprot.writeFieldEnd()
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 3)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_device_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Device, Device.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Device()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_device_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_device_args:
  """
  Attributes:
   - devid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'devid', None, None, ), # 1
  )

  def __init__(self, devid=None,):
    self.devid = devid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.devid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_device_args')
    if self.devid is not None:
      oprot.writeFieldBegin('devid', TType.STRING, 1)
      oprot.writeString(self.devid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_device_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Device, Device.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Device()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_device_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class del_device_args:
  """
  Attributes:
   - devid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'devid', None, None, ), # 1
  )

  def __init__(self, devid=None,):
    self.devid = devid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.devid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('del_device_args')
    if self.devid is not None:
      oprot.writeFieldBegin('devid', TType.STRING, 1)
      oprot.writeString(self.devid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class del_device_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('del_device_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modify_device_args:
  """
  Attributes:
   - dev
   - node
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dev', (Device, Device.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'node', (Node, Node.thrift_spec), None, ), # 2
  )

  def __init__(self, dev=None, node=None,):
    self.dev = dev
    self.node = node

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dev = Device()
          self.dev.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.node = Node()
          self.node.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modify_device_args')
    if self.dev is not None:
      oprot.writeFieldBegin('dev', TType.STRUCT, 1)
      self.dev.write(oprot)
      oprot.writeFieldEnd()
    if self.node is not None:
      oprot.writeFieldBegin('node', TType.STRUCT, 2)
      self.node.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modify_device_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Device, Device.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Device()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modify_device_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_device_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_device_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_device_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Device, Device.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype902, _size899) = iprot.readListBegin()
          for _i903 in xrange(_size899):
            _elem904 = Device()
            _elem904.read(iprot)
            self.success.append(_elem904)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_device_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter905 in self.success:
        iter905.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_node_args:
  """
  Attributes:
   - node_name
   - ipl
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node_name', None, None, ), # 1
    (2, TType.LIST, 'ipl', (TType.STRING,None), None, ), # 2
    (3, TType.I32, 'status', None, None, ), # 3
  )

  def __init__(self, node_name=None, ipl=None, status=None,):
    self.node_name = node_name
    self.ipl = ipl
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.ipl = []
          (_etype909, _size906) = iprot.readListBegin()
          for _i910 in xrange(_size906):
            _elem911 = iprot.readString();
            self.ipl.append(_elem911)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_node_args')
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 1)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    if self.ipl is not None:
      oprot.writeFieldBegin('ipl', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.ipl))
      for iter912 in self.ipl:
        oprot.writeString(iter912)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 3)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alter_node_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Node, Node.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Node()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alter_node_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class find_best_nodes_args:
  """
  Attributes:
   - nr
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'nr', None, None, ), # 1
  )

  def __init__(self, nr=None,):
    self.nr = nr

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.nr = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('find_best_nodes_args')
    if self.nr is not None:
      oprot.writeFieldBegin('nr', TType.I32, 1)
      oprot.writeI32(self.nr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class find_best_nodes_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Node, Node.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype916, _size913) = iprot.readListBegin()
          for _i917 in xrange(_size913):
            _elem918 = Node()
            _elem918.read(iprot)
            self.success.append(_elem918)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('find_best_nodes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter919 in self.success:
        iter919.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class find_best_nodes_in_groups_args:
  """
  Attributes:
   - dbName
   - tableName
   - nr
   - policy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.I32, 'nr', None, None, ), # 3
    (4, TType.I32, 'policy', None, None, ), # 4
  )

  def __init__(self, dbName=None, tableName=None, nr=None, policy=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.nr = nr
    self.policy = policy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.nr = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.policy = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('find_best_nodes_in_groups_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.nr is not None:
      oprot.writeFieldBegin('nr', TType.I32, 3)
      oprot.writeI32(self.nr)
      oprot.writeFieldEnd()
    if self.policy is not None:
      oprot.writeFieldBegin('policy', TType.I32, 4)
      oprot.writeI32(self.policy)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class find_best_nodes_in_groups_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Node, Node.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype923, _size920) = iprot.readListBegin()
          for _i924 in xrange(_size920):
            _elem925 = Node()
            _elem925.read(iprot)
            self.success.append(_elem925)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('find_best_nodes_in_groups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter926 in self.success:
        iter926.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_nodes_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_nodes_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_all_nodes_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Node, Node.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype930, _size927) = iprot.readListBegin()
          for _i931 in xrange(_size927):
            _elem932 = Node()
            _elem932.read(iprot)
            self.success.append(_elem932)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_all_nodes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter933 in self.success:
        iter933.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDMStatus_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDMStatus_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDMStatus_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDMStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNodeInfo_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNodeInfo_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNodeInfo_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNodeInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate_in_args:
  """
  Attributes:
   - tbl
   - files
   - idxs
   - from_db
   - to_devid
   - fileMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
    (2, TType.MAP, 'files', (TType.I64,None,TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'idxs', (TType.STRUCT,(Index, Index.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'from_db', None, None, ), # 4
    (5, TType.STRING, 'to_devid', None, None, ), # 5
    (6, TType.MAP, 'fileMap', (TType.I64,None,TType.STRUCT,(SFileLocation, SFileLocation.thrift_spec)), None, ), # 6
  )

  def __init__(self, tbl=None, files=None, idxs=None, from_db=None, to_devid=None, fileMap=None,):
    self.tbl = tbl
    self.files = files
    self.idxs = idxs
    self.from_db = from_db
    self.to_devid = to_devid
    self.fileMap = fileMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.files = {}
          (_ktype935, _vtype936, _size934 ) = iprot.readMapBegin() 
          for _i938 in xrange(_size934):
            _key939 = iprot.readI64();
            _val940 = SFile()
            _val940.read(iprot)
            self.files[_key939] = _val940
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.idxs = []
          (_etype944, _size941) = iprot.readListBegin()
          for _i945 in xrange(_size941):
            _elem946 = Index()
            _elem946.read(iprot)
            self.idxs.append(_elem946)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.from_db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.to_devid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.fileMap = {}
          (_ktype948, _vtype949, _size947 ) = iprot.readMapBegin() 
          for _i951 in xrange(_size947):
            _key952 = iprot.readI64();
            _val953 = SFileLocation()
            _val953.read(iprot)
            self.fileMap[_key952] = _val953
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate_in_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.files is not None:
      oprot.writeFieldBegin('files', TType.MAP, 2)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.files))
      for kiter954,viter955 in self.files.items():
        oprot.writeI64(kiter954)
        viter955.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.idxs is not None:
      oprot.writeFieldBegin('idxs', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.idxs))
      for iter956 in self.idxs:
        iter956.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.from_db is not None:
      oprot.writeFieldBegin('from_db', TType.STRING, 4)
      oprot.writeString(self.from_db)
      oprot.writeFieldEnd()
    if self.to_devid is not None:
      oprot.writeFieldBegin('to_devid', TType.STRING, 5)
      oprot.writeString(self.to_devid)
      oprot.writeFieldEnd()
    if self.fileMap is not None:
      oprot.writeFieldBegin('fileMap', TType.MAP, 6)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.fileMap))
      for kiter957,viter958 in self.fileMap.items():
        oprot.writeI64(kiter957)
        viter958.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate_in_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate_in_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate_stage1_args:
  """
  Attributes:
   - dbName
   - tableName
   - files
   - to_db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.LIST, 'files', (TType.I64,None), None, ), # 3
    (4, TType.STRING, 'to_db', None, None, ), # 4
  )

  def __init__(self, dbName=None, tableName=None, files=None, to_db=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.files = files
    self.to_db = to_db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.files = []
          (_etype962, _size959) = iprot.readListBegin()
          for _i963 in xrange(_size959):
            _elem964 = iprot.readI64();
            self.files.append(_elem964)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.to_db = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate_stage1_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.files is not None:
      oprot.writeFieldBegin('files', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.files))
      for iter965 in self.files:
        oprot.writeI64(iter965)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.to_db is not None:
      oprot.writeFieldBegin('to_db', TType.STRING, 4)
      oprot.writeString(self.to_db)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate_stage1_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SFileLocation, SFileLocation.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype969, _size966) = iprot.readListBegin()
          for _i970 in xrange(_size966):
            _elem971 = SFileLocation()
            _elem971.read(iprot)
            self.success.append(_elem971)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate_stage1_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter972 in self.success:
        iter972.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate_stage2_args:
  """
  Attributes:
   - dbName
   - tableName
   - files
   - from_db
   - to_db
   - to_devid
   - user
   - password
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.LIST, 'files', (TType.I64,None), None, ), # 3
    (4, TType.STRING, 'from_db', None, None, ), # 4
    (5, TType.STRING, 'to_db', None, None, ), # 5
    (6, TType.STRING, 'to_devid', None, None, ), # 6
    (7, TType.STRING, 'user', None, None, ), # 7
    (8, TType.STRING, 'password', None, None, ), # 8
  )

  def __init__(self, dbName=None, tableName=None, files=None, from_db=None, to_db=None, to_devid=None, user=None, password=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.files = files
    self.from_db = from_db
    self.to_db = to_db
    self.to_devid = to_devid
    self.user = user
    self.password = password

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.files = []
          (_etype976, _size973) = iprot.readListBegin()
          for _i977 in xrange(_size973):
            _elem978 = iprot.readI64();
            self.files.append(_elem978)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.from_db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.to_db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.to_devid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate_stage2_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.files is not None:
      oprot.writeFieldBegin('files', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.files))
      for iter979 in self.files:
        oprot.writeI64(iter979)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.from_db is not None:
      oprot.writeFieldBegin('from_db', TType.STRING, 4)
      oprot.writeString(self.from_db)
      oprot.writeFieldEnd()
    if self.to_db is not None:
      oprot.writeFieldBegin('to_db', TType.STRING, 5)
      oprot.writeString(self.to_db)
      oprot.writeFieldEnd()
    if self.to_devid is not None:
      oprot.writeFieldBegin('to_devid', TType.STRING, 6)
      oprot.writeString(self.to_devid)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 7)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 8)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate_stage2_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate_stage2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate2_in_args:
  """
  Attributes:
   - tbl
   - parts
   - idxs
   - from_db
   - to_nas_devid
   - fileMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ), # 1
    (2, TType.LIST, 'parts', (TType.STRUCT,(Partition, Partition.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'idxs', (TType.STRUCT,(Index, Index.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'from_db', None, None, ), # 4
    (5, TType.STRING, 'to_nas_devid', None, None, ), # 5
    (6, TType.MAP, 'fileMap', (TType.I64,None,TType.STRUCT,(SFileLocation, SFileLocation.thrift_spec)), None, ), # 6
  )

  def __init__(self, tbl=None, parts=None, idxs=None, from_db=None, to_nas_devid=None, fileMap=None,):
    self.tbl = tbl
    self.parts = parts
    self.idxs = idxs
    self.from_db = from_db
    self.to_nas_devid = to_nas_devid
    self.fileMap = fileMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.tbl = Table()
          self.tbl.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype983, _size980) = iprot.readListBegin()
          for _i984 in xrange(_size980):
            _elem985 = Partition()
            _elem985.read(iprot)
            self.parts.append(_elem985)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.idxs = []
          (_etype989, _size986) = iprot.readListBegin()
          for _i990 in xrange(_size986):
            _elem991 = Index()
            _elem991.read(iprot)
            self.idxs.append(_elem991)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.from_db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.to_nas_devid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.fileMap = {}
          (_ktype993, _vtype994, _size992 ) = iprot.readMapBegin() 
          for _i996 in xrange(_size992):
            _key997 = iprot.readI64();
            _val998 = SFileLocation()
            _val998.read(iprot)
            self.fileMap[_key997] = _val998
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate2_in_args')
    if self.tbl is not None:
      oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
      self.tbl.write(oprot)
      oprot.writeFieldEnd()
    if self.parts is not None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.parts))
      for iter999 in self.parts:
        iter999.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.idxs is not None:
      oprot.writeFieldBegin('idxs', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.idxs))
      for iter1000 in self.idxs:
        iter1000.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.from_db is not None:
      oprot.writeFieldBegin('from_db', TType.STRING, 4)
      oprot.writeString(self.from_db)
      oprot.writeFieldEnd()
    if self.to_nas_devid is not None:
      oprot.writeFieldBegin('to_nas_devid', TType.STRING, 5)
      oprot.writeString(self.to_nas_devid)
      oprot.writeFieldEnd()
    if self.fileMap is not None:
      oprot.writeFieldBegin('fileMap', TType.MAP, 6)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.fileMap))
      for kiter1001,viter1002 in self.fileMap.items():
        oprot.writeI64(kiter1001)
        viter1002.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate2_in_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate2_in_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate2_stage1_args:
  """
  Attributes:
   - dbName
   - tableName
   - partNames
   - to_db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.LIST, 'partNames', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'to_db', None, None, ), # 4
  )

  def __init__(self, dbName=None, tableName=None, partNames=None, to_db=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.partNames = partNames
    self.to_db = to_db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.partNames = []
          (_etype1006, _size1003) = iprot.readListBegin()
          for _i1007 in xrange(_size1003):
            _elem1008 = iprot.readString();
            self.partNames.append(_elem1008)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.to_db = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate2_stage1_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partNames is not None:
      oprot.writeFieldBegin('partNames', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.partNames))
      for iter1009 in self.partNames:
        oprot.writeString(iter1009)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.to_db is not None:
      oprot.writeFieldBegin('to_db', TType.STRING, 4)
      oprot.writeString(self.to_db)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate2_stage1_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SFileLocation, SFileLocation.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1013, _size1010) = iprot.readListBegin()
          for _i1014 in xrange(_size1010):
            _elem1015 = SFileLocation()
            _elem1015.read(iprot)
            self.success.append(_elem1015)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate2_stage1_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1016 in self.success:
        iter1016.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate2_stage2_args:
  """
  Attributes:
   - dbName
   - tableName
   - partNames
   - from_db
   - to_db
   - to_nas_devid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.LIST, 'partNames', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'from_db', None, None, ), # 4
    (5, TType.STRING, 'to_db', None, None, ), # 5
    (6, TType.STRING, 'to_nas_devid', None, None, ), # 6
  )

  def __init__(self, dbName=None, tableName=None, partNames=None, from_db=None, to_db=None, to_nas_devid=None,):
    self.dbName = dbName
    self.tableName = tableName
    self.partNames = partNames
    self.from_db = from_db
    self.to_db = to_db
    self.to_nas_devid = to_nas_devid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.partNames = []
          (_etype1020, _size1017) = iprot.readListBegin()
          for _i1021 in xrange(_size1017):
            _elem1022 = iprot.readString();
            self.partNames.append(_elem1022)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.from_db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.to_db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.to_nas_devid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate2_stage2_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.partNames is not None:
      oprot.writeFieldBegin('partNames', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.partNames))
      for iter1023 in self.partNames:
        oprot.writeString(iter1023)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.from_db is not None:
      oprot.writeFieldBegin('from_db', TType.STRING, 4)
      oprot.writeString(self.from_db)
      oprot.writeFieldEnd()
    if self.to_db is not None:
      oprot.writeFieldBegin('to_db', TType.STRING, 5)
      oprot.writeString(self.to_db)
      oprot.writeFieldEnd()
    if self.to_nas_devid is not None:
      oprot.writeFieldBegin('to_nas_devid', TType.STRING, 6)
      oprot.writeString(self.to_nas_devid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class migrate2_stage2_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('migrate2_stage2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMP_args:
  """
  Attributes:
   - node_name
   - devid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'node_name', None, None, ), # 1
    (2, TType.STRING, 'devid', None, None, ), # 2
  )

  def __init__(self, node_name=None, devid=None,):
    self.node_name = node_name
    self.devid = devid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.node_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.devid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMP_args')
    if self.node_name is not None:
      oprot.writeFieldBegin('node_name', TType.STRING, 1)
      oprot.writeString(self.node_name)
      oprot.writeFieldEnd()
    if self.devid is not None:
      oprot.writeFieldBegin('devid', TType.STRING, 2)
      oprot.writeString(self.devid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMP_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMP_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSessionId_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSessionId_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSessionId_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSessionId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createSchema_args:
  """
  Attributes:
   - schema
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'schema', (GlobalSchema, GlobalSchema.thrift_spec), None, ), # 1
  )

  def __init__(self, schema=None,):
    self.schema = schema

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.schema = GlobalSchema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createSchema_args')
    if self.schema is not None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 1)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createSchema_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = InvalidObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createSchema_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modifySchema_args:
  """
  Attributes:
   - schemaName
   - schema
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'schemaName', None, None, ), # 1
    (2, TType.STRUCT, 'schema', (GlobalSchema, GlobalSchema.thrift_spec), None, ), # 2
  )

  def __init__(self, schemaName=None, schema=None,):
    self.schemaName = schemaName
    self.schema = schema

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema = GlobalSchema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modifySchema_args')
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 1)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    if self.schema is not None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 2)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modifySchema_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modifySchema_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteSchema_args:
  """
  Attributes:
   - schemaName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'schemaName', None, None, ), # 1
  )

  def __init__(self, schemaName=None,):
    self.schemaName = schemaName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteSchema_args')
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 1)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteSchema_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteSchema_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchemas_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchemas_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSchemas_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(GlobalSchema, GlobalSchema.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1027, _size1024) = iprot.readListBegin()
          for _i1028 in xrange(_size1024):
            _elem1029 = GlobalSchema()
            _elem1029.read(iprot)
            self.success.append(_elem1029)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSchemas_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1030 in self.success:
        iter1030.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSchemaByName_args:
  """
  Attributes:
   - schemaName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'schemaName', None, None, ), # 1
  )

  def __init__(self, schemaName=None,):
    self.schemaName = schemaName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSchemaByName_args')
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 1)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSchemaByName_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GlobalSchema, GlobalSchema.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GlobalSchema()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = NoSuchObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSchemaByName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTableNodeGroups_args:
  """
  Attributes:
   - dbName
   - tabName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tabName', None, None, ), # 2
  )

  def __init__(self, dbName=None, tabName=None,):
    self.dbName = dbName
    self.tabName = tabName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tabName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTableNodeGroups_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tabName is not None:
      oprot.writeFieldBegin('tabName', TType.STRING, 2)
      oprot.writeString(self.tabName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTableNodeGroups_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(NodeGroup, NodeGroup.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1034, _size1031) = iprot.readListBegin()
          for _i1035 in xrange(_size1031):
            _elem1036 = NodeGroup()
            _elem1036.read(iprot)
            self.success.append(_elem1036)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTableNodeGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1037 in self.success:
        iter1037.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTableNodeFiles_args:
  """
  Attributes:
   - dbName
   - tabName
   - nodeName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tabName', None, None, ), # 2
    (3, TType.STRING, 'nodeName', None, None, ), # 3
  )

  def __init__(self, dbName=None, tabName=None, nodeName=None,):
    self.dbName = dbName
    self.tabName = tabName
    self.nodeName = nodeName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tabName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.nodeName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTableNodeFiles_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tabName is not None:
      oprot.writeFieldBegin('tabName', TType.STRING, 2)
      oprot.writeString(self.tabName)
      oprot.writeFieldEnd()
    if self.nodeName is not None:
      oprot.writeFieldBegin('nodeName', TType.STRING, 3)
      oprot.writeString(self.nodeName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTableNodeFiles_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1041, _size1038) = iprot.readListBegin()
          for _i1042 in xrange(_size1038):
            _elem1043 = SFile()
            _elem1043.read(iprot)
            self.success.append(_elem1043)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTableNodeFiles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1044 in self.success:
        iter1044.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTableFiles_args:
  """
  Attributes:
   - dbName
   - tabName
   - from
   - to
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tabName', None, None, ), # 2
    (3, TType.I32, 'from', None, None, ), # 3
    (4, TType.I32, 'to', None, None, ), # 4
  )

  def __init__(self, dbName=None, tabName=None, from=None, to=None,):
    self.dbName = dbName
    self.tabName = tabName
    self.from = from
    self.to = to

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tabName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.from = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.to = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTableFiles_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tabName is not None:
      oprot.writeFieldBegin('tabName', TType.STRING, 2)
      oprot.writeString(self.tabName)
      oprot.writeFieldEnd()
    if self.from is not None:
      oprot.writeFieldBegin('from', TType.I32, 3)
      oprot.writeI32(self.from)
      oprot.writeFieldEnd()
    if self.to is not None:
      oprot.writeFieldBegin('to', TType.I32, 4)
      oprot.writeI32(self.to)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTableFiles_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1048, _size1045) = iprot.readListBegin()
          for _i1049 in xrange(_size1045):
            _elem1050 = iprot.readI64();
            self.success.append(_elem1050)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTableFiles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I64, len(self.success))
      for iter1051 in self.success:
        oprot.writeI64(iter1051)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listFilesByDigest_args:
  """
  Attributes:
   - digest
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'digest', None, None, ), # 1
  )

  def __init__(self, digest=None,):
    self.digest = digest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.digest = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listFilesByDigest_args')
    if self.digest is not None:
      oprot.writeFieldBegin('digest', TType.STRING, 1)
      oprot.writeString(self.digest)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listFilesByDigest_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1055, _size1052) = iprot.readListBegin()
          for _i1056 in xrange(_size1052):
            _elem1057 = iprot.readI64();
            self.success.append(_elem1057)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listFilesByDigest_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I64, len(self.success))
      for iter1058 in self.success:
        oprot.writeI64(iter1058)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class filterTableFiles_args:
  """
  Attributes:
   - dbName
   - tabName
   - values
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tabName', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(SplitValue, SplitValue.thrift_spec)), None, ), # 3
  )

  def __init__(self, dbName=None, tabName=None, values=None,):
    self.dbName = dbName
    self.tabName = tabName
    self.values = values

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tabName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype1062, _size1059) = iprot.readListBegin()
          for _i1063 in xrange(_size1059):
            _elem1064 = SplitValue()
            _elem1064.read(iprot)
            self.values.append(_elem1064)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('filterTableFiles_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tabName is not None:
      oprot.writeFieldBegin('tabName', TType.STRING, 2)
      oprot.writeString(self.tabName)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter1065 in self.values:
        iter1065.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class filterTableFiles_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(SFile, SFile.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1069, _size1066) = iprot.readListBegin()
          for _i1070 in xrange(_size1066):
            _elem1071 = SFile()
            _elem1071.read(iprot)
            self.success.append(_elem1071)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('filterTableFiles_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1072 in self.success:
        iter1072.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class truncTableFiles_args:
  """
  Attributes:
   - dbName
   - tabName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tabName', None, None, ), # 2
  )

  def __init__(self, dbName=None, tabName=None,):
    self.dbName = dbName
    self.tabName = tabName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tabName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('truncTableFiles_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tabName is not None:
      oprot.writeFieldBegin('tabName', TType.STRING, 2)
      oprot.writeString(self.tabName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class truncTableFiles_result:
  """
  Attributes:
   - o1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, o1=None,):
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('truncTableFiles_result')
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addNodeGroup_args:
  """
  Attributes:
   - ng
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ng', (NodeGroup, NodeGroup.thrift_spec), None, ), # 1
  )

  def __init__(self, ng=None,):
    self.ng = ng

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ng = NodeGroup()
          self.ng.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addNodeGroup_args')
    if self.ng is not None:
      oprot.writeFieldBegin('ng', TType.STRUCT, 1)
      self.ng.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addNodeGroup_result:
  """
  Attributes:
   - success
   - o1
   - o2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, o1=None, o2=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = AlreadyExistsException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = MetaException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addNodeGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modifyNodeGroup_args:
  """
  Attributes:
   - schemaName
   - ng
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'schemaName', None, None, ), # 1
    (2, TType.STRUCT, 'ng', (NodeGroup, NodeGroup.thrift_spec), None, ), # 2
  )

  def __init__(self, schemaName=None, ng=None,):
    self.schemaName = schemaName
    self.ng = ng

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ng = NodeGroup()
          self.ng.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modifyNodeGroup_args')
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 1)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    if self.ng is not None:
      oprot.writeFieldBegin('ng', TType.STRUCT, 2)
      self.ng.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class modifyNodeGroup_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('modifyNodeGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteNodeGroup_args:
  """
  Attributes:
   - ng
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ng', (NodeGroup, NodeGroup.thrift_spec), None, ), # 1
  )

  def __init__(self, ng=None,):
    self.ng = ng

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ng = NodeGroup()
          self.ng.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteNodeGroup_args')
    if self.ng is not None:
      oprot.writeFieldBegin('ng', TType.STRUCT, 1)
      self.ng.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteNodeGroup_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteNodeGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNodeGroups_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNodeGroups_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNodeGroups_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(NodeGroup, NodeGroup.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1076, _size1073) = iprot.readListBegin()
          for _i1077 in xrange(_size1073):
            _elem1078 = NodeGroup()
            _elem1078.read(iprot)
            self.success.append(_elem1078)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNodeGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1079 in self.success:
        iter1079.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listDBNodeGroups_args:
  """
  Attributes:
   - dbName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
  )

  def __init__(self, dbName=None,):
    self.dbName = dbName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listDBNodeGroups_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listDBNodeGroups_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(NodeGroup, NodeGroup.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1083, _size1080) = iprot.readListBegin()
          for _i1084 in xrange(_size1080):
            _elem1085 = NodeGroup()
            _elem1085.read(iprot)
            self.success.append(_elem1085)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listDBNodeGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1086 in self.success:
        iter1086.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNodeGroupByNames_args:
  """
  Attributes:
   - ngNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'ngNames', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, ngNames=None,):
    self.ngNames = ngNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.ngNames = []
          (_etype1090, _size1087) = iprot.readListBegin()
          for _i1091 in xrange(_size1087):
            _elem1092 = iprot.readString();
            self.ngNames.append(_elem1092)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNodeGroupByNames_args')
    if self.ngNames is not None:
      oprot.writeFieldBegin('ngNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.ngNames))
      for iter1093 in self.ngNames:
        oprot.writeString(iter1093)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNodeGroupByNames_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(NodeGroup, NodeGroup.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1097, _size1094) = iprot.readListBegin()
          for _i1098 in xrange(_size1094):
            _elem1099 = NodeGroup()
            _elem1099.read(iprot)
            self.success.append(_elem1099)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNodeGroupByNames_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1100 in self.success:
        iter1100.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addTableNodeDist_args:
  """
  Attributes:
   - db
   - tab
   - ng
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'tab', None, None, ), # 2
    (3, TType.LIST, 'ng', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db=None, tab=None, ng=None,):
    self.db = db
    self.tab = tab
    self.ng = ng

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tab = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.ng = []
          (_etype1104, _size1101) = iprot.readListBegin()
          for _i1105 in xrange(_size1101):
            _elem1106 = iprot.readString();
            self.ng.append(_elem1106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addTableNodeDist_args')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.tab is not None:
      oprot.writeFieldBegin('tab', TType.STRING, 2)
      oprot.writeString(self.tab)
      oprot.writeFieldEnd()
    if self.ng is not None:
      oprot.writeFieldBegin('ng', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.ng))
      for iter1107 in self.ng:
        oprot.writeString(iter1107)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addTableNodeDist_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addTableNodeDist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteTableNodeDist_args:
  """
  Attributes:
   - db
   - tab
   - ng
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'db', None, None, ), # 1
    (2, TType.STRING, 'tab', None, None, ), # 2
    (3, TType.LIST, 'ng', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, db=None, tab=None, ng=None,):
    self.db = db
    self.tab = tab
    self.ng = ng

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.db = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tab = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.ng = []
          (_etype1111, _size1108) = iprot.readListBegin()
          for _i1112 in xrange(_size1108):
            _elem1113 = iprot.readString();
            self.ng.append(_elem1113)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteTableNodeDist_args')
    if self.db is not None:
      oprot.writeFieldBegin('db', TType.STRING, 1)
      oprot.writeString(self.db)
      oprot.writeFieldEnd()
    if self.tab is not None:
      oprot.writeFieldBegin('tab', TType.STRING, 2)
      oprot.writeString(self.tab)
      oprot.writeFieldEnd()
    if self.ng is not None:
      oprot.writeFieldBegin('ng', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.ng))
      for iter1114 in self.ng:
        oprot.writeString(iter1114)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteTableNodeDist_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteTableNodeDist_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTableNodeDists_args:
  """
  Attributes:
   - dbName
   - tabName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'tabName', None, None, ), # 2
  )

  def __init__(self, dbName=None, tabName=None,):
    self.dbName = dbName
    self.tabName = tabName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tabName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTableNodeDists_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.tabName is not None:
      oprot.writeFieldBegin('tabName', TType.STRING, 2)
      oprot.writeString(self.tabName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTableNodeDists_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(NodeGroup, NodeGroup.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype1118, _size1115) = iprot.readListBegin()
          for _i1119 in xrange(_size1115):
            _elem1120 = NodeGroup()
            _elem1120.read(iprot)
            self.success.append(_elem1120)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTableNodeDists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter1121 in self.success:
        iter1121.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class assiginSchematoDB_args:
  """
  Attributes:
   - dbName
   - schemaName
   - fileSplitKeys
   - part_keys
   - ngs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dbName', None, None, ), # 1
    (2, TType.STRING, 'schemaName', None, None, ), # 2
    (3, TType.LIST, 'fileSplitKeys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'part_keys', (TType.STRUCT,(FieldSchema, FieldSchema.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'ngs', (TType.STRUCT,(NodeGroup, NodeGroup.thrift_spec)), None, ), # 5
  )

  def __init__(self, dbName=None, schemaName=None, fileSplitKeys=None, part_keys=None, ngs=None,):
    self.dbName = dbName
    self.schemaName = schemaName
    self.fileSplitKeys = fileSplitKeys
    self.part_keys = part_keys
    self.ngs = ngs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dbName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.schemaName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.fileSplitKeys = []
          (_etype1125, _size1122) = iprot.readListBegin()
          for _i1126 in xrange(_size1122):
            _elem1127 = FieldSchema()
            _elem1127.read(iprot)
            self.fileSplitKeys.append(_elem1127)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.part_keys = []
          (_etype1131, _size1128) = iprot.readListBegin()
          for _i1132 in xrange(_size1128):
            _elem1133 = FieldSchema()
            _elem1133.read(iprot)
            self.part_keys.append(_elem1133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.ngs = []
          (_etype1137, _size1134) = iprot.readListBegin()
          for _i1138 in xrange(_size1134):
            _elem1139 = NodeGroup()
            _elem1139.read(iprot)
            self.ngs.append(_elem1139)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('assiginSchematoDB_args')
    if self.dbName is not None:
      oprot.writeFieldBegin('dbName', TType.STRING, 1)
      oprot.writeString(self.dbName)
      oprot.writeFieldEnd()
    if self.schemaName is not None:
      oprot.writeFieldBegin('schemaName', TType.STRING, 2)
      oprot.writeString(self.schemaName)
      oprot.writeFieldEnd()
    if self.fileSplitKeys is not None:
      oprot.writeFieldBegin('fileSplitKeys', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.fileSplitKeys))
      for iter1140 in self.fileSplitKeys:
        iter1140.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.part_keys is not None:
      oprot.writeFieldBegin('part_keys', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.part_keys))
      for iter1141 in self.part_keys:
        iter1141.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ngs is not None:
      oprot.writeFieldBegin('ngs', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.ngs))
      for iter1142 in self.ngs:
        iter1142.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class assiginSchematoDB_result:
  """
  Attributes:
   - success
   - o1
   - o2
   - o3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, o1=None, o2=None, o3=None,):
    self.success = success
    self.o1 = o1
    self.o2 = o2
    self.o3 = o3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = InvalidObjectException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.o2 = NoSuchObjectException()
          self.o2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.o3 = MetaException()
          self.o3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('assiginSchematoDB_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    if self.o2 is not None:
      oprot.writeFieldBegin('o2', TType.STRUCT, 2)
      self.o2.write(oprot)
      oprot.writeFieldEnd()
    if self.o3 is not None:
      oprot.writeFieldBegin('o3', TType.STRUCT, 3)
      self.o3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class statFileSystem_args:
  """
  Attributes:
   - begin_time
   - end_time
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'begin_time', None, None, ), # 1
    (2, TType.I64, 'end_time', None, None, ), # 2
  )

  def __init__(self, begin_time=None, end_time=None,):
    self.begin_time = begin_time
    self.end_time = end_time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.begin_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.end_time = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('statFileSystem_args')
    if self.begin_time is not None:
      oprot.writeFieldBegin('begin_time', TType.I64, 1)
      oprot.writeI64(self.begin_time)
      oprot.writeFieldEnd()
    if self.end_time is not None:
      oprot.writeFieldBegin('end_time', TType.I64, 2)
      oprot.writeI64(self.end_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class statFileSystem_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (statfs, statfs.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = statfs()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('statFileSystem_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMaxFid_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMaxFid_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMaxFid_result:
  """
  Attributes:
   - success
   - o1
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, o1=None,):
    self.success = success
    self.o1 = o1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.o1 = MetaException()
          self.o1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMaxFid_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.o1 is not None:
      oprot.writeFieldBegin('o1', TType.STRUCT, 1)
      self.o1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
